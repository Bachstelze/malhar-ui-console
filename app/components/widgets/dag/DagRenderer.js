/*
 * Copyright (c) 2014 DataTorrent, Inc. ALL Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

'use strict';

angular.module('app.components.widgets.dag.DagRenderer', [])
  .factory('DagRenderer', function (settings) {
    function DagRenderer(element, dagPlan) {
      this.onlyScrollOnAlt = true;
      this.element = element;
      this.svgMain = jQuery(this.element).find('.svg-main');
      this.graph = this.buildGraph(dagPlan);
      this.streams = dagPlan.streams;
    }

    DagRenderer.prototype = {
      displayGraph: function () {
        // render legend
        this.renderLegend(this.element);

        // Renders the main graph
        this.renderGraph(this.graph, this.svgMain.get(0)); //TODO no jQuery
      },

      buildGraph: function (data) {
        var nodes = [];

        _.each(data.operators, function (value) {
          var node = { id: value.name, value: { label: value.name } };
          nodes.push(node);
        });

        var links = [];

        _.each(data.streams, function (stream) {
          var source = stream.source.operatorName;
          _.each(stream.sinks, function (sink) {
            var target = sink.operatorName;
            var link = { u: source, v: target, value: { label: stream.name } };
            links.push(link);
          });
        });

        var graph = { nodes: nodes, links: links };
        return graph;
      },

      postRender: function() {
      },

      updateHeight: function () {
        this.updateSvgMainHeight();

        var main = this.svgMain.find('g > g');
        var main_dimensions = main.get(0).getBoundingClientRect();
        this.svgMain.find('.dag-minimap').remove();
        this.renderMinimap(this.d3Graph, main_dimensions, this.svgMain);
      },

      updateSvgMainHeight: function () {
        var offset = this.svgMain[0].getBoundingClientRect().top - this.element[0].getBoundingClientRect().top;
        this.svgMain.height(this.element.height() - offset);
      },

      renderLegend: function (element) {
        var svgParent = jQuery(element).find('.svg-legend'); //TODO no jQuery
        var elem = svgParent.children('g').get(0);
        var legend = d3.select(elem);

        // Create a data array from all dag edge types (in settings)
        // ['NOT ASSIGNED', 'THREAD_LOCAL', 'CONTAINER_LOCAL', 'NODE_LOCAL', 'RACK_LOCAL'];
        var data = _.map(settings.dag.edges, function (displayProperties, locality) {
          // Looks for a 'displayName' key in the properties first,
          // otherwise just makes the key the label.
          var label = displayProperties.displayName ? displayProperties.displayName : locality;
          return {
            label: label,
            dasharray: displayProperties.dasharray
          };
        });

        // Dimensions for location of label and lines
        var baseY = 20;
        var spaceY = 20;
        var lineBaseY = 15;
        var lineBaseX = 160;
        var lineLength = 200;

        // Add the labels to the legend
        legend.selectAll('text')
          .data(data)
          .enter()
          .append('text')
          .attr('y', function (d, i) {
            return baseY + i * spaceY;
          })
          .text(function (d) {
            return d.label;
          });

        // Add the line samples
        var points = [
          {x: lineBaseX},
          {x: lineBaseX + lineLength}
        ];

        legend.selectAll('g .edge')
          .data(data)
          .enter()
          .append('g')
          .classed('edgePath', true)
          .append('path')
          .attr('marker-end', 'url(#arrowhead)')
          .attr('stroke-dasharray', function (d) {
            return d.dasharray;
          })
          .attr('d', function (d, lineIndex) {
            return d3.svg.line()
              .x(function (d) {
                return d.x;
              })
              .y(function () {
                return lineBaseY + lineIndex * spaceY;
              })
            (points);
          });
      },

      /**
       * Renders the main graph itself
       * @param  {Object} graph       Object generated by buildGraph
       * @param  {Element} selector   The element that the graph should be added to
       * @return {void}
       */
      renderGraph: function (graph, selector) {
        var svgParent = jQuery(selector);
        var nodes = graph.nodes;
        var links = graph.links;

        var graphElem = svgParent.children('g').get(0);
        var svg = d3.select(graphElem);

        // Remove all inner elements
        svg.selectAll('*').remove();

        // Create renderer
        var renderer = new dagreD3.Renderer();

        // Extend original post render function
        var oldPostRender = this.defaultPostRender;
        renderer._postRender = function (graph, root) {
          oldPostRender.call(renderer, graph, root);
          this.graph = graph;
          this.svgRoot = root;
          this.postRender(graph, root);
        }.bind(this);

        // Define the function that calculates the dimensions for
        // an edge in the graph (adds 10 pixels to either side)
        renderer._calculateEdgeDimensions = function (group, value) {
          var bbox = group.getBBox();
          value.width = bbox.width + 10;
          value.height = bbox.height;
        };

        // Create the layout object
        var layout = dagreD3.layout()
          // DAG should go from left to right (LR)
          .rankDir('LR');

        // Run the renderer
        var d3_graph = renderer.layout(layout).run(dagreD3.json.decode(nodes, links), svg.append('g'));
        this.d3Graph = d3_graph;

        var main = svgParent.find('g > g');
        var main_dimensions = main.get(0).getBoundingClientRect();

        var autoHeight = !this.element.parent()[0].style.height; //TODO use widget model size attribute

        if (autoHeight) {
          // Adjusting height to content
          var h = main_dimensions.height;
          var newHeight = h + 50;
          newHeight = newHeight < 200 ? 200 : newHeight;
          newHeight = newHeight > 500 ? 500 : newHeight;
          svgParent.height(newHeight);
        } else {
          this.updateSvgMainHeight();
        }

        var self = this;

        // Zoom
        var zoomBehavior = this.zoomBehavior = d3.behavior
          .zoom()
          .scaleExtent([0.1, 4]);

        var lastZoomLevel = this.lastZoomLevel = {
          translate: zoomBehavior.translate(),
          scale: zoomBehavior.scale()
        };

        zoomBehavior.on('zoom', function() {
          var ev = d3.event;

          if (self.onlyScrollOnAlt && !ev.sourceEvent.altKey && (ev.sourceEvent.type === 'wheel' || ev.sourceEvent.type === 'mousewheel')) {
            var sev = ev.sourceEvent;
            window.scrollBy(0, sev.deltaY);
            zoomBehavior.translate(lastZoomLevel.translate);
            zoomBehavior.scale(lastZoomLevel.scale);
          } else {
            lastZoomLevel.translate = ev.translate;
            lastZoomLevel.scale = ev.scale;
            svg.select('g')
              .attr('transform', 'translate(' + ev.translate + ') scale(' + ev.scale + ')');
            self.updateMinimap(svgParent, ev.translate, ev.scale);
          }

        });

        // Render the minimap/flyover/birds eye view
        this.renderMinimap(d3_graph, main_dimensions, svgParent);

        zoomBehavior(d3.select(svgParent.get(0)));
      },

      // Due to issue with dagre-d3 library
      defaultPostRender: function (graph, root) {
        if (graph.isDirected() && root.select('#arrowhead').empty()) {
          root
            .append('svg:defs')
            .append('svg:marker')
            .attr('id', 'arrowhead')
            .attr('viewBox', '0 0 10 10')
            .attr('refX', 8)
            .attr('refY', 5)
            // .attr('markerUnits', 'strokewidth')
            .attr('markerWidth', 8)
            .attr('markerHeight', 5)
            .attr('orient', 'auto')
            .attr('style', 'fill: #333')
            .append('svg:path')
            .attr('d', 'M 0 0 L 10 5 L 0 10 z');
        }
      },

      /**
       * Creates minimap of the dag view.
       * @param  {d3.Digraph}   graph
       * @param  {Object}       graph_dimensions    Contains width and height attributes of dag boundaries
       * @param  {jQuery}       root                Root svg element as a jquery element
       * @return {void}
       */
      renderMinimap: function(graph, graph_dimensions, $root) {
        // Reference to the group that gets transform attribute updated.
        var graphGroup = $root.find('g>g')[0];

        // Padding for the map
        var mapPadding = 10;
        var halfMapPadding = mapPadding/2;

        // Width and Height of root svg element in widget
        var rootWidth = this.svgMain.width();
        var rootHeight = this.svgMain.height();

        // The map's width
        var minimapWidth = rootWidth * 0.2;
        // The ratio between the map and the graph
        var mapMultiplier = this.minimapMultiplier = minimapWidth / graph_dimensions.width;
        // Map height
        var minimapHeight = graph_dimensions.height * mapMultiplier;

        var svgMainHeight = this.svgMain.height();
        if (minimapHeight > svgMainHeight - 60) {
          minimapHeight = svgMainHeight - 60;
          mapMultiplier = this.minimapMultiplier = minimapHeight / graph_dimensions.height;
          minimapWidth = graph_dimensions.width * mapMultiplier;
        }

        // adjust minimapWidth with padding
        minimapHeight += mapPadding;
        minimapWidth += mapPadding;

        // Create the minimap group
        var minimap = this.minimap = d3.select($root[0])
          .append('g')
          .attr({
            'class': 'dag-minimap',
            // minus 1 to include bottom and right borders for minimap
            'transform': 'translate(' + (rootWidth - minimapWidth - 1) + ',' + (rootHeight - minimapHeight -1) + ')'
          });

        // backdrop
        minimap.append('rect').attr({
          'class': 'minimap-backdrop',
          'height': minimapHeight,
          'width': minimapWidth
        });

        // Create clip-path for viewbox
        minimap.append('defs').append('clipPath')
          .attr('id', 'minimap-clip-path')
          .append('rect')
          .attr({
            'height': minimapHeight,
            'width': minimapWidth
          });

        // edges
        graph.eachEdge(function(stream_id, source_name, sink_name, info) {
          minimap.append('path')
            .attr('class', 'minimap-stream')
            .attr('d', function() {

              var points;
              // var points = info.points; // uncomment if cpettit ever fixes this

              // HACK: points no longer contain endpoints on nodes
              var src = graph.node(source_name);
              var dest = graph.node(sink_name);
              points = [{x: src.x, y: src.y}].concat(info.points);
              points = points.concat({x: dest.x, y: dest.y});

              var point_strings = _.map(points, function(point) {
                return (point.x * mapMultiplier + halfMapPadding) + ',' + (point.y * mapMultiplier + halfMapPadding);
              });

              return 'M' + point_strings.join('L');
            });
        });

        // nodes
        graph.eachNode(function(nodeName, info) {
          var width, height;
          minimap.append('rect')
            .attr({
              'class': 'minimap-operator',
              'width': width = info.width * mapMultiplier,
              'height': height = info.height * mapMultiplier,
              'x': info.x * mapMultiplier - width/2 + halfMapPadding,
              'y': info.y * mapMultiplier - height/2 + halfMapPadding
            });
        });

        // Create minimap viewbox
        var viewbox = minimap.append('rect')
          .attr('class', 'minimap-viewbox')
          .attr({
            'width': rootWidth * mapMultiplier,
            'height': rootHeight * mapMultiplier,
            'x': 0,
            'y': 0,
            'clip-path': 'url(#minimap-clip-path)'
          });

        // Create the interaction element
        var interaction = minimap.append('rect')
          .attr({
            'class': 'minimap-interaction',
            'height': minimapHeight,
            'width': minimapWidth
          });

        var updateGraphPosition = _.bind(function() {
          // d3.event.preventDefault();
          // d3.event.stopPropagation(); // silence other listeners
          var scale = this.zoomBehavior.scale();
          var x = ((d3.event.x - viewbox.attr('width') / 2) / mapMultiplier) * scale;
          var y = ((d3.event.y - viewbox.attr('height') / 2) / mapMultiplier) * scale;
          graphGroup.setAttribute('transform', 'translate(' + -x + ',' + -y + ') scale(' + scale + ')');
          // console.log('scale: ', this.zoomBehavior.scale());
          this.zoomBehavior.translate([-x,-y]);
          this.updateMinimap($root,[-x,-y], scale);
        }, this);

        var drag = d3.behavior.drag()
          // .on('drag', updateGraphPosition)
          // .on("dragstart", updateGraphPosition);
          .on('drag', function() {
            updateGraphPosition();
          })
          .on('dragstart', function() {
            // console.log('drag starting');
            // updateGraphPosition();
          });

        interaction
          .on('mousedown', function() {
            d3.event.preventDefault();
            d3.event.stopPropagation();
          })
          .call(drag);

      },

      /**
       * Updates the minimap, given the jQuery-wrapped svg element, the new translation and scale
       * @param  {jQuery} $svg      jQuery-wrapped svg element
       * @param  {Array} translate  array of x and y value
       * @param  {Number} scale     scale of the zoom
       * @return {void}
       */
      updateMinimap: function($svg, translate, scale) {
        var viewbox = this.minimap.select('.minimap-viewbox');
        var viewboxWidth = $svg.width() * this.minimapMultiplier / scale;
        var viewboxHeight = $svg.height() * this.minimapMultiplier / scale;
        var offset = this.element.find('.form-inline').height();
        var x = translate[0];
        var y = translate[1];

        viewbox.attr({
          'width': viewboxWidth,
          'height': viewboxHeight,
          'x': -x * this.minimapMultiplier / scale,
          'y': (-y - offset) * this.minimapMultiplier / scale
        });
      },

      resetPosition: function () {
        this.zoomBehavior.scale(1).translate([0,0]);
        this.lastZoomLevel.scale = 1;
        this.lastZoomLevel.translate = [0,0];
        this.element.find('svg.svg-main > g > g').attr('transform', null);
        this.updateMinimap(this.element.find('svg.svg-main'), [0,0], 1);
      },

      createStreamLocalityMap: function () {
        var streamLocality = {};
        this.streams.forEach(function (stream) {
          if (stream.locality) {
            streamLocality[stream.name] = stream.locality;
          }
        });

        return streamLocality;
      },

      clearStreamLocality: function () {
        this.svgRoot.selectAll('g .edgePath > path').attr('stroke-dasharray', null);
      },

      updateStreams: function () {
        var streamLocality = this.createStreamLocalityMap();
        var graph = this.graph;

        this.svgRoot.selectAll('g .edgePath > path').each(function (d) {
          var value = graph.edge(d);
          var streamName = value.label;

          var locality = streamLocality.hasOwnProperty(streamName) ? streamLocality[streamName] : 'NONE';
          var localityDisplayProperty = settings.dag.edges.hasOwnProperty(locality) ? settings.dag.edges[locality] : settings.dag.edges.NONE;

          if (localityDisplayProperty.dasharray) {
            d3.select(this).attr('stroke-dasharray', localityDisplayProperty.dasharray);
          }
        });
      }
    };

    return DagRenderer;
  });
