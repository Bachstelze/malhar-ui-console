{"operatorClasses":[{"name":"com.datatorrent.lib.algo.AllAfterMatchMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>"}],"outputPorts":[{"name":"allafter","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>"}],"shortDesc":"<p>\n A compare metric is done on input tuple based on the property \"key\",\n \"value\", and \"cmp\" type","longDesc":"All tuples are emitted (inclusive) once a match is made.\n The comparison is done by getting double value from the Number.\n This module is a pass through<br>\n <br>\n <b> StateFull : Yes, <\/b> Count is aggregated over application window(s). <br>\n <b> Partitions : No, <\/b> will yield wrong result. <br>\n <br>\n <br>\n <b> StateFull : Yes, <\/b> Count is aggregated over application window(s). <br>\n <b> Partitions : No, <\/b> will yield wrong result. <br>\n <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>allafter<\/b>: emits Map&lt;K,V extends Number&gt; if compare function\n returns true<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\",\n \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\",\n \"gte\"<br>\n <b>Specific run time checks<\/b>: None<br>\n <br>","displayName":"All after match map"},{"name":"com.datatorrent.lib.algo.AllAfterMatchStringValueMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, java.lang.String>","description":"Input port."}],"outputPorts":[{"name":"allafter","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.String>"}],"shortDesc":"A compare metric is done on input tuple based on the property \"key\",\n \"value\", and \"cmp\"","longDesc":"All tuples are emitted (inclusive) once a match is made.\n The comparison is done by getting double value from the Number.\n <p>\n This module is a pass through<br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map<K, String><br>\n <b>allafter<\/b>: emits HashMap<K, String> if compare function returns true<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\",\n \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\",\n \"gte\"<br>\n <br>\n <b>Specific run time checks<\/b>:<br>\n The key exists in the HashMap<br>\n Value converts to Double successfully<br>","displayName":"All after match string value map"},{"name":"com.datatorrent.lib.algo.BottomNMap","properties":[{"name":"ascending","canGet":true,"canSet":false,"description":"false","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"n","canGet":true,"canSet":true,"description":"n","type":"int"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>","description":"Expects a HashMap<K,V> tuple"}],"outputPorts":[{"name":"bottom","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.util.ArrayList<V>>","description":"Bottom tuples output port."}],"shortDesc":"Input stream of key value pairs is ordered by key, and bottom N of the\n ordered tuples per key are emitted on port \"bottom\" at the end of window\n <p>\n This is an end of window operator","longDesc":"At the end of window all data is flushed.\n Thus the data set is windowed and no history is kept of previous windows<br>\n The operator assumes that the key, val pairs in the incoming tuple is\n immutable. If the tuple is mutable users should override cloneKey(), and\n cloneValue()<br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V&gt;<br>\n <b>bottom<\/b>: emits HashMap&lt;K, ArrayList&lt;V&gt;&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>N<\/b>: The number of top values to be emitted per key<br>\n <br>\n <b>Specific compile time checks are<\/b>:<br>\n N: Has to be >= 1<br>\n <br>","displayName":"Bottom n map"},{"name":"com.datatorrent.lib.algo.BottomNUnifier","properties":[{"name":"n","canGet":true,"canSet":true,"description":"n","type":"int"}],"inputPorts":[],"outputPorts":[{"name":"mergedport","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.util.ArrayList<V>>","description":"Default output port."}],"shortDesc":"<p>BottomNUnifier class.<\/p>","displayName":"Bottom n unifier"},{"name":"com.datatorrent.lib.algo.BottomNUniqueMap","properties":[{"name":"ascending","canGet":true,"canSet":false,"description":"false","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"n","canGet":true,"canSet":true,"description":"n","type":"int"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>","description":"Expects a HashMap<K,V> tuple"}],"outputPorts":[{"name":"bottom","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.util.ArrayList<java.util.HashMap<V, java.lang.Integer>>>","description":"Bottom tuples output port."}],"shortDesc":"Input stream of key value pairs are ordered by key, and bottom N of the ordered unique tuples per key are emitted on\n port \"top\" at the end of window<p>\n This is an end of window module<br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V&gt;<br>\n <b>bottom<\/b>: emits HashMap&lt;K, ArrayList&lt;HashMap&lt;V,Integer&gt;&gt;&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>N<\/b>: The number of top values to be emitted per key<br>\n <br>\n <b>Specific compile time checks are<\/b>:<br>\n N: Has to be >= 1<br>","displayName":"Bottom n unique map"},{"name":"com.datatorrent.lib.algo.CompareExceptCountMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>"}],"outputPorts":[{"name":"count","optional":true,"error":false,"tupleType":"class java.lang.Integer","description":"Match count output port."},{"name":"except","optional":true,"error":false,"tupleType":"class java.lang.Integer","description":"Not match count output port."},{"name":"match","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>"}],"shortDesc":"A count is done on how many tuples of value type Number satisfy the compare function","longDesc":"The function is given by\n \"key\", \"value\", and \"cmp\". If a tuple passed the test count is incremented. On end of window count is emitted on the output port \"count\".\n The comparison is done by getting double value from the Number.<p>\n This module is an end of window module. If no tuple comes in during a window 0 is emitted on both ports, thus no matter what one Integer\n tuple is emitted on each port<br>\n <br>\n <b>StateFull : Yes, <\/b> tuple are compare across application window(s). <br>\n <b>Partitions : Yes, <\/b> count is unified at output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>count<\/b>: emits Integer<br>\n <b>except<\/b>: emits Integer<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>","displayName":"Compare except count map"},{"name":"com.datatorrent.lib.algo.CompareExceptCountStringMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"emitError","canGet":true,"canSet":true,"description":"emitError","type":"boolean"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, java.lang.String>"}],"outputPorts":[{"name":"count","optional":true,"error":false,"tupleType":"class java.lang.Integer"},{"name":"except","optional":true,"error":false,"tupleType":"class java.lang.Integer"},{"name":"match","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.String>"}],"shortDesc":"A count is done on how many tuples of value type String satisfy the compare function","longDesc":"The function is given by\n \"key\", \"value\", and \"compare\". If a tuple passed the test count is incremented. On end of window count is emitted on the output port \"count\".\n The comparison is done by getting double value from the Number.<p>\n This module is an end of window module. If no tuple comes in during a window 0 is emitted on both ports, thus no matter what one Integer\n tuple is emitted on each port<br>\n <br>\n <b>StateFull : Yes, <\/b> tuple are compare across application window(s). <br>\n <b>Partitions : Yes, <\/b> count is unified at output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,String&gt;<br>\n <b>count<\/b>: emits Integer<br>\n <b>except<\/b>: emits Integer<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>","displayName":"Compare except count string map"},{"name":"com.datatorrent.lib.algo.Distinct","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Object","description":"Input port."}],"outputPorts":[{"name":"distinct","optional":true,"error":false,"tupleType":"class java.lang.Object","description":"Output for distinct values. <\/b>"}],"shortDesc":"Computes and emits distinct tuples of type K (i.e drops duplicates) at end of window<p>\n <br>\n This module is same as a \"FirstOf\" metric on any key, val pair\n Even though this module produces continuous tuples, at end of window all data is flushed","longDesc":"Thus the data set is windowed\n and no history is kept of previous windows<br>\n <br>\n <b>StateFull : Yes, <\/b> tuple are compare across application window(s). <br>\n <b>Partitions : Yes, <\/b> distinct output is unified by same operator. <br>\n <br>\n <b>Ports<\/b><br>\n <b>data<\/b>: Input data port expects K<br>\n <b>distinct<\/b>: Output data port, emits K<br>\n <br>\n <b>Properties<\/b>: None<br>\n <br>","displayName":"Distinct"},{"name":"com.datatorrent.lib.algo.DistinctMap","properties":[{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>"}],"outputPorts":[{"name":"distinct","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>"}],"shortDesc":"Computes and emits distinct key,val pairs (i.e drops duplicates)<p>\n This is a pass through operator<br>\n <br>\n This module is same as a \"FirstOf\" metric on any key,val pair","longDesc":"At end of window all data is flushed.<br>\n <br>\n <b>StateFull : Yes, <\/b> tuple are compare across application window(s). <br>\n <b>Partitions : Yes, <\/b> distinct output is unified by unifier hash map operator. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: Input data port expects Map&lt;K,V&gt;<br>\n <b>distinct<\/b>: Output data port, emits HashMap&lt;K,V&gt;(1)<br>\n <br>","displayName":"Distinct map"},{"name":"com.datatorrent.lib.algo.FilterKeyVals","properties":[{"name":"inverse","canGet":true,"canSet":true,"description":"inverse","type":"boolean"},{"name":"keyVals","canGet":true,"canSet":true,"description":"keyvals hash","type":"java.util.HashMap","properties":[{"name":"empty","canGet":true,"canSet":false,"type":"boolean"}]},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.HashMap<K, V>"}],"outputPorts":[{"name":"filter","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>"}],"shortDesc":"Filters the incoming stream based of specified key,val pairs, and emits those that match the filter","longDesc":"If\n property \"inverse\" is set to \"true\", then all key,val pairs except those specified by in keyvals parameter are emitted<p>\n Operator assumes that the key, val pairs are immutable objects. If this operator has to be used for mutable objects,\n override \"cloneKey()\" to make copy of K, and \"cloneValue()\" to make copy of V.<br>\n This is a pass through node<br>\n <br>\n <b>StateFull : No, <\/b> tuple are processed in current window. <br>\n <b>Partitions : Yes, <\/b> no dependency among input tuples. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects HashMap&lt;K,V&gt;<br>\n <b>filter<\/b>: emits HashMap&lt;K,V&gt;(1)<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>keyvals<\/b>: The keyvals is key,val pairs to pass through, rest are filtered\/dropped.<br>\n <br>","displayName":"Filter key vals"},{"name":"com.datatorrent.lib.algo.FilterKeysHashMap","properties":[{"name":"inverse","canGet":true,"canSet":true,"description":"inverse","type":"boolean"},{"name":"key","canGet":false,"canSet":true,"type":"java.lang.Object"},{"name":"keys","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, java.util.HashMap<K, V>>","description":"Input port."}],"outputPorts":[{"name":"filter","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.util.HashMap<K, V>>","description":"Output port."}],"shortDesc":"Filters the incoming stream based of keys specified by property \"keys\"","longDesc":"If\n property \"inverse\" is set to \"true\", then all keys except those specified by \"keys\" are emitted<p>\n Operator assumes that the key, val pairs are immutable objects. If this operator has to be used for mutable objects,\n override \"cloneKey()\" to make copy of K, and \"cloneValue()\" to make copy of V.<br>\n This is a pass through node.<br>\n <br>\n <b>StateFull : No, <\/b> tuple are processed in current window. <br>\n <b>Partitions : Yes, <\/b> no dependency among input tuples. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: Expects Map&lt;K, HashMap&lt;K,V&gt;&gt. Filters are applied only on keys of second hash map.<br>\n <b>filter<\/b>: Emits HashMap&lt;K, HashMap&lt;K,V&gt;&gt.<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>keys<\/b>: The keys to pass through, rest are filtered\/dropped. A comma separated list of keys.<br>\n <br>","displayName":"Filter keys hash map"},{"name":"com.datatorrent.lib.algo.FilterKeysMap","properties":[{"name":"inverse","canGet":true,"canSet":true,"description":"inverse","type":"boolean"},{"name":"key","canGet":false,"canSet":true,"type":"java.lang.Object"},{"name":"keys","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>","description":"Input port."}],"outputPorts":[{"name":"filter","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>","description":"Output port."}],"shortDesc":"Filters the incoming stream based of keys specified by property \"keys\"","longDesc":"If\n property \"inverse\" is set to \"true\", then all keys except those specified by \"keys\" are emitted<p>\n Operator assumes that the key, val pairs are immutable objects. If this operator has to be used for mutable objects,\n override \"cloneKey()\" to make copy of K, and \"cloneValue()\" to make copy of V.<br>\n This is a pass through node<br>\n <br>\n <b>StateFull : No, <\/b> tuple are processed in current window. <br>\n <b>Partitions : Yes, <\/b> no dependency among input tuples. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: Expects Map&lt;K,V&gt;<br>\n <b>filter<\/b>: Emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>keys<\/b>: The keys to pass through, rest are filtered\/dropped. A comma separated list of keys<br>\n <br>","displayName":"Filter keys map"},{"name":"com.datatorrent.lib.algo.FilterValues","properties":[{"name":"inverse","canGet":true,"canSet":true,"description":"inverse","type":"boolean"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"value","canGet":false,"canSet":true,"type":"java.lang.Object"},{"name":"values","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[{"name":"filter","optional":true,"error":false,"tupleType":"class java.lang.Object"}],"shortDesc":"Filters incoming stream and emits values as specified by the set of values to filter","longDesc":"If\n property \"inverse\" is set to \"true\", then all keys except those specified by \"keys\" are emitted. The values are expected to be immutable<p>\n This operator should not be used with mutable objects. If this operator has immutable Objects, override \"cloneCopy\" to ensure a new copy is sent out.\n This is a pass through node<br>\n <br>\n <b>StateFull : No, <\/b> tuple are processed in current window. <br>\n <b>Partitions : Yes, <\/b> no dependency among input tuples. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expect T (a POJO)<br>\n <b>filter<\/b>: emits T (a POJO)<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>keys<\/b>: The keys to pass through. Those not in the list are dropped. A comma separated list of keys<br>\n <br>","displayName":"Filter values"},{"name":"com.datatorrent.lib.algo.FirstMatchMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>","description":"Input port."}],"outputPorts":[{"name":"first","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>","description":"Output port, unifier operator."}],"shortDesc":"A compare metric on a Number tuple based on the property \"key\", \"value\", and \"cmp\"; the first match is emitted","longDesc":"  The comparison is done by getting double value from the Number.<p>\n This module is a pass through<br>\n The operators by default assumes immutable keys. If the key is mutable, use cloneKey to make a copy<br>\n <br>\n <b>StateFull : Yes, <\/b> tuple are processed in current window. <br>\n <b>Partitions : No, <\/b>will yield wrong results. <br>\n <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>first<\/b>: emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>","displayName":"First match map"},{"name":"com.datatorrent.lib.algo.FirstMatchStringMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, java.lang.String>"}],"outputPorts":[{"name":"first","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.String>"}],"shortDesc":"A compare metric on a tuple with value type String, based on the property \"key\", \"value\", and \"cmp\"; the first match is emitted","longDesc":"The comparison is done by getting double\n value from the Number.<p>\n This module is a pass through<br>\n <br>\n <b>StateFull : Yes, <\/b> tuple are processed in current window. <br>\n <b>Partitions : No, <\/b>will yield wrong results. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,String&gt;><br>\n <b>first<\/b>: emits HashMap&lt;K,String&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>","displayName":"First match string map"},{"name":"com.datatorrent.lib.algo.FirstN","properties":[{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"n","canGet":true,"canSet":true,"description":"n","type":"int"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>","description":"Expects a HashMap<K,V> tuple"}],"outputPorts":[{"name":"first","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>","description":"Output port, unifier operator."}],"shortDesc":"Emits first N tuples of a particular key.<p>\n This module is a pass through module<br>\n <br>\n <b>StateFull : Yes, <\/b> tuple are compare across application window(s)","longDesc":"<br>\n <b>Partitions : No, <\/b> will yield wrong results. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: Input data port expects HashMap&lt;K,V&gt;<br>\n <b>bottom<\/b>: Output data port, emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>N<\/b>: The number of top values to be emitted per key<br>\n <br>\n <b>Specific compile time checks are<\/b>:<br>\n N: Has to be >= 1<br>\n <br>\n <br>","displayName":"First n"},{"name":"com.datatorrent.lib.algo.FirstTillMatch","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.HashMap<K, V>","description":"Input port."}],"outputPorts":[{"name":"first","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>","description":"Output port."}],"shortDesc":"All key.val pairs with val sub-classed from Number are emitted till the first match;  A compare metric is done based on the property \"key\",\n \"value\", and \"cmp\"","longDesc":"Then on no tuple is emitted in that window. The comparison is done by getting double value of the Number.<p>\n This module is a pass through<br>\n <br>\n <b>StateFull : Yes, <\/b> tuple are processed in current window. <br>\n <b>Partitions : No, <\/b>will yield wrong results. <br>\n <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: Input port, expects HashMap&lt;K,V&gt;<br>\n <b>first<\/b>: Output port, emits HashMap&lt;K,V&gt; if compare function returns true<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>","displayName":"First till match"},{"name":"com.datatorrent.lib.algo.FirstTillMatchString","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.HashMap<K, java.lang.String>","description":"Input port."}],"outputPorts":[{"name":"first","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.String>","description":"Output port."}],"shortDesc":"All key,val pairs with val of type String are emitted till the first match;  A compare metric is done based on the property \"key\", \"value\",\n and \"cmp\"","longDesc":"Then on no tuple is emitted in that window. The comparison is done by getting double value of the Number.<p>\n This module is a pass through<br>\n <br>\n <b>StateFull : Yes, <\/b> tuple are processed in current window. <br>\n <b>Partitions : No, <\/b>will yield wrong results. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: Input port, expects HashMap&lt;K,String&gt;<br>\n <b>first<\/b>: Output port, emits HashMap&lt;K,String&gt; if compare function returns true<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n Compile time checks<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n <b>Specific compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n <br>","displayName":"First till match string"},{"name":"com.datatorrent.lib.algo.InsertSort","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"size","canGet":true,"canSet":true,"description":"size","type":"int"}],"inputPorts":[{"name":"data","optional":true,"tupleType":"class java.lang.Object","description":"Input port that takes in one tuple at a time"},{"name":"datalist","optional":true,"tupleType":"java.util.ArrayList<K>","description":"Input port that takes in an array of Objects to insert"}],"outputPorts":[{"name":"sort","optional":true,"error":false,"tupleType":"java.util.ArrayList<K>","description":"Output port."}],"shortDesc":"Takes a stream of key value pairs via input port \"data\"","longDesc":"The incoming tuple\n is merged into already existing sorted list. At the end of the window the\n entire sorted list is emitted on output port \"sort\"\n <p\/>\n <br>\n <b>StateFull : Yes, <\/b> tuple are compare across application window(s). <br>\n <b>Partitions : Yes, <\/b> the operator itself serves as the unifier.\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects K<br>\n <b>datalist<\/b>: expects ArrayList&lt;K&gt;<br>\n <b>sortlist<\/b>: emits ArrayList&lt;K&gt;, must be connected<br>\n <br>","displayName":"Insert sort"},{"name":"com.datatorrent.lib.algo.InsertSortDesc","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"size","canGet":true,"canSet":true,"description":"size","type":"int"}],"inputPorts":[{"name":"data","optional":true,"tupleType":"class java.lang.Object","description":"Input port that takes in one tuple at a time"},{"name":"datalist","optional":true,"tupleType":"java.util.ArrayList<K>","description":"Input port that takes in an array of Objects to insert"}],"outputPorts":[{"name":"sort","optional":true,"error":false,"tupleType":"java.util.ArrayList<K>"},{"name":"sorthash","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Integer>"}],"shortDesc":"Incoming tuple is inserted into already existing sorted list in a descending order","longDesc":"At the end of the window the resultant sorted list is emitted on the output ports<p>\n <br>\n <b>StateFull : Yes, <\/b> tuple are compare across application window(s). <br>\n <b>Partitions : No, <\/b> will yield wrong results. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects K<br>\n <b>datalist<\/b>: expects ArrayList&lt;K&gt;<br>\n <b>sortlist<\/b>: emits ArrayList&lt;K&gt;<br>\n <b>sorthash<\/b>: emits HashMap&lt;K,Integer&gt;<br>\n <br>\n <br>","displayName":"Insert sort desc"},{"name":"com.datatorrent.lib.algo.InvertIndex","properties":[{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.HashMap<K, V>","description":"Input port."}],"outputPorts":[{"name":"index","optional":true,"error":false,"tupleType":"java.util.HashMap<V, java.util.ArrayList<K>>","description":"Output port."}],"shortDesc":"Inverts the index and sends out the tuple on output port \"index\" at the end of the window<p>\n This is an end of window operator<br>\n <br>\n <b>StateFull : Yes, <\/b> tuple are compare across application window(s)","longDesc":"<br>\n <b>Partitions : Yes, <\/b> inverted indexes are unified by instance of same operator. <br>\n <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects &lt;K,V&gt;<br>\n <b>index<\/b>: emits &lt;V,ArrayList&lt;K&gt;&gt;(1); one HashMap per V<br>\n <br>","displayName":"Invert index"},{"name":"com.datatorrent.lib.algo.InvertIndexArray","properties":[{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.HashMap<K, java.util.ArrayList<V>>","description":"Input port."}],"outputPorts":[{"name":"index","optional":true,"error":false,"tupleType":"java.util.HashMap<V, java.util.ArrayList<K>>","description":"Output port."}],"shortDesc":"Inverts the index and sends out the tuple on output port \"index\" at the end of the window<p>\n This is an end of window operator<br>\n <br>\n <b>StateFull : Yes, <\/b> tuple are compare across application window(s)","longDesc":"<br>\n <b>Partitions : Yes, <\/b> inverted indexes are unified by instance of same operator. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects HashMap&lt;K,ArrayList&lt;V&gt;&gt;<br>\n <b>index<\/b>: emits HashMap&lt;V,ArrayList&lt;K&gt;&gt;(1), one HashMap per V<br>\n <br>","displayName":"Invert index array"},{"name":"com.datatorrent.lib.algo.LastMatchMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>","description":"Input port."}],"outputPorts":[{"name":"last","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>","description":"Output port."}],"shortDesc":"A compare function is  operated on a tuple value sub-classed from Number based on the property \"key\", \"value\", and \"cmp\"","longDesc":"Every tuple\n is checked and the last one that passes the condition is send during end of window on port \"last\". The comparison is done by getting double\n value from the Number<p>\n This module is an end of window module<br>\n <br>\n <b>StateFull : Yes, <\/b> tuple are compare across application window(s). <br>\n <b>Partitions : No, <\/b> will yield wrong result. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>last<\/b>: emits Map&lt;K,V&gt; in end of window for the last tuple on which the compare function is true<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>","displayName":"Last match map"},{"name":"com.datatorrent.lib.algo.LastMatchStringMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, java.lang.String>","description":"Input port."}],"outputPorts":[{"name":"last","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.String>","description":"Output port."}],"shortDesc":"A compare function is operated on a tuple value of type String based on the property \"key\", \"value\", and \"cmp\"","longDesc":"Every tuple\n is checked and the last one that passes the condition is send during end of window on port \"last\". The comparison is done by getting double\n value from the Number<p>\n This module is an end of window module<br>\n <br>\n <b>StateFull : Yes, <\/b> tuple are compare across application window(s). <br>\n <b>Partitions : No, <\/b> will yield wrong result. <br>\n <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,String&gt;<br>\n <b>last<\/b>: emits HashMap&lt;K,String&gt; in end of window for the last tuple on which the compare function is true<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>","displayName":"Last match string map"},{"name":"com.datatorrent.lib.algo.LeastFrequentKey","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[{"name":"least","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Integer>","description":"Output port, optional."},{"name":"list","optional":true,"error":false,"tupleType":"java.util.ArrayList<java.util.HashMap<K, java.lang.Integer>>","description":"Output port."}],"shortDesc":"<p>\n Occurrences of each tuple is counted and at the end of window any of the least frequent tuple is emitted on output port 'least'\n All keys with same least frequency value least are emitted on output port 'list'.<br>\n This module is an end of window module<br>\n In case of a tie any of the least key would be emitted","longDesc":"The list port would however have all the tied keys\n <br>\n <b>StateFull : Yes, <\/b> tuple are compared across application window(s). <br>\n <b>Partitions : Yes, <\/b> least keys are unified on output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects K<br>\n <b>least<\/b>: emits HashMap&lt;K,Integer&gt;(1), Where K is the least occurring key in the window.\n               In case of tie any of the least key would be emitted<br>\n <b>list<\/b>: emits ArrayList&lt;HashMap&lt;K,Integer&gt;(1)&gt, Where the list includes all the keys that are least frequent<br>\n <br>","displayName":"Least frequent key"},{"name":"com.datatorrent.lib.algo.LeastFrequentKeyArrayUnifier","properties":[],"inputPorts":[],"outputPorts":[{"name":"mergedport","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Integer>","description":"Default output port."}],"shortDesc":"<p>LeastFrequentKeyArrayUnifier class.<\/p>","displayName":"Least frequent key array unifier"},{"name":"com.datatorrent.lib.algo.LeastFrequentKeyMap","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>","description":"Input port."}],"outputPorts":[{"name":"least","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Integer>","description":"Output port."},{"name":"list","optional":true,"error":false,"tupleType":"java.util.ArrayList<java.util.HashMap<K, java.lang.Integer>>","description":"Output port."}],"shortDesc":"Occurrences of each key is counted and at the end of window any of the least frequent key is emitted on output port least and all least frequent\n keys on output port list<p>\n This module is an end of window module","longDesc":"In case of a tie any of the least key would be emitted. The list port would however have all the tied keys<br>\n <br>\n <b>StateFull : Yes, <\/b> tuple are compared across application window(s). <br>\n <b>Partitions : Yes, <\/b> least keys are unified on output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V&gt;, V is ignored\/not used<br>\n <b>least<\/b>: emits HashMap&lt;K,Integer&gt;(1); where String is the least frequent key, and Integer is the number of its occurrences in the window<br>\n <b>list<\/b>: emits ArrayList&lt;HashMap&lt;K,Integer&gt;(1)&gt;; Where the list includes all the keys are least frequent<br>\n <br>","displayName":"Least frequent key map"},{"name":"com.datatorrent.lib.algo.LeastFrequentKeyUnifier","properties":[],"inputPorts":[],"outputPorts":[{"name":"mergedport","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Integer>","description":"Default output port."}],"shortDesc":"<p>LeastFrequentKeyUnifier class.<\/p>","displayName":"Least frequent key unifier"},{"name":"com.datatorrent.lib.algo.LeastFrequentKeyValueMap","properties":[{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>"}],"outputPorts":[{"name":"least","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.util.HashMap<V, java.lang.Integer>>"}],"shortDesc":"Occurrences of all values for each key is counted and at the end of window the least frequent values are emitted on output port least per key<p>\n This module is an end of window module<br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V&gt;<br>\n <b>least<\/b>: Output port, emits HashMap&lt;K,HashMap&lt;V,Integer&gt;&gt;(1)<br>\n <br>\n <b>Properties<\/b>: None<br>\n <br>\n <b>Compile time checks<\/b>: None<br>\n <b>Specific run time checks<\/b>: None <br>\n <br>\n <b>Benchmarks<\/b>: Blast as many tuples as possible in inline mode<br>\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Benchmark table for LeastFrequentKeyValueMap&lt;K,V&gt; operator template\">\n <tr><th>In-Bound<\/th><th>Out-bound<\/th><th>Comments<\/th><\/tr>\n <tr><td><b>&gt; 30 Million K,V pairs\/s<\/b><\/td><td>Emits only 1 tuple per window per key<\/td><td>In-bound throughput is the main determinant of performance","longDesc":" The benchmark was done with immutable objects. If K or V are mutable the benchmark may be lower<\/td><\/tr>\n <\/table><br>\n <p>\n <b>Function Table (K=String,V=Integer);<\/b>:\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Function table for LeastFrequentKeyValueMap&lt;K,V&gt; operator template\">\n <tr><th rowspan=2>Tuple Type (api)<\/th><th>In-bound (process)<\/th><th>Out-bound (emit)<\/th><\/tr>\n <tr><th><i>data<\/i>(Map&lt;K,V&gt;)<\/th><th><i>least<\/i>(HashMap&lt;K,HashMap&lt;Integer&gt;&gt;)<\/th><\/tr>\n <tr><td>Begin Window (beginWindow())<\/td><td>N\/A<\/td><td>N\/A<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{a=1,b=5,c=110}<\/td><td><\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{a=55,c=2000,b=45}<\/td><td><\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{d=2}<\/td><td><\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{a=55,b=5,c=22}<\/td><td><\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{h=20,a=2,z=5}<\/td><td><\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{a=4,c=110}<\/td><td><\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{a=4,z=5}<\/td><td><\/td><\/tr>\n <tr><td>End Window (endWindow())<\/td><td>N\/A<\/td><td>{a={1=1,2=1},b={45=1},c={2000=1,22=1},d={2=1},h={20=1},z={5=2}<\/td><\/tr>\n <\/table>\n <br>\n <br>","displayName":"Least frequent key value map"},{"name":"com.datatorrent.lib.algo.MatchAllMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>"}],"outputPorts":[{"name":"all","optional":true,"error":false,"tupleType":"class java.lang.Boolean"}],"shortDesc":"Each tuple is tested for the compare function","longDesc":"The function is given by\n \"key\", \"value\", and \"cmp\". If all tuples passes a Boolean(true) is emitted, else a Boolean(false) is emitted on end of window on the output port \"all\".\n The comparison is done by getting double value from the Number.<p>\n This module is an end of window module<br>\n <br>\n <b>StateFull : Yes, <\/b> tuple are compared across application window(s). <br>\n <b>Partitions : Yes, <\/b> match status is unified on output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>all<\/b>: emits Boolean<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>","displayName":"Match all map"},{"name":"com.datatorrent.lib.algo.MatchAllStringMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, java.lang.String>"}],"outputPorts":[{"name":"all","optional":true,"error":false,"tupleType":"class java.lang.Boolean"}],"shortDesc":"Each tuple is tested for the compare function","longDesc":"The function is given by\n \"key\", \"value\", and \"cmp\". If all tuples passes a Boolean(true) is emitted, else a Boolean(false) is emitted on end of window on the output port \"all\".\n The comparison is done by getting double value from the Number.<p>\n This module is an end of window module<br>\n <br>\n <b>StateFull : Yes, <\/b> tuple are compared across application window(s). <br>\n <b>Partitions : Yes, <\/b> match status is unified on output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,String&gt;<br>\n <b>all<\/b>: emits Boolean<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <b>Specific run time checks<\/b>: None<br>\n <br>","displayName":"Match all string map"},{"name":"com.datatorrent.lib.algo.MatchAnyMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>"}],"outputPorts":[{"name":"any","optional":true,"error":false,"tupleType":"class java.lang.Boolean"}],"shortDesc":"Each tuple is tested for the compare function","longDesc":"The function is given by\n \"key\", \"value\", and \"compare\". If any tuple passes a Boolean(true) is emitted, else a Boolean(false) is emitted on the output port \"any\".\n The comparison is done by getting double value from the Number.<p>\n This module is a pass through as it emits the moment the condition is met<br>\n <br>\n <b>StateFull : Yes, <\/b> tuple are compared across application window(s). <br>\n <b>Partitions : Yes, <\/b> match status is unified on output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>any<\/b>: emits Boolean<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <b>Specific run time checks<\/b>: None<br>\n <br>","displayName":"Match any map"},{"name":"com.datatorrent.lib.algo.MatchAnyStringMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, java.lang.String>"}],"outputPorts":[{"name":"any","optional":true,"error":false,"tupleType":"class java.lang.Boolean"}],"shortDesc":"Each tuple is tested for the compare function","longDesc":"The function is given by\n \"key\", \"value\", and \"compare\". If any tuple passes a Boolean(true) is emitted, else a Boolean(false) is emitted on the output port \"any\".\n The comparison is done by getting double value from the Number.<p>\n This module is a pass through as it emits the moment the condition is met<br>\n <br>\n <b>StateFull : Yes, <\/b> tuple are compared across application window(s). <br>\n <b>Partitions : Yes, <\/b> match status is unified on output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map<K,String><br>\n <b>any<\/b>: emits Boolean<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>","displayName":"Match any string map"},{"name":"com.datatorrent.lib.algo.MatchMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>"}],"outputPorts":[{"name":"match","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>"}],"shortDesc":"A compare function is imposed based on the property \"key\", \"value\", and \"cmp\"","longDesc":"If the tuple\n passed the test, it is emitted on the output port match. The comparison is done by getting double\n value from the Number. Both output ports are optional, but at least one has to be connected<p>\n This module is a pass through<br>\n <br>\n <b>StateFull : No, <\/b> tuple is processed in current application window. <br>\n <b>Partitions : Yes, <\/b> match status is unified on output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>match<\/b>: emits HashMap&lt;K,V&gt<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>","displayName":"Match map"},{"name":"com.datatorrent.lib.algo.MatchStringMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"emitError","canGet":true,"canSet":true,"description":"emitError","type":"boolean"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, java.lang.String>"}],"outputPorts":[{"name":"match","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.String>"}],"shortDesc":"A compare function is imposed based on the property \"key\", \"value\", and \"cmp\"","longDesc":"If the tuple\n passed the test, it is emitted on the output port \"match\". The comparison is done by getting double\n value from the Number. Both output ports are optional, but at least one has to be connected<p>\n This module is a pass through<br>\n <br>\n <b>StateFull : No, <\/b> tuple is processed in current application window. <br>\n <b>Partitions : Yes, <\/b> match status is unified on output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,String&gt;<br>\n <b>match<\/b>: emits HashMap&lt;K,String&gt; if compare function returns true<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>","displayName":"Match string map"},{"name":"com.datatorrent.lib.algo.MergeSortNumber","properties":[{"name":"ascending","canGet":true,"canSet":true,"type":"boolean"},{"name":"unifierInstance","canGet":true,"canSet":false,"type":"com.datatorrent.api.Operator$Unifier","properties":[]}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.ArrayList<K>","description":"Input port."}],"outputPorts":[{"name":"sort","optional":true,"error":false,"tupleType":"java.util.ArrayList<K>","description":"Sorted list output port."}],"shortDesc":"<p>\n Incoming sorted list is merged into already existing sorted list","longDesc":"The input list is expected to be sorted. <b>\n At the end of the window, merged sorted list is emitted on sort output port. <br>\n <br>\n <b>Notes : <\/b> <br>\n Get unifier instance must return instance of sub class itself, since merge operator\n id unifier on output port. <br>\n <br>\n  <b>StateFull : Yes<\/b>, Sorted listed are merged over application window can be > 1. <br>\n  <b>Partitions : Yes<\/b>, Operator itself is used as unfier on output port.\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects ArrayList&lt;K&gt;<br>\n <b>sort<\/b>: emits ArrayList&lt;K&gt;<br>\n <br>\n <b>Abstract Methods: <\/b><br>\n 1. compare : K type value compare criteria for sort.\n 2. getUnifierInstance : Get unifier operator instance for output port, (must return self instance).","displayName":"Merge sort number"},{"name":"com.datatorrent.lib.algo.MostFrequentKey","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[{"name":"list","optional":true,"error":false,"tupleType":"java.util.ArrayList<java.util.HashMap<K, java.lang.Integer>>"},{"name":"most","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Integer>"}],"shortDesc":"Occurrences of each tuple is counted and at the end of window any of the most frequent tuple is emitted on output port least and all least frequent\n tuples on output port list<p>\n This module is an end of window module<br>\n In case of a tie any of the least key would be emitted","longDesc":"The list port would however have all the tied keys\n <br>\n  <b>StateFull : Yes<\/b>, Values are compared all over  application window can be > 1. <br>\n  <b>Partitions : Yes<\/b>, Result is unified on output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects K<br>\n <b>most<\/b>: emits HashMap&lt;K,Integer&gt;(1), Where K is the least occurring key in the window. In case of tie any of the least key would be emitted<br>\n <b>list<\/b>: emits ArrayList&lt;HashMap&lt;K,Integer&gt;(1)&gt, Where the list includes all the keys that are least frequent<br>\n <br>\n <b>Properties<\/b>: None<br>\n <br>\n <b>Compile time checks<\/b>: None<br>\n <b>Specific run time checks<\/b>: None<br>\n <br>","displayName":"Most frequent key"},{"name":"com.datatorrent.lib.algo.MostFrequentKeyMap","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>"}],"outputPorts":[{"name":"list","optional":true,"error":false,"tupleType":"java.util.ArrayList<java.util.HashMap<K, java.lang.Integer>>"},{"name":"most","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Integer>"}],"shortDesc":"Occurrences of each key is counted and at the end of window any of the most frequent key is emitted on output port least and all least frequent\n keys on output port list<p>\n This module is an end of window module","longDesc":"In case of a tie any of the least key would be emitted. The list port would however have all the tied keys<br>\n <br>\n  <b>StateFull : Yes<\/b>, Values are compared all over  application window can be > 1. <br>\n  <b>Partitions : Yes<\/b>, Result is unified on output port. <br>\n  <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V&gt;, V is ignored\/not used<br>\n <b>most<\/b>: emits HashMap&lt;K,Integer&gt;(1); where String is the least frequent key, and Integer is the number of its occurrences in the window<br>\n <b>list<\/b>: emits ArrayList&lt;HashMap&lt;K,Integer&gt;(1)&gt;; Where the list includes all the keys are least frequent<br>\n <br>","displayName":"Most frequent key map"},{"name":"com.datatorrent.lib.algo.MostFrequentKeyValueMap","properties":[{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>"}],"outputPorts":[{"name":"most","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.util.HashMap<V, java.lang.Integer>>"}],"shortDesc":"Occurrences of all values for each key is counted and at the end of window the most frequent values are emitted on output port least per key<p>\n This module is an end of window module<br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects HashMap&lt;K,V&gt;<br>\n <b>most<\/b>: emits HashMap&lt;String, HashMap&lt;String, Integer&gt;&gt;(1)<br>\n <br>\n <br>\n <b>Properties<\/b>: None<br>\n <br>\n <b>Compile time checks<\/b>: None<br>\n <b>Specific run time checks<\/b>: None <br>\n <br>\n <b>Benchmarks<\/b>: Blast as many tuples as possible in inline mode<br>\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Benchmark table for MostFrequentKeyValueMap&lt;K,V&gt; operator template\">\n <tr><th>In-Bound<\/th><th>Out-bound<\/th><th>Comments<\/th><\/tr>\n <tr><td><b>&gt; 30 Million K,V pairs\/s<\/b><\/td><td>Emits only 1 tuple per window per key<\/td><td>In-bound throughput is the main determinant of performance","longDesc":" The benchmark was done with immutable objects. If K or V are mutable the benchmark may be lower<\/td><\/tr>\n <\/table><br>\n <p>\n <b>Function Table (K=String,V=Integer);<\/b>:\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Function table for MostFrequentKeyValueMap&lt;K,V&gt; operator template\">\n <tr><th rowspan=2>Tuple Type (api)<\/th><th>In-bound (process)<\/th><th>Out-bound (emit)<\/th><\/tr>\n <tr><th><i>data<\/i>(HashMap&lt;K,V&gt;)<\/th><th><i>most<\/i>(HashMap&lt;K,HashMap&lt;Integer&gt;&gt;)<\/th><\/tr>\n <tr><td>Begin Window (beginWindow())<\/td><td>N\/A<\/td><td>N\/A<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{a=1,b=5,c=110}<\/td><td><\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{a=55,c=2000,b=45}<\/td><td><\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{d=2}<\/td><td><\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{a=55,b=5,c=22}<\/td><td><\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{h=20,a=2,z=5}<\/td><td><\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{a=4,c=110}<\/td><td><\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{a=4,z=5}<\/td><td><\/td><\/tr>\n <tr><td>End Window (endWindow())<\/td><td>N\/A<\/td><td>{a={4=2,55=2},b={5=2},c={110=2},d={2=1},h={20=1},z={5=2}<\/td><\/tr>\n <\/table>\n <br>\n <br>","displayName":"Most frequent key value map"},{"name":"com.datatorrent.lib.algo.PartitionableUniqueCount","properties":[{"name":"cumulative","canGet":true,"canSet":true,"type":"boolean"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Object"},{"name":"data1","optional":true,"tupleType":"class java.lang.Object"}],"outputPorts":[{"name":"count","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyHashValPair<K, java.lang.Integer>"}],"shortDesc":"<p>PartitionableUniqueCount class.<\/p>","displayName":"Partitionable unique count"},{"name":"com.datatorrent.lib.algo.PartitionableUniqueCount$UniqueCountUnifier","properties":[],"inputPorts":[],"outputPorts":[{"name":"mergedport","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyHashValPair<K, java.lang.Integer>"}]},{"name":"com.datatorrent.lib.algo.Sampler","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"passrate","canGet":true,"canSet":true,"description":"passrate","type":"int"},{"name":"totalrate","canGet":true,"canSet":true,"description":"totalrate","type":"int"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[{"name":"sample","optional":true,"error":false,"tupleType":"class java.lang.Object"}],"shortDesc":"Emits sample percentage tuples","longDesc":"<br>\n Emits the tuple as per probability of pass rate out of total rate. <br>\n <br>\n An efficient filter to allow sample analysis of a stream. Very useful is the incoming stream has high throughput<p>\n <br>\n <b> StateFull : No, <\/b> tuple is processed in current window. <br>\n <b> Partitions : Yes. <\/b> No state dependency among input tuples. <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects K<br>\n <b>sample<\/b>: emits K<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>passrate<\/b>: Sample rate out of a total of totalrate. Default is 1<br>\n <b>totalrate<\/b>: Total rate (divisor). Default is 100<br>\n <br>\n <b>Specific compile time checks are<\/b>: None<br>\n passrate is positive integer<br>\n totalrate is positive integer<br>\n passrate and totalrate are not compared (i.e. passrate &lt; totalrate) check is not done to allow users to make this operator a passthrough (all) during testing<br>\n <br>\n <b>Specific run time checks are<\/b>: None<br>\n <br>","displayName":"Sampler"},{"name":"com.datatorrent.lib.algo.TopN","properties":[{"name":"ascending","canGet":true,"canSet":false,"description":"true","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"n","canGet":true,"canSet":true,"description":"n","type":"int"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>","description":"Expects a HashMap<K,V> tuple"}],"outputPorts":[{"name":"top","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.util.ArrayList<V>>","description":"Output port."}],"shortDesc":"Orders tuples per key and emits top N tuples per key on end of window<p>\n This is an end of window module.<br>\n <br>\n <b>StateFull : Yes, <\/b> Tuple are aggregated across application window(s)","longDesc":"<br>\n <b>Partitions : Yes, <\/b> Top values are unified on output port. <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: Input data port expects HashMap&lt;K,V&gt;<br>\n <b>top<\/b>: Output data port, emits HashMap&lt;K, ArrayList&lt;V&gt;&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>N<\/b>: The number of top values to be emitted per key<br>\n <br>\n <b>Specific compile time checks are<\/b>:<br>\n N: Has to be >= 1<br>\n <br>","displayName":"Top n"},{"name":"com.datatorrent.lib.algo.TopNUnique","properties":[{"name":"ascending","canGet":true,"canSet":false,"description":"true","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"n","canGet":true,"canSet":true,"description":"n","type":"int"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>","description":"Expects a HashMap<K,V> tuple"}],"outputPorts":[{"name":"top","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.util.ArrayList<java.util.HashMap<V, java.lang.Integer>>>"}],"shortDesc":"Orders tuples per key and emits top N unique tuples per key on end of window<p>\n This is an end of window module<br>\n At the end of window all data is flushed","longDesc":"Thus the data set is windowed and no history is kept of previous windows<br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: Input data port expects HashMap&lt;K,V&gt;<br>\n <b>top<\/b>: Output data port, emits HashMap&lt;K, ArrayList&lt;V&gt;&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>N<\/b>: The number of top values to be emitted per key<br>\n <br>\n <b>Specific compile time checks are<\/b>:<br>\n N: Has to be >= 1<br>\n <br>\n <b>Specific run time checks are<\/b>: None<br>\n <br>","displayName":"Top n unique"},{"name":"com.datatorrent.lib.algo.UniqueCounter","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[{"name":"count","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Integer>"}],"shortDesc":"Counts the number of times a key exists in a window; Count is emitted at end of window in a single HashMap<p>\n This is an end of window operator<br>\n <br>\n <b>StateFull : yes, <\/b> Tuples are aggregated over application window(s)","longDesc":"<br>\n <b>Partitions : Yes, <\/b> Unique count is unified at output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects K<br>\n <b>count<\/b>: emits HashMap&lt;K,Integer&gt;<br>\n <b>Properties<\/b>: None<br>\n <br>","displayName":"Unique counter"},{"name":"com.datatorrent.lib.algo.UniqueCounterValue","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[{"name":"count","optional":true,"error":false,"tupleType":"class java.lang.Integer"}],"shortDesc":"Counts the number of tuples emitted in a window","longDesc":"<p>\n This is an end of window operator<br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects K<br>\n <b>count<\/b>: emits Integer<br>\n <b>Properties<\/b>: None<br>\n <br>\n <b>Specific compile time checks<\/b>: None<br>\n <b>Specific run time checks<\/b>:<br>\n <br>\n <b>Benchmarks<\/b>: Blast as many tuples as possible in inline mode<br>\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Benchmark table for UniqueCounter&lt;K&gt; operator template\">\n <tr><th>In-Bound<\/th><th>Out-bound<\/th><th>Comments<\/th><\/tr>\n <tr><td><b>&gt; processes 110 Million K,V pairs\/s<\/b><\/td><td>Emits one tuple per window<\/td><td>In-bound throughput\n and number of unique k are the main determinant of performance. Tuples are assumed to be immutable. If you use mutable tuples and have lots of keys,\n the benchmarks may be lower<\/td><\/tr>\n <\/table><br>\n <p>\n <b>Function Table (K=String)<\/b>:\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Function table for UniqueCounter&lt;K&gt; operator template\">\n <tr><th rowspan=2>Tuple Type (api)<\/th><th>In-bound (process)<\/th><th>Out-bound (emit)<\/th><\/tr>\n <tr><th><i>data<\/i>(K)<\/th><th><i>count<\/i>(Integer)<\/th><\/tr>\n <tr><td>Begin Window (beginWindow())<\/td><td>N\/A<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>a<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>b<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>c<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>4<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>5ah<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>h<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>a<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>a<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>a<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>a<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>5ah<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>a<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>c<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>c<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>b<\/td><\/tr>\n <tr><td>End Window (endWindow())<\/td><td>N\/A<\/td><td>15<\/td><\/tr>\n <\/table>\n <br>","displayName":"Unique counter value"},{"name":"com.datatorrent.lib.algo.UniqueKeyValCounter","properties":[{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.HashMap<K, V>"}],"outputPorts":[{"name":"count","optional":true,"error":false,"tupleType":"java.util.HashMap<java.util.HashMap<K, V>, java.lang.Integer>"}],"shortDesc":"Count unique occurrences of key,val pairs within a window, and emits one HashMap tuple","longDesc":"<p>\n This is an end of window operator<br>\n <br>\n <b>StateFull : yes, <\/b> Tuples are aggregated over application window(s). <br>\n <b>Partitions : Yes, <\/b> Unique count is unified at output port. <br>\n <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects HashMap&lt;K,V&gt;<br>\n <b>count<\/b>: emits HashMap&lt;HashMap&lt;K,V&gt;(1),Integer&gt;(1)<br>\n <br>","displayName":"Unique key val counter"},{"name":"com.datatorrent.lib.algo.UniqueValueCount","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Object>"}],"outputPorts":[{"name":"output","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>"}],"shortDesc":"Counts no","longDesc":"of unique values of a key within a window.<br>\n Emits {@link InternalCountOutput} which contains the key, count of its unique values\n and also the set of values.<br>\n When the operator is partitioned, the unifier uses the internal set of values to\n compute the count of unique values again.<br>\n <br>\n Partitions: yes, uses {@link UniqueCountUnifier} to merge partitioned output.<br>\n Stateful: no<br>\n <br><\/br>","displayName":"Unique value count"},{"name":"com.datatorrent.lib.algo.UniqueValueCount$UniqueCountUnifier","properties":[],"inputPorts":[],"outputPorts":[{"name":"output","optional":true,"error":false,"tupleType":"com.datatorrent.lib.algo.UniqueValueCount.com.datatorrent.lib.algo.UniqueValueCount$InternalCountOutput<K>"}]},{"name":"com.datatorrent.lib.algo.UniqueValueKeyVal","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, ?>"}],"outputPorts":[{"name":"count","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>"}],"shortDesc":"Count unique occurrences of vals for every key within a window, and emits Key,Integer pairs tuple.<p>\n This is an end of window operator","longDesc":"It uses sticky key partition and default unifier<br>\n <br>\n <b>StateFull : Yes, <\/b> Tuple are aggregated across application window(s). <br>\n <b>Partitions : Yes, <\/b> Unique key\/value are unified at output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects KeyValPair&lt;K,V&gt;<br>\n <b>count<\/b>: emits KeyValPair&lt;K,Integer&gt;<br>\n <br>","displayName":"Unique value key val"},{"name":"com.datatorrent.lib.algo.UniqueValueMap","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, ?>"}],"outputPorts":[{"name":"count","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Integer>"}],"shortDesc":"Count unique occurrences of vals for every key within a window, and emits Key,Integer pairs tuple.<p>\n This is an end of window operator","longDesc":"It uses sticky key partition and default unifier<br>\n <br>\n <b>StateFull : Yes, <\/b> Tuple are aggregated across application window(s). <br>\n <b>Partitions : Yes, <\/b> Top values are unified on output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V&gt;<br>\n <b>count<\/b>: emits HashMap&lt;K,Integer&gt;<br>\n <br>","displayName":"Unique value map"},{"name":"com.datatorrent.lib.chart.TimeSeriesAverageChartOperator","properties":[{"name":"chartType","canGet":true,"canSet":false,"description":"The chart type","type":"com.datatorrent.lib.chart.ChartOperator$Type"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"xAxisLabel","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"yAxisLabel","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"yNumberType","canGet":true,"canSet":true,"type":"com.datatorrent.lib.chart.XYChartOperator$NumberType"}],"inputPorts":[{"name":"in1","optional":false,"tupleType":"class java.lang.Object","description":"The input port of the chart operator."}],"outputPorts":[{"name":"chart","optional":true,"error":false,"tupleType":"java.util.Map<K, java.util.Map<X, Y>>","description":"The output port of the chart operator.  The data of this will be shipped to the module that draws the chart."}],"shortDesc":"This is the chart operator that plots the average (mean) value of Y for each window","longDesc":" X will be based on the timestamp derived from the window id","displayName":"Time series average chart operator"},{"name":"com.datatorrent.lib.chart.TimeSeriesCandleStickChartOperator","properties":[{"name":"chartType","canGet":true,"canSet":false,"description":"The chart type","type":"com.datatorrent.lib.chart.ChartOperator$Type"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"xAxisLabel","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"yAxisLabel","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"yNumberType","canGet":true,"canSet":true,"type":"com.datatorrent.lib.chart.XYChartOperator$NumberType"}],"inputPorts":[{"name":"in1","optional":false,"tupleType":"class java.lang.Object","description":"The input port of the chart operator."}],"outputPorts":[{"name":"chart","optional":true,"error":false,"tupleType":"java.util.Map<K, java.util.Map<X, Y>>","description":"The output port of the chart operator.  The data of this will be shipped to the module that draws the chart."}],"shortDesc":"This is the chart operator that plots the candle stick of Y for each window","longDesc":" X will be based on the timestamp derived from the window id","displayName":"Time series candle stick chart operator"},{"name":"com.datatorrent.lib.io.ApacheGenRandomLogs","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"class java.lang.String"}],"shortDesc":"Generates apache server log entries","longDesc":"The apache access log has the following\n format\n\n %s %h %l %u %t \"%r\" %s %b \"%{Referer}\" \"%{User-agent}\"\n\n %s - server name - server0.mydomain.com:80 .......................  server9.mydomain.com:80\n %h - The ip address of the client\n %l - The identity of the client typically \"-\"\n %u - The username of the user if HTTP authentication was used otherwise \"-\"\n %t - The time the request was received e.g., [31\/May\/2013:08:03:46 -0700]\n %r - The HTTP request string e.g., \"GET \/favicon.ico HTTP\/1.1\"\n %s - The status code of the response e.g., 404\n %b - The number of bytes in the response\n %{Referer} - The referer web site reported by the client, \"-\" if there is none\n %{User-agent} - Unique string identifying the client browser e.g.,\n \t\t\t\t\t\t\t\"Mozilla\/5.0 (Windows NT 6.1) AppleWebKit\/537.36 (KHTML, like Gecko) Chrome\/28.0.1468.0 Safari\/537.36\"\n\n Putting it all together a sample log string looks like :\n --------------------------------------------------------\n 127.0.0.1 - [31\/May\/2013:09:05:49 -0700] \"GET \/favicon.ico HTTP\/1.1\" 304 210 \"-\"\n \"Mozilla\/5.0 (X11; Linux x86_64) AppleWebKit\/537.22 (KHTML, like Gecko) Ubuntu Chromium\/25.0.1364.160 Chrome\/25.0.1364.160 Safari\/537.22\"","displayName":"Apache gen random logs"},{"name":"com.datatorrent.lib.io.CollectionMultiConsoleOutputOperator","properties":[{"name":"debug","canGet":true,"canSet":true,"type":"boolean"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"silent","canGet":true,"canSet":true,"type":"boolean"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"java.util.Collection<E>"}],"outputPorts":[],"shortDesc":"Writes tuples to standard out of the container\n <p>\n This is for specific use case for collection where I want to print each key\n value pair in different line <br>\n Mainly to be used for debugging","longDesc":"Users should be careful to not have this\n node listen to a high throughput stream<br>\n <br>","displayName":"Collection multi console output operator"},{"name":"com.datatorrent.lib.io.ConsoleOutputOperator","properties":[{"name":"debug","canGet":true,"canSet":true,"type":"boolean"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"silent","canGet":true,"canSet":true,"description":"the silent","type":"boolean"},{"name":"stringFormat","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[],"shortDesc":"Writes tuples to stdout of the container<p>\n <br>\n Mainly to be used for debugging","longDesc":"Users should be careful to not have this node listen to a high throughput stream<br>\n <br>","displayName":"Console output operator"},{"name":"com.datatorrent.lib.io.FtpInputOperator","properties":[{"name":"delay","canGet":true,"canSet":true,"description":"the delay","type":"long"},{"name":"filePath","canGet":true,"canSet":true,"description":"the filePath","type":"java.lang.String"},{"name":"ftpServer","canGet":true,"canSet":true,"description":"the ftpServer","type":"java.lang.String"},{"name":"gzip","canGet":true,"canSet":true,"description":"the isGzip","type":"boolean"},{"name":"localPassiveMode","canGet":true,"canSet":true,"description":"the localPassiveMode","type":"boolean"},{"name":"numberOfTuples","canGet":true,"canSet":true,"description":"the numberOfTuples","type":"int"},{"name":"password","canGet":true,"canSet":true,"description":"the password","type":"java.lang.String"},{"name":"port","canGet":true,"canSet":true,"description":"the port","type":"int"},{"name":"userName","canGet":true,"canSet":true,"description":"the userName","type":"java.lang.String"}],"inputPorts":[],"outputPorts":[{"name":"output","optional":true,"error":false,"tupleType":"class java.lang.String"}],"shortDesc":"This operator emits each line as different tuple for a give file hosted on a ftp server <br>\n\n <b>Ports<\/b>:<br>\n <b>outport<\/b>: emits &lt;String&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>filePath<\/b> : Path for file to be read","longDesc":"<br>\n <b>delay<\/b>: Thread sleep interval after emitting line.<br>\n <b>numberOfTuples<\/b>: Number of tuples to be emitted in a single emit Tuple call.<br>\n <b>ftpServer<\/b>: The ftp server where the file is hosted.<br>\n <b>port<\/b>: Port of the ftp server.<br>\n <b>userName<\/b>: The user name used to login to ftp server. Default is anonymous.<br>\n <b>password<\/b>: The password used to login to ftp server.<br>\n <b>isGzip<\/b>: If the format of the file is gzip.<br>","displayName":"Ftp input operator"},{"name":"com.datatorrent.lib.io.HttpGetMapOperator","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"url","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[{"name":"output","optional":true,"error":false,"tupleType":"class java.lang.Object"}],"shortDesc":"Operator to take in map of key value pairs and make a HTTP GET request with the key value pairs from the map\n as query parameters in the request","longDesc":"\n If output port is connected, the response is emitted as {@link String} through the output port.","displayName":"Http get map operator"},{"name":"com.datatorrent.lib.io.HttpJsonChunksInputOperator","properties":[{"name":"active","canGet":true,"canSet":false,"type":"boolean"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"url","canGet":false,"canSet":true,"type":"java.net.URI","properties":[{"name":"absolute","canGet":true,"canSet":false,"type":"boolean"},{"name":"authority","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"fragment","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"host","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"opaque","canGet":true,"canSet":false,"type":"boolean"},{"name":"path","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"port","canGet":true,"canSet":false,"type":"int"},{"name":"query","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawAuthority","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawFragment","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawPath","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawQuery","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawSchemeSpecificPart","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawUserInfo","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"scheme","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"schemeSpecificPart","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"userInfo","canGet":true,"canSet":false,"type":"java.lang.String"}]}],"inputPorts":[],"outputPorts":[{"name":"outputPort","optional":true,"error":false,"tupleType":"class java.lang.Object","description":"The single output port of this input operator.\n Collects asynchronously emitted tuples and flushes in container thread."},{"name":"rawOutput","optional":true,"error":false,"tupleType":"class java.lang.String"}],"shortDesc":"(entities on stream delimited by leading length)\n Incoming data is interpreted as JSONObject and converted to {@link java.util.Map}.<br>\n If second rawOutput is connected then content is streamed to this port as it is","longDesc":" <br>","displayName":"Http json chunks input operator"},{"name":"com.datatorrent.lib.io.HttpLinesInputOperator","properties":[{"name":"active","canGet":true,"canSet":false,"type":"boolean"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"url","canGet":false,"canSet":true,"type":"java.net.URI","properties":[{"name":"absolute","canGet":true,"canSet":false,"type":"boolean"},{"name":"authority","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"fragment","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"host","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"opaque","canGet":true,"canSet":false,"type":"boolean"},{"name":"path","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"port","canGet":true,"canSet":false,"type":"int"},{"name":"query","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawAuthority","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawFragment","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawPath","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawQuery","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawSchemeSpecificPart","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawUserInfo","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"scheme","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"schemeSpecificPart","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"userInfo","canGet":true,"canSet":false,"type":"java.lang.String"}]}],"inputPorts":[],"outputPorts":[{"name":"outputPort","optional":true,"error":false,"tupleType":"class java.lang.Object","description":"The single output port of this input operator.\n Collects asynchronously emitted tuples and flushes in container thread."},{"name":"rawOutput","optional":true,"error":false,"tupleType":"class java.lang.String"}],"shortDesc":"Incoming data is interpreted as lines of plain text and each tuple output is a line in the content\n <br>","displayName":"Http lines input operator"},{"name":"com.datatorrent.lib.io.HttpOutputOperator","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"resourceURL","canGet":false,"canSet":true,"type":"java.net.URI","properties":[{"name":"absolute","canGet":true,"canSet":false,"type":"boolean"},{"name":"authority","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"fragment","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"host","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"opaque","canGet":true,"canSet":false,"type":"boolean"},{"name":"path","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"port","canGet":true,"canSet":false,"type":"int"},{"name":"query","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawAuthority","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawFragment","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawPath","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawQuery","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawSchemeSpecificPart","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawUserInfo","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"scheme","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"schemeSpecificPart","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"userInfo","canGet":true,"canSet":false,"type":"java.lang.String"}]},{"name":"url","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[],"shortDesc":"Sends tuple as POST with JSON content to the given URL<p>\n <br>\n Data of type {@link java.util.Map} is converted to JSON","longDesc":"All other types are sent in their {@link Object#toString()} representation.<br>\n <br>","displayName":"Http output operator"},{"name":"com.datatorrent.lib.io.HttpPostOutputOperator","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"url","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[],"shortDesc":"Sends tuple as POST with JSON content to the given URL<p>\n <br>\n Data of type {@link java.util.Map} is converted to JSON","longDesc":"All other types are sent in their {@link Object#toString()} representation.<br>\n <br>","displayName":"Http post output operator"},{"name":"com.datatorrent.lib.io.MapMultiConsoleOutputOperator","properties":[{"name":"debug","canGet":true,"canSet":true,"type":"boolean"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"silent","canGet":true,"canSet":true,"type":"boolean"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"java.util.Map<K, V>"}],"outputPorts":[],"shortDesc":"Writes tuples to standard out of the container\n <p>\n This is for specific use case for map where I want to print each key value\n pair in different line <br>\n Mainly to be used for debugging","longDesc":"Users should be careful to not have this\n node listen to a high throughput stream<br>\n <br>","displayName":"Map multi console output operator"},{"name":"com.datatorrent.lib.io.PubSubWebSocketInputOperator","properties":[{"name":"active","canGet":true,"canSet":false,"type":"boolean"},{"name":"ioThreadMultiplier","canGet":true,"canSet":true,"description":"the IO thread multiplier","type":"int"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"uri","canGet":true,"canSet":true,"description":"the URI","type":"java.net.URI","properties":[{"name":"absolute","canGet":true,"canSet":false,"type":"boolean"},{"name":"authority","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"fragment","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"host","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"opaque","canGet":true,"canSet":false,"type":"boolean"},{"name":"path","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"port","canGet":true,"canSet":false,"type":"int"},{"name":"query","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawAuthority","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawFragment","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawPath","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawQuery","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawSchemeSpecificPart","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawUserInfo","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"scheme","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"schemeSpecificPart","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"userInfo","canGet":true,"canSet":false,"type":"java.lang.String"}]}],"inputPorts":[],"outputPorts":[{"name":"outputPort","optional":true,"error":false,"tupleType":"class java.lang.Object","description":"The single output port of this input operator.\n Collects asynchronously emitted tuples and flushes in container thread."}],"shortDesc":"<p>PubSubWebSocketInputOperator class.<\/p>","displayName":"Pub sub web socket input operator"},{"name":"com.datatorrent.lib.io.PubSubWebSocketOutputOperator","properties":[{"name":"ioThreadMultiplier","canGet":true,"canSet":true,"description":"the IO thread multiplier","type":"int"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"numRetries","canGet":true,"canSet":true,"description":"the number of retries","type":"int"},{"name":"topic","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"uri","canGet":true,"canSet":true,"description":"the URI","type":"java.net.URI","properties":[{"name":"absolute","canGet":true,"canSet":false,"type":"boolean"},{"name":"authority","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"fragment","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"host","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"opaque","canGet":true,"canSet":false,"type":"boolean"},{"name":"path","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"port","canGet":true,"canSet":false,"type":"int"},{"name":"query","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawAuthority","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawFragment","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawPath","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawQuery","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawSchemeSpecificPart","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawUserInfo","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"scheme","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"schemeSpecificPart","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"userInfo","canGet":true,"canSet":false,"type":"java.lang.String"}]},{"name":"waitMillisRetry","canGet":true,"canSet":true,"description":"wait in milliseconds","type":"int"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"class java.lang.Object","description":"The input port"}],"outputPorts":[],"shortDesc":"<p>PubSubWebSocketOutputOperator class.<\/p>","displayName":"Pub sub web socket output operator"},{"name":"com.datatorrent.lib.io.SimpleSinglePortInputOperator","properties":[{"name":"active","canGet":true,"canSet":false,"type":"boolean"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[],"outputPorts":[{"name":"outputPort","optional":true,"error":false,"tupleType":"class java.lang.Object","description":"The single output port of this input operator.\n Collects asynchronously emitted tuples and flushes in container thread."}],"shortDesc":"A simple Base class for input operator with a single output port without recovery","longDesc":" <p>\n Handles hand over from asynchronous input to port processing thread (tuples\n must be emitted by container thread). If derived class implements\n {@link Runnable} to perform synchronous IO, this class will manage the thread\n according to the operator lifecycle.","displayName":"Simple single port input operator"},{"name":"com.datatorrent.lib.io.SmtpOutputOperator","properties":[{"name":"content","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"contentType","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"from","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"smtpHost","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"smtpPassword","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"smtpPort","canGet":true,"canSet":true,"type":"int"},{"name":"smtpUserName","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"subject","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"useSsl","canGet":true,"canSet":true,"type":"boolean"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[],"shortDesc":"<p>SmtpOutputOperator class.<\/p>","displayName":"Smtp output operator"},{"name":"com.datatorrent.lib.io.WebSocketInputOperator","properties":[{"name":"active","canGet":true,"canSet":false,"type":"boolean"},{"name":"ioThreadMultiplier","canGet":true,"canSet":true,"description":"the IO thread multiplier","type":"int"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"uri","canGet":true,"canSet":true,"description":"the URI","type":"java.net.URI","properties":[{"name":"absolute","canGet":true,"canSet":false,"type":"boolean"},{"name":"authority","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"fragment","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"host","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"opaque","canGet":true,"canSet":false,"type":"boolean"},{"name":"path","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"port","canGet":true,"canSet":false,"type":"int"},{"name":"query","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawAuthority","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawFragment","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawPath","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawQuery","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawSchemeSpecificPart","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawUserInfo","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"scheme","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"schemeSpecificPart","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"userInfo","canGet":true,"canSet":false,"type":"java.lang.String"}]}],"inputPorts":[],"outputPorts":[{"name":"outputPort","optional":true,"error":false,"tupleType":"class java.lang.Object","description":"The single output port of this input operator.\n Collects asynchronously emitted tuples and flushes in container thread."}],"shortDesc":"Reads via WebSocket from given URL as input stream<p>\n <br>\n Incoming data is interpreted as JSONObject and converted to {@link java.util.Map}.<br>\n <br>","displayName":"Web socket input operator"},{"name":"com.datatorrent.lib.io.WebSocketOutputOperator","properties":[{"name":"ioThreadMultiplier","canGet":true,"canSet":true,"description":"the IO thread multiplier","type":"int"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"numRetries","canGet":true,"canSet":true,"description":"the number of retries","type":"int"},{"name":"uri","canGet":true,"canSet":true,"description":"the URI","type":"java.net.URI","properties":[{"name":"absolute","canGet":true,"canSet":false,"type":"boolean"},{"name":"authority","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"fragment","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"host","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"opaque","canGet":true,"canSet":false,"type":"boolean"},{"name":"path","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"port","canGet":true,"canSet":false,"type":"int"},{"name":"query","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawAuthority","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawFragment","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawPath","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawQuery","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawSchemeSpecificPart","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawUserInfo","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"scheme","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"schemeSpecificPart","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"userInfo","canGet":true,"canSet":false,"type":"java.lang.String"}]},{"name":"waitMillisRetry","canGet":true,"canSet":true,"description":"wait in milliseconds","type":"int"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"class java.lang.Object","description":"The input port"}],"outputPorts":[],"shortDesc":"Reads via WebSocket from given URL as input stream<p>\n <br>\n Incoming data is interpreted as JSONObject and converted to {@link java.util.Map}.<br>\n <br>","displayName":"Web socket output operator"},{"name":"com.datatorrent.lib.io.WidgetOutputOperator$1","properties":[{"name":"ioThreadMultiplier","canGet":true,"canSet":true,"description":"the IO thread multiplier","type":"int"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"numRetries","canGet":true,"canSet":true,"description":"the number of retries","type":"int"},{"name":"uri","canGet":true,"canSet":true,"description":"the URI","type":"java.net.URI","properties":[{"name":"absolute","canGet":true,"canSet":false,"type":"boolean"},{"name":"authority","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"fragment","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"host","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"opaque","canGet":true,"canSet":false,"type":"boolean"},{"name":"path","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"port","canGet":true,"canSet":false,"type":"int"},{"name":"query","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawAuthority","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawFragment","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawPath","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawQuery","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawSchemeSpecificPart","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawUserInfo","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"scheme","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"schemeSpecificPart","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"userInfo","canGet":true,"canSet":false,"type":"java.lang.String"}]},{"name":"waitMillisRetry","canGet":true,"canSet":true,"description":"wait in milliseconds","type":"int"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"class java.lang.Object","description":"The input port"}],"outputPorts":[]},{"name":"com.datatorrent.lib.io.fs.DirectoryScanInputOperator","properties":[{"name":"directoryPath","canGet":true,"canSet":true,"description":"directoryPath the path of directory being scanned.","type":"java.lang.String"},{"name":"fileCountPerEmit","canGet":true,"canSet":true,"description":"fileCountPerEmit the number of file records that are output per emit","type":"int"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"scanIntervalInMilliSeconds","canGet":true,"canSet":true,"description":"scanIntervalInMilliSeconds the interval at which the directory is being scanned","type":"int"}],"inputPorts":[],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"class com.datatorrent.lib.io.fs.FileInfoRecord"}],"shortDesc":"\/**\n Input Adapter that scans for files in the specified local directory","longDesc":" Since the operator can be deployed anywhere in the cluster the directory\n to be scanned should be available on all nodes of the cluster.\n Not to be used for HDFS.\n <p>","displayName":"Directory scan input operator"},{"name":"com.datatorrent.lib.io.fs.HdfsExactlyOnceOutputOperator","properties":[{"name":"append","canGet":false,"canSet":true,"type":"boolean"},{"name":"bufferSize","canGet":false,"canSet":true,"type":"int"},{"name":"filePath","canGet":true,"canSet":true,"description":"","type":"java.lang.String"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"replication","canGet":false,"canSet":true,"type":"int"},{"name":"totalBytesWritten","canGet":true,"canSet":false,"type":"long"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[],"shortDesc":"HDFSOutput Operator that writes the data exactly once","longDesc":" The Operator creates file <window_id>.tmp during beginwindow and writes the tuples to it.\n It moves the file to <window_id> in the end window.\n If the operator fails and recovers, checks if the file <window_id> exists during begin window. If it does,\n then the operator doesn't process anything during that window. If it doesn't, then the operator deletes\n the <window_id>.tmp file if it exists, creates new and starts writing to it.","displayName":"Hdfs exactly once output operator"},{"name":"com.datatorrent.lib.io.fs.HdfsTextFileInputOperator","properties":[{"name":"filePath","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"linesEachWindow","canGet":true,"canSet":true,"type":"int"}],"inputPorts":[],"outputPorts":[{"name":"HDFSOutput","optional":true,"error":false,"tupleType":"class java.lang.String"}],"shortDesc":"An adaptor to read from hdfs text file input operator\n Read tuple from the text file in HDFS distributed filesystem\n Read #linesEachWindow lines for each dag window","displayName":"Hdfs text file input operator"},{"name":"com.datatorrent.lib.io.fs.HdfsWordInputOperator","properties":[{"name":"filePath","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"tupleSize","canGet":true,"canSet":true,"description":"the tupleSize","type":"int"}],"inputPorts":[],"outputPorts":[{"name":"HDFSOutput","optional":true,"error":false,"tupleType":"byte[]"}],"shortDesc":"Input operator to read words of specified size from HDFS file\n Reads words of specified size from the file in HDFS\n Reads as many words as possible in each dag window.","displayName":"Hdfs word input operator"},{"name":"com.datatorrent.lib.io.fs.LocalFsInputOperator","properties":[{"name":"filePath","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"sleepInterval","canGet":true,"canSet":true,"type":"int"}],"inputPorts":[],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"class java.lang.String"}],"shortDesc":"<p>\n This operator opens given file from local file system","longDesc":"Each line is emitted on\n output port, Thread waits for sleep interval after emitting line.\n\n <br>\n <b>Ports<\/b>:<br>\n <b>outport<\/b>: emits &lt;String&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>filePath<\/b> : Path for file to be read. <br>\n <b>sleepInterval<\/b>: Thread sleep interval after emitting line.<br>\n <br>","displayName":"Local fs input operator"},{"name":"com.datatorrent.lib.io.fs.TailFsInputOperator","properties":[{"name":"delay","canGet":true,"canSet":true,"description":"the delay","type":"long"},{"name":"delimiter","canGet":true,"canSet":true,"description":"the delimiter","type":"char"},{"name":"end","canGet":true,"canSet":true,"description":"the end","type":"boolean"},{"name":"filePath","canGet":true,"canSet":true,"description":"the filePath","type":"java.lang.String"},{"name":"numberOfTuples","canGet":true,"canSet":true,"description":"the numberOfTuples","type":"int"},{"name":"position","canGet":true,"canSet":true,"description":"the position","type":"long"}],"inputPorts":[],"outputPorts":[{"name":"output","optional":true,"error":false,"tupleType":"class java.lang.String"}],"shortDesc":"<p>\n This operator implements \"tail -f\" command","longDesc":"If the operator has reached the end of the file, it will wait till more\n data comes\n\n <br>\n <b>Ports<\/b>:<br>\n <b>outport<\/b>: emits &lt;String&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>filePath<\/b> : Path for file to be read. <br>\n <b>delay<\/b>: Thread sleep interval after emitting line.<br>\n <b>position<\/b>: The position from where to start reading the file.<br>\n <b>numberOfTuples<\/b>: number of tuples to be emitted in a single emit Tuple call.<br>\n <b>end<\/b>: if the user wants to start tailing from end.<br>\n <br>","displayName":"Tail fs input operator"},{"name":"com.datatorrent.lib.io.jms.ActiveMQSinglePortStringInputOperator","properties":[{"name":"ackMode","canGet":true,"canSet":true,"description":"the message acknowledgment mode","type":"java.lang.String"},{"name":"batch","canGet":true,"canSet":true,"description":"the batch","type":"int"},{"name":"bufferSize","canGet":true,"canSet":true,"description":"the buffer size","type":"int"},{"name":"clientId","canGet":true,"canSet":true,"description":"the clientId","type":"java.lang.String"},{"name":"connection","canGet":true,"canSet":false,"description":"the connection","type":"javax.jms.Connection","properties":[{"name":"clientID","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"exceptionListener","canGet":true,"canSet":true,"type":"javax.jms.ExceptionListener","properties":[]},{"name":"metaData","canGet":true,"canSet":false,"type":"javax.jms.ConnectionMetaData","properties":[{"name":"JMSMajorVersion","canGet":true,"canSet":false,"type":"int"},{"name":"JMSMinorVersion","canGet":true,"canSet":false,"type":"int"},{"name":"JMSProviderName","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"JMSVersion","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"JMSXPropertyNames","canGet":true,"canSet":false,"type":"java.util.Enumeration","properties":[]},{"name":"providerMajorVersion","canGet":true,"canSet":false,"type":"int"},{"name":"providerMinorVersion","canGet":true,"canSet":false,"type":"int"},{"name":"providerVersion","canGet":true,"canSet":false,"type":"java.lang.String"}]}]},{"name":"connectionFactoryClass","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"connectionFactoryProperties","canGet":true,"canSet":true,"description":"reference to mutable properties","type":"java.util.Map","properties":[{"name":"empty","canGet":true,"canSet":false,"type":"boolean"}]},{"name":"consumer","canGet":true,"canSet":false,"description":"the message consumer","type":"javax.jms.MessageConsumer","properties":[{"name":"messageListener","canGet":true,"canSet":true,"type":"javax.jms.MessageListener","properties":[]},{"name":"messageSelector","canGet":true,"canSet":false,"type":"java.lang.String"}]},{"name":"consumerName","canGet":true,"canSet":true,"description":"the consumer name","type":"java.lang.String"},{"name":"destination","canGet":true,"canSet":false,"description":"the destination","type":"javax.jms.Destination","properties":[]},{"name":"durable","canGet":true,"canSet":true,"description":"the durability of the consumer","type":"boolean"},{"name":"maximumReceiveMessages","canGet":true,"canSet":true,"description":"the maximum of received messages","type":"long"},{"name":"messageSize","canGet":true,"canSet":true,"description":"the message size","type":"int"},{"name":"messagesReceived","canGet":true,"canSet":true,"description":"the count of messages received","type":"long"},{"name":"password","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"replyProducer","canGet":true,"canSet":false,"description":"the message producer","type":"javax.jms.MessageProducer","properties":[{"name":"deliveryMode","canGet":true,"canSet":true,"type":"int"},{"name":"destination","canGet":true,"canSet":false,"type":"javax.jms.Destination","properties":[]},{"name":"disableMessageID","canGet":true,"canSet":true,"type":"boolean"},{"name":"disableMessageTimestamp","canGet":true,"canSet":true,"type":"boolean"},{"name":"priority","canGet":true,"canSet":true,"type":"int"},{"name":"timeToLive","canGet":true,"canSet":true,"type":"long"}]},{"name":"session","canGet":true,"canSet":false,"description":"the session","type":"javax.jms.Session","properties":[{"name":"acknowledgeMode","canGet":true,"canSet":false,"type":"int"},{"name":"messageListener","canGet":true,"canSet":true,"type":"javax.jms.MessageListener","properties":[]},{"name":"transacted","canGet":true,"canSet":false,"type":"boolean"}]},{"name":"subject","canGet":true,"canSet":true,"description":"the name of the destination","type":"java.lang.String"},{"name":"topic","canGet":true,"canSet":true,"description":"the topic","type":"boolean"},{"name":"transacted","canGet":true,"canSet":true,"description":"the transacted","type":"boolean"},{"name":"tuplesBlast","canGet":true,"canSet":true,"description":"the tuplesBlast","type":"int"},{"name":"url","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"user","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"verbose","canGet":true,"canSet":true,"type":"boolean"}],"inputPorts":[],"outputPorts":[{"name":"outputPort","optional":true,"error":false,"tupleType":"class java.lang.Object","description":"The single output port."}],"shortDesc":"<p>ActiveMQStringInputOperator class.<\/p>","displayName":"Active m q single port string input operator"},{"name":"com.datatorrent.lib.logs.ApacheLogParseMapOutputOperator","properties":[{"name":"logRegex","canGet":true,"canSet":true,"description":"the logRegex","type":"java.lang.String"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"regexGroups","canGet":true,"canSet":true,"description":"the groups","type":"[Ljava.lang.String;"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.String","description":"Input log line port."}],"outputPorts":[{"name":"output","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Client IP address, output port."}],"shortDesc":"Parse Apache log lines one line at a time","longDesc":"logRegex is used as a parser. The fields extracted are defined as a\n property\n <p>\n This is a pass through operator<br>\n <br>\n <b>StateFull : No <\/b><br>\n <b>Partitions : Yes<\/b>, No dependency among input values. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects String<br>\n <b>output<\/b>: emits Map<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>logRegex<\/b>: defines the regex <br>\n <b>groupMap<\/b>: defines the mapping from the group ids to the names <br>","displayName":"Apache log parse map output operator"},{"name":"com.datatorrent.lib.logs.ApacheLogParseOperator","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.String","description":"Input log line port."}],"outputPorts":[{"name":"outputAgent","optional":true,"error":false,"tupleType":"class java.lang.String","description":"IP Agent, output port."},{"name":"outputBytes","optional":true,"error":false,"tupleType":"class java.lang.Long","description":"Number of bytes served, output port."},{"name":"outputIPAddress","optional":true,"error":false,"tupleType":"class java.lang.String","description":"Client IP address, output port."},{"name":"outputReferer","optional":true,"error":false,"tupleType":"class java.lang.String","description":"Referer name, output port."},{"name":"outputStatusCode","optional":true,"error":false,"tupleType":"class java.lang.String","description":"Apache status log, output port."},{"name":"outputUrl","optional":true,"error":false,"tupleType":"class java.lang.String","description":"Access url port, output port."}],"shortDesc":"Parse Apache log lines one line at a time","longDesc":"Regex (getAccessLogRegex) is used\n as a parser. The fields extracted include i\/p (outputIPAddress), url\n (outputUrl), status code (outputStatusCode), bytes (outputBytes), referer\n (outputReferer), and agent (outputAgent)\n <p>\n This is a pass through operator<br>\n <br>\n <b>StateFull : No <\/b><br>\n <b>Partitions : Yes<\/b>, No dependency among input values. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects String<br>\n <b>outputIPAddress<\/b>: emits String<br>\n <b>outputUrl<\/b>: emits String<br>\n <b>outputStatusCode<\/b>: emits String<br>\n <b>outputBytes<\/b>: emits String<br>\n <b>outputReferer<\/b>: emits String<br>\n <b>outputAgent<\/b>: emits String<br>\n <br>\n <b>Properties<\/b>: none<br>","displayName":"Apache log parse operator"},{"name":"com.datatorrent.lib.logs.ApacheVirtualLogParseOperator","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.String"}],"outputPorts":[{"name":"clientDataUsage","optional":true,"error":false,"tupleType":"class java.lang.Integer"},{"name":"outServerStatus","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.String>"},{"name":"outUrlStatus","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.String>"},{"name":"outputAgent","optional":true,"error":false,"tupleType":"class java.lang.String"},{"name":"outputBytes","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Integer>"},{"name":"outputIPAddress","optional":true,"error":false,"tupleType":"class java.lang.String"},{"name":"outputReferer","optional":true,"error":false,"tupleType":"class java.lang.String"},{"name":"outputServerName","optional":true,"error":false,"tupleType":"class java.lang.String"},{"name":"outputServerName1","optional":true,"error":false,"tupleType":"class java.lang.String"},{"name":"outputStatusCode","optional":true,"error":false,"tupleType":"class java.lang.String"},{"name":"outputUrl","optional":true,"error":false,"tupleType":"class java.lang.String"},{"name":"viewCount","optional":true,"error":false,"tupleType":"class java.lang.Integer"}],"shortDesc":"Please refer to docs for {@link com.datatorrent.lib.logs.ApacheLogParseOperator} documentation","longDesc":" More output ports in this operator.","displayName":"Apache virtual log parse operator"},{"name":"com.datatorrent.lib.logs.DimensionAggregationUnifier","properties":[],"inputPorts":[{"name":"input","optional":false,"tupleType":"java.util.Map<java.lang.String, com.datatorrent.lib.logs.DimensionObject<java.lang.String>>"}],"outputPorts":[{"name":"output","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, com.datatorrent.lib.logs.DimensionObject<java.lang.String>>"}],"shortDesc":"<p>DimensionAggregationUnifier class.<\/p>","displayName":"Dimension aggregation unifier"},{"name":"com.datatorrent.lib.logs.FilteredLineToTokenArrayList","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.String;"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"splitBy","canGet":true,"canSet":true,"description":"splitBy","type":"java.lang.String"},{"name":"splitTokenBy","canGet":true,"canSet":true,"description":"splitTokenBy","type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.String"}],"outputPorts":[{"name":"splittokens","optional":true,"error":false,"tupleType":"java.util.ArrayList<java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.String>>>","description":"Output sub tokens port."},{"name":"tokens","optional":true,"error":false,"tupleType":"java.util.ArrayList<java.lang.String>","description":"Output token port."}],"shortDesc":"Splits String objects into tokens, and emits filtered keys as ArrayList","longDesc":"An ArrayList of all tokens that pass the filter are emitted<p>\n This module is a pass through<br>\n <br>\n <b>StateFull : No, <\/b> tokens are processed in current window. <br>\n <b>Partitions : Yes, <\/b> No state dependency in output tokens. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: Input port, expects String<br>\n <b>tokens<\/b>: Output port, emits ArrayList<Object><br>\n <br>\n <b>Properties<\/b>:<br>\n <b>splitby<\/b>: The characters used to split the line. Default is \";\\t \"<br>\n <b>splittokenby<\/b>: The characters used to split a token into key,val pair. If not specified the value is set to null. Default is \",\", i.e. tokens are split<br>\n <b>filterby<\/b>: Only emit the keys (comma separated_that are in filterby<br>\n <br>\n <br>\n <br>","displayName":"Filtered line to token array list"},{"name":"com.datatorrent.lib.logs.FilteredLineToTokenHashMap","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.String;"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"splitBy","canGet":true,"canSet":true,"description":"splitBy","type":"java.lang.String"},{"name":"splitTokenBy","canGet":true,"canSet":true,"description":"splitTokenBy","type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.String"}],"outputPorts":[{"name":"tokens","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.String>>"}],"shortDesc":"<p>\n Splits the String tuples into tokens and emits filtered keys as HashMap","longDesc":"A\n HashMap of all filtered tokens are emitted on output port \"tokens\" . <br>\n <p>\n First token in line is treated as key and rest are put into values array list. <br>\n HashMap of token and array values are emitted on output port.\n This module is a pass through<br>\n <br>\n <b>StateFull : No, <\/b> tokens are processed in current window. <br>\n <b>Partitions : Yes, <\/b> No state dependency in output tokens. <br>\n <br>\n Ports:<br>\n <b>data<\/b>: Input port, expects String<br>\n <b>tokens<\/b>: Output port, emits HashMap<String, Object><br>\n <br>\n <b>Properties<\/b>:<br>\n <b>splitby<\/b>: The characters used to split the line. Default is \";\\t \"<br>\n <b>splittokenby<\/b>: The characters used to split a token into key,val pair.\n Default is \"\", i.e. tokens are not split, and key is set to token, and val is\n null<br>\n <b>filterby<\/b>: Only emit the keys (comma separated) that are in filterby<br>\n <br>","displayName":"Filtered line to token hash map"},{"name":"com.datatorrent.lib.logs.FilteredLineTokenizerKeyVal","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.String;"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"splitBy","canGet":true,"canSet":true,"description":"splitBy","type":"java.lang.String"},{"name":"splitTokenBy","canGet":true,"canSet":true,"description":"splitTokenBy","type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.String"}],"outputPorts":[{"name":"tokens","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.lang.String>"}],"shortDesc":"<p>\n Splits the String tuples into tokens ","longDesc":"Each token is emitted on output port \"tokens\" as key,val pair if the key exists in\n the filterby. This module is a pass through. Ideal for applications like log\n processing where only a few keys are to be processed<br>\n <br>\n <b>StateFull : No, <\/b> tokens are processed in current window. <br>\n <b>Partitions : Yes, <\/b> No state dependency in output tokens. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects String<br>\n <b>tokens<\/b>: emits HashMap&lt;String,String&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>splitby<\/b>: The characters used to split the line. Default is \";\\t \"<br>\n <b>splittokenby<\/b>: The characters used to split a token into key,val pair.\n Default is \"\", i.e. tokens are not split, and key is set to token, and val is\n null<br>\n <b>filterby<\/b>: Only emit the keys (comma separated) that are in filterby\n <br>","displayName":"Filtered line tokenizer key val"},{"name":"com.datatorrent.lib.logs.LineToTokenArrayList","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"splitBy","canGet":true,"canSet":true,"description":"splitBy","type":"java.lang.String"},{"name":"splitTokenBy","canGet":true,"canSet":true,"description":"splitTokenBy","type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.String"}],"outputPorts":[{"name":"splittokens","optional":true,"error":false,"tupleType":"java.util.ArrayList<java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.String>>>","description":"Output sub tokens port."},{"name":"tokens","optional":true,"error":false,"tupleType":"java.util.ArrayList<java.lang.String>","description":"Output token port."}],"shortDesc":"Splits String objects into tokens, and emits as ArrayList","longDesc":" An ArrayList of all tkns are emitted on output port \"tokens\".\n An ArrayList of all subtokens are emitted on port splittokens<p>\n This module is a pass through. Ideal for applications like log processing<br>\n <br>\n <b>StateFull : No, <\/b> tokens are processed in current window. <br>\n <b>Partitions : Yes, <\/b> output port unifier operator. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects String<br>\n <b>tokens<\/b>: emits ArrayList&lt;String&gt;<br>\n <b>splittokens<\/b>: emits ArrayList&lt;HashMap&lt;String,ArrayList&lt;String&gt;&gt;&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>splitby<\/b>: The characters used to split the line. Default is \";\\t \"<br>\n <b>splittokenby<\/b>: The characters used to split a token into key,val1,val2,.... If not specified the value is set to null. Default is \"\", i.e. tokens are not split<br>\n\n <br>","displayName":"Line to token array list"},{"name":"com.datatorrent.lib.logs.LineToTokenHashMap","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"splitBy","canGet":true,"canSet":true,"description":"splitBy","type":"java.lang.String"},{"name":"splitTokenBy","canGet":true,"canSet":true,"description":"splitTokenBy","type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.String"}],"outputPorts":[{"name":"tokens","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.String>>"}],"shortDesc":"<p>\n Splits String objects into tokens, and emits as HashMap","longDesc":" First token in line is treated as key and rest are put into values array list. <br>\n HashMap of token and array values are emitted on output port.\n This module is a pass through<br>\n <br>\n <b>StateFull : No, <\/b> tokens are processed in current window. <br>\n <b>Partitions : Yes, <\/b> output port unifier operator. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: Input port, expects String<br>\n <b>tokens<\/b>: Output port, emits HashMap&lt;String, ArrayList&lt;String&gt;&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>splitby<\/b>: The characters used to split the line. Default is \";\\t \"<br>\n <b>splittokenby<\/b>: The characters used to split a token into key,val1,val2,.... Default is \"\", i.e. tokens are not split, and key=token, val=\"\"<br>\n <br>","displayName":"Line to token hash map"},{"name":"com.datatorrent.lib.logs.LineTokenizer","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"splitBy","canGet":true,"canSet":true,"description":"splitBy","type":"java.lang.String"},{"name":"splitTokenBy","canGet":true,"canSet":true,"description":"splitTokenBy","type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.String"}],"outputPorts":[{"name":"tokens","optional":true,"error":false,"tupleType":"class java.lang.String"}],"shortDesc":"<p>\n Splits lines into tokens and emits token Strings on outpu port","longDesc":" This module is a pass through. Ideal for applications like word count, or log\n processing<br>\n <br>\n <b>StateFull : No, <\/b> tokens are processed in current window. <br>\n <b>Partitions : Yes, <\/b> No state dependency in output tokens. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects String<br>\n <b>tokens<\/b>: emits String<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>splitby<\/b>: The characters used to split the line. Default is \";\\t \"<br>\n <br>\n <br>","displayName":"Line tokenizer"},{"name":"com.datatorrent.lib.logs.LineTokenizerKeyVal","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"splitBy","canGet":true,"canSet":true,"description":"splitBy","type":"java.lang.String"},{"name":"splitTokenBy","canGet":true,"canSet":true,"description":"splitTokenBy","type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.String"}],"outputPorts":[{"name":"tokens","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.lang.String>"}],"shortDesc":"Splits lines into tokens, and tokens into sub-tokens and emits key,val pairs in a HashMap","longDesc":"Useful to convert String (log lines) into a POJO (HashMap)<p>\n This module is a pass through<br>\n <br>\n <b>StateFull : No, <\/b> tokens are processed in current window. <br>\n <b>Partitions : Yes, <\/b>output unifier. <br>\n <br>\n <br>\n Ideal for applications like log processing<br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects String<br>\n <b>tokens<\/b>: emits HashMap&lt;String,String&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>splitby<\/b>: The characters used to split the line. Default is \";\\t \"<br>\n <b>splittokenby<\/b>: The characters used to split a token into key,val pair. Default is \"\", i.e. tokens are not split, and key is set to token, and val is null<br>\n <br>","displayName":"Line tokenizer key val"},{"name":"com.datatorrent.lib.logs.MultiWindowDimensionAggregation","properties":[{"name":"dimensionArray","canGet":true,"canSet":true,"type":"java.util.List","properties":[{"name":"empty","canGet":true,"canSet":false,"type":"boolean"}]},{"name":"dimensionKeyVal","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"operationType","canGet":true,"canSet":true,"type":"com.datatorrent.lib.logs.MultiWindowDimensionAggregation$AggregateOperation"},{"name":"timeBucket","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"windowSize","canGet":true,"canSet":true,"type":"int"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<java.lang.String, java.util.Map<java.lang.String, java.lang.Number>>"}],"outputPorts":[{"name":"output","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, com.datatorrent.lib.logs.DimensionObject<java.lang.String>>"}],"shortDesc":"<p>\n MultiWindowDimensionAggregation class","longDesc":" <\/p>\n This class aggregates the value of given dimension across windows","displayName":"Multi window dimension aggregation"},{"name":"com.datatorrent.lib.logs.RegexMatchMapOperator","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"regex","canGet":true,"canSet":true,"description":"the regex","type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.String","description":"Input log line port."}],"outputPorts":[{"name":"output","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Output port."}],"shortDesc":"<p>Use this operator to parse unstructured log data into named fields.<\/p>\n\n <p>Uses a regex with named capturing groups (http:\/\/www.regular-expressions.info\/named.html) to extract portions of a string read\n from the input port into a Map<String,String>","longDesc":"The capturing group name is used as the key name. The captured value is used as\n the value.<\/p>\n\n <p>For example, given the input:\n   <br><code>12345 \"foo bar\" baz;goober<\/code><\/p>\n\n <p>And the regular expression:\n   <br><code>(?&lt;id&gt;\\d+) \"(?&lt;username&gt;[^\"]+)\" (?&lt;action&gt;[^;]+);(?&lt;cookie&gt;.+)<\/code><\/p>\n\n <p>The operator would emit a Map containing:<br>\n  <table>\n  <tr><th>KEY<\/th><th>VAL<\/th><\/tr>\n  <tr><td>id<\/td><td>12345<\/td><\/tr>\n  <tr><td>username<\/td><td>foo bar<\/td><\/tr>\n  <tr><td>action<\/td><td>baz<\/td><\/tr>\n  <tr><td>cookie<\/td><td>goober<\/td><\/tr>\n  <\/table>\n\n <p>In the case where the regex does not match the input, nothing is emitted.<\/p>\n\n <p>Uses the named-regexp library originally from Google, but now maintained\n by Anthony Trinh (https:\/\/github.com\/tony19\/named-regexp).<\/p>\n\n This is a passthrough operator<br>\n <br>\n <b>StateFull : No <\/b><br>\n <b>Partitions : Yes<\/b>, No dependency among input values. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects String<br>\n <b>output<\/b>: emits Map<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>regex<\/b>: defines the regex <br>","displayName":"Regex match map operator"},{"name":"com.datatorrent.lib.math.Average","properties":[{"name":"VType","canGet":false,"canSet":true,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"},{"name":"average","canGet":true,"canSet":false,"type":"java.lang.Number"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Number","description":"Input port"}],"outputPorts":[{"name":"average","optional":true,"error":false,"tupleType":"class java.lang.Number","description":"Output port"}],"shortDesc":"Emits the average of values at the end of window","longDesc":" <p>\n This is an end window operator. This can not be partitioned. Partitioning\n this will yield incorrect result.<br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects V extends Number<br>\n <b>average<\/b>: emits V extends Number<br>\n <br>\n <br>\n <b>Properties<\/b>: None<br>\n <b>Specific compile time checks<\/b>: None<br>\n <b>Specific run time checks<\/b>: None<br>\n <p>","displayName":"Average"},{"name":"com.datatorrent.lib.math.AverageKeyVal","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, ? extends java.lang.Number>","description":"Data input port."}],"outputPorts":[{"name":"doubleAverage","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Double>","description":"Double average output port."},{"name":"intAverage","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>","description":"Integer average output port."},{"name":"longAverage","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Long>","description":"Long average output port."}],"shortDesc":"Emits the average of values for each key at the end of window","longDesc":" <br>User can block or only enable certain keys by setting filter-keys\/inverse operator properties.\n <br> Block Key : inverse=true\n <br> Enable Key : inverse=false\n <p>\n This is an end window operator. This can not be partitioned. Partitioning\n this will yield incorrect result.<br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>averagePort(s)<\/b>: emits KeyValPair&lt;K,V extends Number&gt;<\/b><br>\n <br>Output ports are optional.\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple (default : true).<br>\n <b>filterBy<\/b>: List of keys to filter on.<br>\n <br>\n <b>Specific compile time checks<\/b>: None<br>\n <b>Specific run time checks<\/b>: None<br>\n <p>","displayName":"Average key val"},{"name":"com.datatorrent.lib.math.AverageMap","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>","description":"Data input port."}],"outputPorts":[{"name":"average","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>","description":"Average output port."}],"shortDesc":"Emits the average value for each key at the end of window","longDesc":" <p>\n This is an end window operator. This can not be partitioned. Partitioning\n this will yield incorrect result.<br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects HashMap&lt;K,V extends Number&gt;<br>\n <b>average<\/b>: emits HashMap&lt;K,V extends Number&gt;<\/b><br>\n <br>\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy<\/b>: List of keys to filter on<br>\n <br>\n <b>Specific compile time checks<\/b>: None<br>\n <b>Specific run time checks<\/b>: None<br>\n <p>\n <br>","displayName":"Average map"},{"name":"com.datatorrent.lib.math.Change","properties":[{"name":"VType","canGet":false,"canSet":true,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"}],"inputPorts":[{"name":"base","optional":false,"tupleType":"class java.lang.Number"},{"name":"data","optional":false,"tupleType":"class java.lang.Number"}],"outputPorts":[{"name":"change","optional":true,"error":false,"tupleType":"class java.lang.Number","description":"Change in value compared to base value."},{"name":"percent","optional":true,"error":false,"tupleType":"class java.lang.Double","description":"Percent change in data value compared to base value."}],"shortDesc":"<p>\n Operator expects values arriving on data input port and base value input operator","longDesc":" Arriving base value is stored in operator for comparison, old base value is overwritten.\n Data values arriving input port are compared with base value. <br>\n Change in value and percentage change in values are emitted on separate ports.<br>\n This operator can not be partitioned, since copies won't get consecutive operators. <br>\n This is StateFull operator, tuples that arrive on base port are kept in\n cache forever.<br>\n <br>\n <b>Input Ports<\/b>:<br>\n <b>data<\/b>: expects V extends Number, Data values<br>\n <b>base<\/b>: expects V extends Number, Base Value stored for comparison<br>\n\n <b>Output Ports<\/b>:<br>\n <b>change<\/b>: emits V extends Number,  Diff from base value<br>\n <b>percent<\/b>: emits Doubl, percent change in value compared to base value.<br>\n <br>\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy<\/b>: List of keys to filter on<br>\n <br>\n <b>Specific compile time checks<\/b>: None<br>\n <b>Specific run time checks<\/b>: None<br>\n <br>\n\n <br>","displayName":"Change"},{"name":"com.datatorrent.lib.math.ChangeAlert","properties":[{"name":"VType","canGet":false,"canSet":true,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"percentThreshold","canGet":true,"canSet":true,"description":"threshold value","type":"double"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Number","description":"Input port."}],"outputPorts":[{"name":"alert","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<V, java.lang.Double>","description":"Output port."}],"shortDesc":"<p>\n Operator compare consecutive input data values and exits value and percent change value\n pair on alert output port, if percent change exceeds certain thresh hold value","longDesc":"<br>\n Operator is StateFull since current value is stored for comparison in next window. <br>\n This operator can not be partitioned, partitioning will result in inconsitent base value\n across replicated copies.\n <br>\n\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>alert<\/b>: emits KeyValPair&lt;K,KeyValPair&lt;V,Double&gt;&gt;(1)<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>threshold<\/b>: The threshold of change between consecutive tuples of the\n same key that triggers an alert tuple<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy<\/b>: List of keys to filter on<br>\n <br>\n <b>Specific compile time checks<\/b>: None<br>\n <b>Specific run time checks<\/b>: None<br>\n <br>","displayName":"Change alert"},{"name":"com.datatorrent.lib.math.ChangeAlertKeyVal","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"percentThreshold","canGet":true,"canSet":true,"description":"threshold value","type":"double"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>","description":"Input port, key\/value pair."}],"outputPorts":[{"name":"alert","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, com.datatorrent.lib.util.KeyValPair<V, java.lang.Double>>","description":"Key\/Percent Change output port."}],"shortDesc":"<p>\n Operator compare consecutive values arriving at input port mapped by keys,\n this emits key\/percent change pair on output alert port if percent change\n exceeds percentage thresh hold set in operator","longDesc":"<br>\n\n StateFull : Yes, current key\/value is stored in operator for comparison in\n next successive windows. <br>\n Partition(s): No, base comparison value will be inconsistent across\n instantiated copies. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>alert<\/b>: emits KeyValPair&lt;K,KeyValPair&lt;V,Double&gt;&gt;(1)<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>threshold<\/b>: The threshold of change between consecutive tuples of the\n same key that triggers an alert tuple<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy<\/b>: List of keys to filter on<br>","displayName":"Change alert key val"},{"name":"com.datatorrent.lib.math.ChangeAlertMap","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"percentThreshold","canGet":true,"canSet":true,"description":"threshold value","type":"double"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>"}],"outputPorts":[{"name":"alert","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.util.HashMap<V, java.lang.Double>>"}],"shortDesc":"<p>\n Operator stores key\/value pair in hash map across the windows for comparison.<br>\n Operator emits hashmap of key\/percent change in value for each key, if percent change\n exceeds preset thresh hold","longDesc":"<br> <br>\n\n StateFull : Yes, key\/value pair in current window are stored for comparison in next window. <br>\n Partition : No, will yield wrong result, base value won't be consistent across instances. <br>\n\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>alert<\/b>: emits HashMap&lt;K,HashMap&lt;V,Double&gt;&gt;(1)<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>threshold<\/b>: The threshold of change between consecutive tuples of the same key that triggers an alert tuple<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy<\/b>: List of keys to filter on<br>","displayName":"Change alert map"},{"name":"com.datatorrent.lib.math.ChangeKeyVal","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[{"name":"base","optional":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>","description":"Base value port, stored in base map for comparison."},{"name":"data","optional":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>","description":"Data tuples input port."}],"outputPorts":[{"name":"change","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>","description":"Key\/Change output port."},{"name":"percent","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Double>","description":"key\/percent change pair output port."}],"shortDesc":"<p\/>\n <br>Operator takes input from two ports - data and base","longDesc":"It stores kay\/value pairs arriving at base\n port in <code>basemap<\/code> across the windows.<\/br>\n <br>The key\/value pairs that arrive at data port are compared with base value if the key exists in the <code>basemap<\/code>.<\/br>\n <br>Change value\/percent are emitted on separate ports.<\/br>\n <p\/>\n StateFull : Yes, base map values are stored across windows. <br>\n Partitions : Yes, values on the base port are replicated across all partitions. However the order of tuples on the\n output stream may change.\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>base<\/b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>change<\/b>: emits KeyValPair&lt;K,V&gt;(1)<br>\n <b>percent<\/b>: emits KeyValPair&lt;K,Double&gt;(1)<br>\n <br>\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy<\/b>: List of keys to filter on<br>","displayName":"Change key val"},{"name":"com.datatorrent.lib.math.ChangeMap","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[{"name":"base","optional":false,"tupleType":"java.util.Map<K, V>","description":"Base key\/value map input port, for comparison."},{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>","description":"Data key\/value map input port."}],"outputPorts":[{"name":"change","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>","description":"Output port emits map for key\/change."},{"name":"percent","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Double>","description":"Output port emits map for key\/percent change."}],"shortDesc":"<p\/>\n Operator takes input from two ports","longDesc":"Operator stores input arriving base port\n for comparison across the windows. kay\/value map arriving are compared with\n base map, on per key base. For all existing keys map of key\/change and\n key\/percent change values are emitted on separate ports. <br>\n <p\/>\n <br>\n StateFull : Yes, base values are stored across windows for comparison. <br>\n Partitions : Yes, values on the base port are replicated across all partitions. The order of tuples from output port may\n change.\n <br>\n <p\/>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>base<\/b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>change<\/b>: emits HashMap&lt;K,V&gt;(1)<br>\n <b>percent<\/b>: emits HashMap&lt;K,Double&gt;(1)<br>\n <br>\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy<\/b>: List of keys to filter on<br>\n <br>","displayName":"Change map"},{"name":"com.datatorrent.lib.math.CompareExceptMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>"}],"outputPorts":[{"name":"compare","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>"},{"name":"expect","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>"},{"name":"match","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>"}],"shortDesc":"A compare opertion is done based on the property \"key\", \"value\", and \"compare\"","longDesc":"If the tuple\n passed the test, it is emitted on the output port \"compare\". If the tuple fails it is emitted on port \"except\". The comparison is done by getting double\n value from the Number. Both output ports are optional, but at least one has to be connected<p>\n  * This module is a pass through<br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V&gt;<br>\n <b>compare<\/b>: emits HashMap&lt;K,V&gt;<br>\n <b>except<\/b>: emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n Compile time checks<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <b>Specific run time checks<\/b>:<br>\n Does the incoming HashMap have the key<br>\n Is the value of the key a number<br>\n <p>\n <b>Benchmarks<\/b>: Blast as many tuples as possible in inline mode<br>\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Benchmark table for CompareExceptMap&lt;K,V extends Number&gt; operator template\">\n <tr><th>In-Bound<\/th><th>Out-bound<\/th><th>Comments<\/th><\/tr>\n <tr><td><b>5 Million K,V pairs\/s<\/b><\/td><td>Each tuple is emitted if emitError is set to true<\/td><td>In-bound rate determines performance as every tuple is emitted.\n Immutable tuples were used in the benchmarking. If you use mutable tuples and have lots of keys, the benchmarks may be lower<\/td><\/tr>\n <\/table><br>\n <p>\n <b>Function Table (K=String, V=Integer); emitError=true; key=a; value=3; cmp=eq)<\/b>:\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Function table for CompareExceptMap&lt;K,V extends Number&gt; operator template\">\n <tr><th rowspan=2>Tuple Type (api)<\/th><th>In-bound (process)<\/th><th colspan=2>Out-bound (emit)<\/th><\/tr>\n <tr><th><i>data<\/i>(HashMap&lt;K,V&gt;)<\/th><th><i>compare<\/i>(HashMap&lt;K,V&gt;)<\/th><th><i>except<\/i>(HashMap&lt;K,V&gt;)<\/th><\/tr>\n <tr><td>Begin Window (beginWindow())<\/td><td>N\/A<\/td><td>N\/A<\/td><td>N\/A<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{a=2,b=20,c=1000}<\/td><td><\/td><td>{a=2,b=20,c=1000}<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{a=3,b=40,c=2}<\/td><td>{a=3,b=40,c=2}<\/td><td><\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{a=10,b=5}<\/td><td><\/td><td>{a=10,b=5}<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{d=55,b=12}<\/td><td><\/td><td>{d=55,b=12}<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{d=22,a=4}<\/td><td><\/td><td>{d=22,a=4}<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{d=4,a=3,g=5,h=44}<\/td><td>{d=4,a=3,g=5,h=44}<\/td><td><\/td><\/tr>\n <tr><td>End Window (endWindow())<\/td><td>N\/A<\/td><td>N\/A<\/td><td>N\/A<\/td><\/tr>\n <\/table>\n <br>\n <br>","displayName":"Compare except map"},{"name":"com.datatorrent.lib.math.CompareExceptStringMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"emitError","canGet":true,"canSet":true,"description":"emitError","type":"boolean"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, java.lang.String>"}],"outputPorts":[{"name":"compare","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.String>"},{"name":"except","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.String>"},{"name":"match","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.String>"}],"shortDesc":"A compare metric is done on String tuple based on the property \"key\", \"value\", and \"cmp\" both matching and non matching tuples on emitted on respective ports","longDesc":"If the tuple\n passed the test, it is emitted on the output port \"compare\". If the tuple fails it is emitted on port \"except\". The comparison is done parsing a double\n value from the String. Both output ports are optional, but at least one has to be connected<p>\n  * This module is a pass through<br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,String&gt;<br>\n <b>compare<\/b>: emits HashMap&lt;K,String&gt;<br>\n <b>except<\/b>: emits HashMap&lt;K,String&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <b>Specific run time checks<\/b>:<br>\n Does the incoming HashMap have the key<br>\n Is the value of the key a number<br>\n <br>","displayName":"Compare except string map"},{"name":"com.datatorrent.lib.math.CompareMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>"}],"outputPorts":[{"name":"compare","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>"},{"name":"match","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>"}],"shortDesc":"A compare metric is done on tuple subclassed from Number based on the property \"key\", \"value\", and \"cmp\", and matching tuples are emitted","longDesc":"If the tuple\n passed the test, it is emitted on the output port \"compare\". The comparison is done by getting double value from the Number.\n Both output ports are optional, but at least one has to be connected<p>\n This module is a pass through<br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>compare<\/b>: emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n CompareMap string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n <b>Specific run time checks<\/b>:<br>\n Does the incoming HashMap have the key<br>\n Is the value of the key a number<br>\n <p>\n <b>Benchmarks<\/b>: Blast as many tuples as possible in inline mode<br>\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Benchmark table for CompareMap&lt;K,V extends Number&gt; operator template\">\n <tr><th>In-Bound<\/th><th>Out-bound<\/th><th>Comments<\/th><\/tr>\n <tr><td><b>8 Million K,V pairs\/s<\/b><\/td><td>Each matched tuple is emitted<\/td><td>In-bound rate and number of tuples that match determine performance.\n Immutable tuples were used in the benchmarking. If you use mutable tuples and have lots of keys, the benchmarks may be lower<\/td><\/tr>\n <\/table><br>\n <p>\n <b>Function Table (K=String,V=Integer); emitError=true; key=a; value=3; cmp=eq)<\/b>:\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Function table for CompareMap&lt;K,V extends Number&gt; operator template\">\n <tr><th rowspan=2>Tuple Type (api)<\/th><th>In-bound (process)<\/th><th>Out-bound (emit)<\/th><\/tr>\n <tr><th><i>data<\/i>(Map&lt;K,V&gt;)<\/th><th><i>compare<\/i>(HashMap&lt;K,V&gt;)<\/th><\/tr>\n <tr><td>Begin Window (beginWindow())<\/td><td>N\/A<\/td><td>N\/A<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{a=2,b=20,c=1000}<\/td><td><\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{a=3,b=40,c=2}<\/td><td>{a=3,b=40,c=2}<\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{a=10,b=5}<\/td><td><\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{d=55,b=12}<\/td><td><\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{d=22,a=4}<\/td><td><\/td><\/tr>\n <tr><td>Data (process())<\/td><td>{d=4,a=3,g=5,h=44}<\/td><td>{d=4,a=3,g=5,h=44}<\/td><\/tr>\n <tr><td>End Window (endWindow())<\/td><td>N\/A<\/td><td>N\/A<\/td><\/tr>\n <\/table>\n <br>\n <br>","displayName":"Compare map"},{"name":"com.datatorrent.lib.math.CompareStringMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"emitError","canGet":true,"canSet":true,"description":"emitError","type":"boolean"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, java.lang.String>"}],"outputPorts":[{"name":"compare","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.String>"},{"name":"match","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.String>"}],"shortDesc":"A compare metric is done on String tuples based on the property \"key\", \"value\", and \"cmp\" and all matching tuples are emitted","longDesc":"If the tuple\n passed the test, it is emitted on the output port \"compare\". The comparison is done by parsing double value from the String.<p>\n This module is a pass through<br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,String&gt;<br>\n <b>compare<\/b>: emits HashMap&lt;K,String&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n <b>Specific run time checks<\/b>:<br>\n Does the incoming HashMap have the key<br>\n Is the value of the key a number<br>\n <br>","displayName":"Compare string map"},{"name":"com.datatorrent.lib.math.CountKeyVal","properties":[{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>","description":"Input port to receive data."}],"outputPorts":[{"name":"count","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>","description":"Key\/occurrence value pair output port."}],"shortDesc":"<p>\n Operator aggregates occurrence of keys in key\/value pair at input port","longDesc":"<br>\n Key\/Occurrence count value pair is emitted for each input on output port. <br>\n <br>\n StateFull : Yes, key occurrence is aggregated over windows. <br>\n Partitions : Yes, count occurrence unifier at output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects KeyValPair&lt;K,V&gt;<br>\n <b>count<\/b>: emits KeyValPair&lt;K,Integer&gt;<\/b><br>\n <br>","displayName":"Count key val"},{"name":"com.datatorrent.lib.math.CountMap","properties":[{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>","description":"Input port to receive data."}],"outputPorts":[{"name":"count","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Integer>"}],"shortDesc":"Operator aggregates key\/occurrence count in map from key\/value map input\n port","longDesc":"<br>\n Emits the count of occurrences of each key at the end of window. <br>\n <br>\n StateFull : Yes, each key occurrence are counted till end windows is seen. <br>\n Partitions : Yes, hash sum unifier on output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>count<\/b>: emits HashMap&lt;K,Integer&gt;<br>\n <br>\n <b>Properties<\/b>: <br>\n  counts : Key occurrence aggregate map.\n <br>","displayName":"Count map"},{"name":"com.datatorrent.lib.math.Division","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"denominator","optional":false,"tupleType":"class java.lang.Number","description":"Denominator input port."},{"name":"numerator","optional":false,"tupleType":"class java.lang.Number","description":"Numerator input port."}],"outputPorts":[{"name":"doubleQuotient","optional":true,"error":false,"tupleType":"class java.lang.Double"},{"name":"doubleRemainder","optional":true,"error":false,"tupleType":"class java.lang.Double"},{"name":"errorData","optional":true,"error":true,"tupleType":"class java.lang.String"},{"name":"floatQuotient","optional":true,"error":false,"tupleType":"class java.lang.Float"},{"name":"floatRemainder","optional":true,"error":false,"tupleType":"class java.lang.Float"},{"name":"integerQuotient","optional":true,"error":false,"tupleType":"class java.lang.Integer"},{"name":"integerRemainder","optional":true,"error":false,"tupleType":"class java.lang.Integer"},{"name":"longQuotient","optional":true,"error":false,"tupleType":"class java.lang.Long"},{"name":"longRemainder","optional":true,"error":false,"tupleType":"class java.lang.Long"}],"shortDesc":"A division metric is done on consecutive tuples on ports numerator and denominator","longDesc":"The operator is idempotent as the division is done\n in order, i.e. the first number on denominator port would divide the first number on the numerator port.<p>\n This is a pass through operator<br>\n <br>\n StateFull : No, quotient is calculated in current window.\n Partitions : Yes, since each denominator and numerator are treated indiviually.\n <p>\n <b>Ports<\/b>:<br>\n <b>numerator<\/b>: expects Number<br>\n <b>denominator<\/b>: expects Number<br>\n <b>longQuotient<\/b>: emits Long<br>\n <b>integerQuotient<\/b>: emits Integer<br>\n <b>doubleQuotient<\/b>: emits Double<br>\n <b>floatQuotient<\/b>: emits Float<br>\n <b>longRemainder<\/b>: emits Long<br>\n <b>integerRemainder<\/b>: emits Integer<br>\n <b>doubleRemainder<\/b>: emits Double<br>\n <b>floatRemainder<\/b>: emits Float<br>\n <b>errordata<\/b>: emits String<br>\n <br>","displayName":"Division"},{"name":"com.datatorrent.lib.math.ExceptMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>"}],"outputPorts":[{"name":"except","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>"},{"name":"match","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>"}],"shortDesc":"<p>\n A compare metric is done on tuple sub-classed from Number based on the\n property \"key\", \"value\", and \"cmp\", and not matched tuples are emitted","longDesc":"The\n comparison is done by getting double value from the Number. Both output ports\n are optional, but at least one has to be connected\n <p>\n This module is a pass through<br>\n <br>\n <br>\n StateFull : No, output is emitted in current window. <br>\n Partitions : Yes, No state dependency among input tuples. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>except<\/b>: emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\",\n \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Compile time checks<\/b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\",\n \"gte\"<br>\n <br>\n <b>Run time checks<\/b>:<br>\n Does the incoming HashMap have the key, Is the value of the key a number<br>\n <br>","displayName":"Except map"},{"name":"com.datatorrent.lib.math.ExceptStringMap","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"emitError","canGet":true,"canSet":true,"description":"emitError","type":"boolean"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, java.lang.String>"}],"outputPorts":[{"name":"except","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.String>"},{"name":"match","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.String>"}],"shortDesc":"A compare metric is done on tuple sub-classed from Number based on the\n property \"key\", \"value\", and \"cmp\", and not matched tuples are emitted","longDesc":"The\n comparison is done by parsing double value from the String. Both output ports\n are optional, but at least one has to be connected\n <p>\n This module is a pass through<br>\n <br>\n StateFull : No, output is computed during current window. <br>\n Partitions : Yes, no state dependency among input tuples. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,String&gt;<br>\n <b>except<\/b>: emits HashMap&lt;K,String&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>cmp<\/b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\",\n \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Compile time checks<\/b>:<br>\n Key must be non empty (has to be set)<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\",\n \"gte\"<br>\n <br>\n <b>Specific run time checks<\/b>:<br>\n Does the incoming HashMap have the key<br>\n Is the value of the key a number<br>\n <br>","displayName":"Except string map"},{"name":"com.datatorrent.lib.math.LogicalCompareToConstant","properties":[{"name":"constant","canGet":true,"canSet":true,"type":"java.lang.Comparable"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"java.lang.Comparable<? super T>","description":"Tuple input port."}],"outputPorts":[{"name":"equalTo","optional":true,"error":false,"tupleType":"java.lang.Comparable<? super T>","description":"Equal output port."},{"name":"greaterThan","optional":true,"error":false,"tupleType":"java.lang.Comparable<? super T>","description":"Greater than output port."},{"name":"greaterThanOrEqualTo","optional":true,"error":false,"tupleType":"java.lang.Comparable<? super T>"},{"name":"lessThan","optional":true,"error":false,"tupleType":"java.lang.Comparable<? super T>","description":"Less Than output port."},{"name":"lessThanOrEqualTo","optional":true,"error":false,"tupleType":"java.lang.Comparable<? super T>"},{"name":"notEqualTo","optional":true,"error":false,"tupleType":"java.lang.Comparable<? super T>","description":"Not Equal output port."}],"shortDesc":"Compare the constant to the incoming tuple emit it on one or more of the\n output ports accordingly","longDesc":" <p>","displayName":"Logical compare to constant"},{"name":"com.datatorrent.lib.math.Margin","properties":[{"name":"VType","canGet":false,"canSet":true,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"percent","canGet":true,"canSet":true,"description":"percent","type":"boolean"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"}],"inputPorts":[{"name":"denominator","optional":false,"tupleType":"class java.lang.Number","description":"Denominator input port."},{"name":"numerator","optional":false,"tupleType":"class java.lang.Number","description":"Numerator input port."}],"outputPorts":[{"name":"margin","optional":true,"error":false,"tupleType":"class java.lang.Number","description":"Output margin port."}],"shortDesc":"<p>\n Operator sums numerator and denominator value arriving at input ports","longDesc":"<br>\n Margin Formula : (1 - numerator\/denominator). <br>\n If percent flag is set than margin is emitted as percentage. <br>\n <br>\n StateFull : Yes, numerator and denominator are summed for application\n windows. <br>\n Partitions : No, will yield worng margin result, no unifier on output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>numerator<\/b>: expects V extends Number<br>\n <b>denominator<\/b>: expects V extends Number<br>\n <b>margin<\/b>: emits Double<br>\n <br>\n <b>Properties:<b>\n <br>\n <b>percent: <\/b>  output margin as percentage value.","displayName":"Margin"},{"name":"com.datatorrent.lib.math.MarginKeyVal","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"percent","canGet":true,"canSet":true,"description":"percent","type":"boolean"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[{"name":"denominator","optional":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>"},{"name":"numerator","optional":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>"}],"outputPorts":[{"name":"margin","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>"}],"shortDesc":"Adds all values for each key in \"numerator\" and \"denominator\", and at the end\n of window emits the margin for each key (1 - numerator\/denominator)","longDesc":" <p>\n <br>\n The values are added for each key within the window and for each stream.<br>\n <br>\n <b>Ports<\/b>:<br>\n <b>numerator<\/b>: expects KeyValPair&lt;K,V&gt;<br>\n <b>denominator<\/b>: expects KeyValPair&lt;K,V&gt;<br>\n <b>margin<\/b>: emits HashMap&lt;K,Double&gt;, one entry per key per window<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy<\/b>: List of keys to filter on<br>\n <br>","displayName":"Margin key val"},{"name":"com.datatorrent.lib.math.MarginMap","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"percent","canGet":true,"canSet":true,"description":"percent","type":"boolean"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[{"name":"denominator","optional":false,"tupleType":"java.util.Map<K, V>"},{"name":"numerator","optional":false,"tupleType":"java.util.Map<K, V>"}],"outputPorts":[{"name":"margin","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>"}],"shortDesc":"Adds all values for each key in \"numerator\" and \"denominator\", and at the end of window emits the margin for each key\n (1 - numerator\/denominator)","longDesc":"<p>\n <br>The values are added for each key within the window and for each stream.<br>\n <br>\n <b>Ports<\/b>:<br>\n <b>numerator<\/b>: expects Map&lt;K,V&gt;<br>\n <b>denominator<\/b>: expects Map&lt;K,V&gt;<br>\n <b>margin<\/b>: emits HashMap&lt;K,Double&gt;, one entry per key per window<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy<\/b>: List of keys to filter on<br>\n <br>","displayName":"Margin map"},{"name":"com.datatorrent.lib.math.Max","properties":[{"name":"VType","canGet":false,"canSet":true,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Number"}],"outputPorts":[{"name":"max","optional":true,"error":false,"tupleType":"class java.lang.Number","description":"Max value output port."}],"shortDesc":"<p>\n Emits at end of window maximum of all values sub-classed from Number in the incoming stream","longDesc":"<br>\n <br>\n <b>StateFull :<\/b> Yes, max value is determined during application window, can be more than 1. <br>\n <b>Partitions : <\/b>Yes, operator itself is used as unifier at output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects V extends Number<br>\n <b>max<\/b>: emits V extends Number<br>\n <br>","displayName":"Max"},{"name":"com.datatorrent.lib.math.MaxKeyVal","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>","description":"Input port."}],"outputPorts":[{"name":"max","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>","description":"Max value output port."}],"shortDesc":"Emits at end of window maximum of all values sub-classed from Number for each key in KeyValPair","longDesc":"<p>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>max<\/b>: emits KeyValPair&lt;K,V extends Number&gt;, one entry per key<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy<\/b>: List of keys to filter on<br>\n <br>","displayName":"Max key val"},{"name":"com.datatorrent.lib.math.MaxMap","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.HashMap<K, V>"}],"outputPorts":[{"name":"max","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>"}],"shortDesc":"Emits at end of window maximum of all values sub-classed from Number for each key in HashMap","longDesc":"<p>\n Emits tuple in end of window. Partition is round robin<br>\n <br>\n  <b>StateFull : <\/b>Yes, key\/value max is determined over application window, can be > 1. <br>\n  <b>Partitions : <\/b>Yes, operator is max unifier operator on output port.\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects HashMap&lt;K,V extends Number&gt;<br>\n <b>max<\/b>: emits HashMap&lt;K,V extends Number&gt;, one entry per key<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy<\/b>: List of keys to filter on<br>\n <br>","displayName":"Max map"},{"name":"com.datatorrent.lib.math.Min","properties":[{"name":"VType","canGet":false,"canSet":true,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Number","description":"Input port."}],"outputPorts":[{"name":"min","optional":true,"error":false,"tupleType":"class java.lang.Number","description":"Min output port."}],"shortDesc":"Emits at end of window minimum of all values sub-classed from Number in the incoming stream","longDesc":"<br>\n <br>\n <b>StateFull :<\/b>Yes, min value is computed over application windows. <br>\n <b>Partitions :<\/b>Yes, operator is kin unifier operator. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects V extends Number<br>\n <b>min<\/b>: emits V extends Number<br>\n <br>\n <br>","displayName":"Min"},{"name":"com.datatorrent.lib.math.MinKeyVal","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>","description":"Input key\/value port."}],"outputPorts":[{"name":"min","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>","description":"Min value output port."}],"shortDesc":"Emits at end of window minimum of all values sub-classed from Number for each key in KeyValPair","longDesc":"<p>\n <br>\n\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>min<\/b>: emits KeyValPair&lt;K,V extends Number&gt;, one entry per key<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy<\/b>: List of keys to filter on<br>\n <br>","displayName":"Min key val"},{"name":"com.datatorrent.lib.math.MinMap","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.HashMap<K, V>","description":"Input data port."}],"outputPorts":[{"name":"min","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>","description":"Min value output port"}],"shortDesc":"Emits at end of window minimum of all values sub-classed from Number for each key","longDesc":"<br>\n <br>\n <b>StateFull :<\/b> Yes, min value is computed over application window. <br>\n <b>Partitions :<\/b> Yes, min operator is min unifier for output port.\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects HashMap&lt;K,V extends Number&gt;<br>\n <b>min<\/b>: emits HashMap&lt;K,V extends Number&gt;, one entry per key<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy<\/b>: List of keys to filter on<br>\n <br>","displayName":"Min map"},{"name":"com.datatorrent.lib.math.MultiplyByConstant","properties":[{"name":"multiplier","canGet":true,"canSet":true,"type":"java.lang.Number"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"class java.lang.Number","description":"Input number port."}],"outputPorts":[{"name":"doubleProduct","optional":true,"error":false,"tupleType":"class java.lang.Double","description":"Double output port."},{"name":"floatProduct","optional":true,"error":false,"tupleType":"class java.lang.Float","description":"Float output port."},{"name":"integerProduct","optional":true,"error":false,"tupleType":"class java.lang.Integer","description":"Integer output port."},{"name":"longProduct","optional":true,"error":false,"tupleType":"class java.lang.Long","description":"Long output port."}],"shortDesc":"Multiplies input tuple (Number) by the value of property \\\"multiplier\\\"","longDesc":" Emits the result as Long on port \\\"longProduct\\\", as Integer on port \\\"integerProduct\\\",\n as Double on port \\\"doubleProduct\\\", and as Float on port \\\"floatProduct\\\". This is a pass through operator<p>\n <br>\n <b>StateFull : No <\/b>, output is computed in current window. <br>\n <b>Partitions : Yes <\/b>, No state dependency among input tuples. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>input<\/b>: expects Number<br>\n <b>longProduct<\/b>: emits Long<br>\n <b>integerProduct<\/b>: emits Integer<br>\n <b>doubleProduct<\/b>: emits Double<br>\n <b>floatProduct<\/b>: emits Float<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>multiplier<\/b>: Number to multiply input tuple with<br>\n <br>","displayName":"Multiply by constant"},{"name":"com.datatorrent.lib.math.Quotient","properties":[{"name":"VType","canGet":false,"canSet":true,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"},{"name":"mult_by","canGet":false,"canSet":true,"type":"int"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"}],"inputPorts":[{"name":"denominator","optional":false,"tupleType":"class java.lang.Number","description":"Denominator values port."},{"name":"numerator","optional":false,"tupleType":"class java.lang.Number","description":"Numerator values port."}],"outputPorts":[{"name":"quotient","optional":true,"error":false,"tupleType":"class java.lang.Number","description":"Quotient output port."}],"shortDesc":"<p>\n Adds all the values on \"numerator\" and \"denominator\" and emits quotient at\n end of window","longDesc":"<br>\n Application can set multiply by value for quotient. <br>\n <br>\n <b>StateFull : Yes <\/b>, Values are sumed over application window. <br>\n <b>Partitions : No <\/b>, will yield wrong results, since values are\n accumulated over application window. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>numerator<\/b>: expects V extends Number<br>\n <b>denominator<\/b>: expects V extends Number<br>\n <b>quotient<\/b>: emits Double<br>\n <br>\n <b>Properties : <\/b> <br>\n <b>mult_by : <\/b>Multiply by value(default = 1). <br>\n <br>","displayName":"Quotient"},{"name":"com.datatorrent.lib.math.QuotientMap","properties":[{"name":"countkey","canGet":true,"canSet":true,"description":"countkey","type":"boolean"},{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"mult_by","canGet":true,"canSet":true,"description":"mult_by","type":"int"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[{"name":"denominator","optional":false,"tupleType":"java.util.Map<K, V>","description":"Denominator input port."},{"name":"numerator","optional":false,"tupleType":"java.util.Map<K, V>","description":"Numerator input port."}],"outputPorts":[{"name":"quotient","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Double>","description":"Quotient input port."}],"shortDesc":"<p>\n Add all the values for each key on \"numerator\" and \"denominator\" and emits\n quotient at end of window for all keys in the denominator","longDesc":"<br>\n Application can set multiplication value for quotient(default = 1). <br>\n Operator will calculate quotient of occurrence of key in numerator divided by\n occurrence of key in denominator if countKey flag is true. <br>\n Application can allow or block keys by setting filter key and inverse flag. <br>\n <br>\n <b>StateFull : Yes<\/b>, numerator\/denominator values are summed over\n application window. <br>\n <b>Partitions : No, <\/b>, will yield wrong results, since values are summed\n over app window. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>numerator<\/b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>denominator<\/b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>quotient<\/b>: emits HashMap&lt;K,Double&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse :<\/b> if set to true the key in the filter will block tuple<br>\n <b>filterBy :<\/b> List of keys to filter on<br>\n <b>countkey :<\/b> Get quotient of occurrence of keys in numerator and\n denominator. <br>\n <b>mult_by :<\/b> Set multiply by constant value. <br>\n <br>","displayName":"Quotient map"},{"name":"com.datatorrent.lib.math.Range","properties":[{"name":"VType","canGet":false,"canSet":true,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Number","description":"Input data port."}],"outputPorts":[{"name":"range","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.HighLow<V>","description":"Output range port, with high low unifier operator."}],"shortDesc":"<p>\n Emits the range of values at the end of window<br>\n <br>\n <b>StateFull : Yes<\/b>, values are computed over application time window","longDesc":"<br>\n <b>Partitions : Yes <\/b>, High\/Low values are unified on output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects V extends Number<br>\n <b>range<\/b>: emits HighLow&lt;V&gt;<br>\n <br>\n <br>","displayName":"Range"},{"name":"com.datatorrent.lib.math.RangeKeyVal","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>","description":"Input port."}],"outputPorts":[{"name":"range","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, com.datatorrent.lib.util.HighLow<V>>","description":"Output port to send out the high low range."}],"shortDesc":"<p>\n Emits the range for each key at the end of window","longDesc":"<br>\n <br>\n <b>StateFull : Yes<\/b>, values are computed over application window. <br>\n <b>Partitions : Yes, <\/b> high\/low values are each key is unified at output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>range<\/b>: emits KeyValPair&lt;K,HighLow&lt;V&gt;&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy<\/b>: List of keys to filter on<br>\n <br>","displayName":"Range key val"},{"name":"com.datatorrent.lib.math.RangeMap","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>","description":"Input key\/value map port."}],"outputPorts":[{"name":"range","optional":true,"error":false,"tupleType":"java.util.HashMap<K, com.datatorrent.lib.util.HighLow<V>>","description":"Output range port."}],"shortDesc":"<p>\n Emits the range for each key at the end of window","longDesc":"<br>\n Application can allow or block keys by setting filter keys and inverse flag. <br>\n <br>\n <b>StateFull : Yes<\/b>, values are computed over application window. <br>\n <b>Partitions : Yes<\/b>, values are unified at output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>range<\/b>: emits HashMap&lt;K,HighLow&lt;V&gt;&gt; each key has two entries; .get(0) gives Max, .get(1) gives Min<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy<\/b>: List of keys to filter on<br>\n <br>","displayName":"Range map"},{"name":"com.datatorrent.lib.math.RunningAverage","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"class java.lang.Number","description":"Input number port."}],"outputPorts":[{"name":"doubleAverage","optional":true,"error":false,"tupleType":"class java.lang.Double","description":"Double average output port."},{"name":"floatAverage","optional":true,"error":false,"tupleType":"class java.lang.Float","description":"Float average output port."},{"name":"integerAverage","optional":true,"error":false,"tupleType":"class java.lang.Integer","description":"Integer average output port."},{"name":"longAverage","optional":true,"error":false,"tupleType":"class java.lang.Long","description":"Long average output port."}],"shortDesc":"Calculate the running average of the input numbers and emit it at the end of\n the window","longDesc":"This is an end of window operator<br>\n <br>\n <b>StateFull : Yes<\/b>, average is computed over application window. <br>\n <b>Partitions : No<\/b>, will yield wrong results. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>input<\/b>: expects Number<br>\n <b>longAverage<\/b>: emits Long<br>\n <b>integerAverage<\/b>: emits Integer<br>\n <b>doubleAverage<\/b>: emits Double<br>\n <b>floatAverage<\/b>: emits Float<br>\n <br>","displayName":"Running average"},{"name":"com.datatorrent.lib.math.Sigma","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"java.util.Collection<T>","description":"Input port, accepts collection of values of type 'T'."}],"outputPorts":[{"name":"doubleResult","optional":true,"error":false,"tupleType":"class java.lang.Double","description":"Double type output."},{"name":"floatResult","optional":true,"error":false,"tupleType":"class java.lang.Float","description":"Float type output."},{"name":"integerResult","optional":true,"error":false,"tupleType":"class java.lang.Integer","description":"Integer type output."},{"name":"longResult","optional":true,"error":false,"tupleType":"class java.lang.Long","description":"Long type output."}],"shortDesc":"Adds incoming tuple to the state","longDesc":"This is a stateful operator that never\n flushes its state; i.e. the addition would go on forever. The result of each\n addition is emitted on the four ports, namely \\\"doubleResult\\\",\n \\\"floatResult\\\", \\\"integerResult\\\", \\\"longResult\\\". Input tuple object has to\n be an implementation of the interface Collection&lt;T&gt;. Tuples are emitted\n on the output ports only if they are connected. This is done to avoid the\n cost of calling the functions when some ports are not connected.\n <p>\n This is a stateful pass through operator<br>\n <b>Partitions : <\/b>, no will yield wrong results, no unifier on output port.\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Collection&lt;T extends Number&lt;<br>\n <b>doubleResult<\/b>: emits Double<br>\n <b>floatResult<\/b>: emits Float<br>\n <b>integerResult<\/b>: emits Integer<br>\n <b>longResult<\/b>: emits Long<br>\n <br>","displayName":"Sigma"},{"name":"com.datatorrent.lib.math.SquareCalculus","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"class java.lang.Number"}],"outputPorts":[{"name":"doubleResult","optional":true,"error":false,"tupleType":"class java.lang.Double","description":"Double type output."},{"name":"floatResult","optional":true,"error":false,"tupleType":"class java.lang.Float","description":"Float type output."},{"name":"integerResult","optional":true,"error":false,"tupleType":"class java.lang.Integer","description":"Integer type output."},{"name":"longResult","optional":true,"error":false,"tupleType":"class java.lang.Long","description":"Long type output."}],"shortDesc":"Emits the result of square of the input tuple (Number).<br>\n Emits the result as Long on port longResult, as Integer on port integerResult,\n as Double on port doubleResult, and as Float on port floatResult","longDesc":"This is a pass through operator<p>\n <br>\n <b>Ports<\/b>:<br>\n <b>input<\/b>: expects Number<br>\n <b>longResult<\/b>: emits Long<br>\n <b>integerResult<\/b>: emits Integer<br>\n <b>doubleResult<\/b>: emits Double<br>\n <b>floatResult<\/b>: emits Float<br>\n <br>","displayName":"Square calculus"},{"name":"com.datatorrent.lib.math.Sum","properties":[{"name":"VType","canGet":false,"canSet":true,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"},{"name":"cumulative","canGet":true,"canSet":true,"description":"cumulative flag","type":"boolean"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Number","description":"Input port to receive data."}],"outputPorts":[{"name":"redisport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.Integer, java.lang.Integer>","description":"Redis server output port."},{"name":"sum","optional":true,"error":false,"tupleType":"class java.lang.Number","description":"Output sum port."},{"name":"sumDouble","optional":true,"error":false,"tupleType":"class java.lang.Double","description":"Output double sum port."},{"name":"sumFloat","optional":true,"error":false,"tupleType":"class java.lang.Float","description":"Output float sum port."},{"name":"sumInteger","optional":true,"error":false,"tupleType":"class java.lang.Integer","description":"Output integer sum port."},{"name":"sumLong","optional":true,"error":false,"tupleType":"class java.lang.Long","description":"Output Long sum port."},{"name":"sumShort","optional":true,"error":false,"tupleType":"class java.lang.Short","description":"Output short sum port."}],"shortDesc":"<p>\n Emits the sum of values at the end of window","longDesc":"<br>\n This is an end of window operator. Application can turn this into accumulated\n sum operator by setting cumulative flag to true. <br>\n <b>StateFull : Yes<\/b>, sum is computed over application window >= 1. <br>\n <b>Partitions : Yes<\/b>, sum is unified at output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects V extends Number<br>\n <b>sum<\/b>: emits V extends Number<br>\n <b>sumDouble<\/b>: emits Double<br>\n <b>sumFloat<\/b>: emits Float<br>\n <b>sumInteger<\/b>: emits Integer<br>\n <b>sumLong<\/b>: emits Long<br>\n <b>sumShort<\/b>: emits Short<br>\n <br>\n <b>Properties: <\/b> <br>\n <b>cumulative <\/b> Sum has to be cumulative. <br>\n <br>","displayName":"Sum"},{"name":"com.datatorrent.lib.math.SumCountMap","properties":[{"name":"cumulative","canGet":true,"canSet":true,"description":"cumulative flag","type":"boolean"},{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>","description":"Input port to receive data."}],"outputPorts":[{"name":"count","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Integer>"},{"name":"sum","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>","description":"Key\/sum map output port."},{"name":"sumDouble","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Double>","description":"key\/double sum map output port."},{"name":"sumFloat","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Float>"},{"name":"sumInteger","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Integer>","description":"key\/integer sum output port."},{"name":"sumLong","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Long>"},{"name":"sumShort","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Short>"}],"shortDesc":"<p>\n Emits the sum, and count of values for each key at the end of window","longDesc":" Application accumulate sum across streaming window by setting cumulative flag\n to true. <br>\n This is an end of window operator<br>\n <br>\n <b>StateFull : Yes<\/b>, Sum is computed over application window and streaming\n window. <br>\n <b>Partitions : Yes<\/b>, Sum is unified at output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>sum<\/b>: emits HashMap&lt;K,V&gt;<br>\n <b>count<\/b>: emits HashMap&lt;K,Integer&gt;<\/b><br>\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy<\/b>: List of keys to filter on<br>\n <b>cumulative<\/b>: boolean flag, if set the sum is not cleared at the end of\n window, <br>\n hence generating cumulative sum across streaming windows. Default is false.<br>\n <br>","displayName":"Sum count map"},{"name":"com.datatorrent.lib.math.SumKeyVal","properties":[{"name":"cumulative","canGet":true,"canSet":true,"description":"cumulative flag.","type":"boolean"},{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>","description":"Input port to receive data."}],"outputPorts":[{"name":"sum","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>","description":"Output sum port."},{"name":"sumDouble","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Double>","description":"Output double sum port."},{"name":"sumFloat","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Float>","description":"Output float sum port."},{"name":"sumInteger","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>","description":"Output integer sum port."},{"name":"sumLong","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Long>","description":"Output long sum port."},{"name":"sumShort","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Short>","description":"Output short sum port."}],"shortDesc":"Emits the sum of values for each key at the end of window","longDesc":"<p> This is an end window operator. Default unifier works as this operator follows sticky partition.<br> <br> <b>Ports<\/b>:<br>\n <b>data<\/b>: expects KeyValPair&lt;K,V extends Number&gt;<br> <b>sum<\/b>: emits KeyValPair&lt;K,V extends Number&gt;<br> <br> <b>Properties<\/b>:<br> <b>inverse<\/b>: If set to true the key in the\n filter will block tuple<br> <b>filterBy<\/b>: List of keys to filter on<br>\n <b>cumulative<\/b>: boolean flag, if set the sum is not cleared at the end of window, <br>\n hence generating cumulative sum\n across streaming windows. Default is false.<br>\n <br>","displayName":"Sum key val"},{"name":"com.datatorrent.lib.math.SumMap","properties":[{"name":"cumulative","canGet":true,"canSet":true,"description":"cumulative flag","type":"boolean"},{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.Map<K, V>","description":"Input port to receive data."}],"outputPorts":[{"name":"sum","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>","description":"Sum output port."},{"name":"sumDouble","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Double>","description":"Double sum output port."},{"name":"sumFloat","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Float>","description":"Float sum output port."},{"name":"sumInteger","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Integer>","description":"Integer sum output port."},{"name":"sumLong","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Long>","description":"Long sum output port."},{"name":"sumShort","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Short>","description":"Short sum output port."}],"shortDesc":"<p>\n Emits the sum of values for each key at the end of window","longDesc":" This is an end of window operator<br>\n <br>\n <b>StateFull : Yes<\/b>, sum is computed over application window. <br>\n <b>Partitions : Yes<\/b>, sum is unified at output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>sum<\/b>: emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy<\/b>: List of keys to filter on<br>\n <b>cumulative<\/b>: boolean flag, if set the sum is not cleared at the end of window, <br>\n hence generating cumulative sum across streaming windows. Default is false.<br>\n <br>","displayName":"Sum map"},{"name":"com.datatorrent.lib.math.XmlKeyValueStringCartesianProduct","properties":[{"name":"config","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"delim","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[{"name":"output","optional":true,"error":false,"tupleType":"class java.lang.String"}],"shortDesc":"An implementation of the AbstractXmlKeyValueCartesianProduct operator that takes in the xml document\n as a String input and outputs the cartesian product as Strings.","displayName":"Xml key value string cartesian product"},{"name":"com.datatorrent.lib.multiwindow.MultiWindowRangeKeyVal","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"},{"name":"windowSize","canGet":false,"canSet":true,"type":"int"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>","description":"Input port."}],"outputPorts":[{"name":"range","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, com.datatorrent.lib.util.HighLow<V>>","description":"Output port to send out the high low range."}],"shortDesc":"A range operator of KeyValPair schema which calculate range across multiple streaming windows","longDesc":"<br>\n This is an end window operator which emits only at Nth window. <br>\n <br>\n <b>StateFull : Yes<\/b>, computes across multiple windows. <br>\n <b>Partitions : Yes<\/b>, high\/low are unified on output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>range<\/b>: emits KeyValPair&lt;K,HighLow&lt;V&gt;&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy<\/b>: List of keys to filter on<br>\n <br>\n <b>Specific compile time checks<\/b>: None<br>\n <b>Specific run time checks<\/b>: None<br>\n <b>windowSize i.e. N<\/b>: Number of streaming windows that define application window.<br>\n <br>","displayName":"Multi window range key val"},{"name":"com.datatorrent.lib.multiwindow.MultiWindowSumKeyVal","properties":[{"name":"cumulative","canGet":true,"canSet":true,"description":"cumulative flag.","type":"boolean"},{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"},{"name":"windowSize","canGet":false,"canSet":true,"type":"int"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>","description":"Input port to receive data."}],"outputPorts":[{"name":"sum","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>","description":"Output sum port."},{"name":"sumDouble","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Double>","description":"Output double sum port."},{"name":"sumFloat","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Float>","description":"Output float sum port."},{"name":"sumInteger","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>","description":"Output integer sum port."},{"name":"sumLong","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Long>","description":"Output long sum port."},{"name":"sumShort","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Short>","description":"Output short sum port."}],"shortDesc":"A sum operator of KeyValPair schema which accumulates sum across multiple\n streaming windows","longDesc":" <p>\n This is an end window operator which emits only at Nth window. <br>\n <br>\n <b>StateFull : Yes, <\/b> sum is computed across streaming windows.  <br>\n <b>Partitions : No, <\/b> sum is not unified at output port. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>sum<\/b>: emits KeyValPair&lt;K,V&gt;<br>\n <b>count<\/b>: emits KeyValPair&lt;K,Integer&gt;<\/b><br>\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse<\/b>: If set to true the key in the filter will block tuple.<br>\n <b>filterBy<\/b>: List of keys to filter on.<br>\n <b>windowSize i.e. N<\/b>: Number of streaming windows that define application\n window.<br>\n <br>","displayName":"Multi window sum key val"},{"name":"com.datatorrent.lib.multiwindow.SimpleMovingAverage","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"},{"name":"windowSize","canGet":true,"canSet":true,"description":"windowSize","type":"int"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>","description":"Input port for getting incoming data."}],"outputPorts":[{"name":"doubleSMA","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Double>","description":"Output port to emit simple moving average (SMA) of last N window as Double."},{"name":"floatSMA","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Float>","description":"Output port to emit simple moving average (SMA) of last N window as Float."},{"name":"integerSMA","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>","description":"Output port to emit simple moving average (SMA) of last N window as\n Integer."},{"name":"longSMA","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Long>","description":"Output port to emit simple moving average (SMA) of last N window as Long."}],"shortDesc":"Calculate simple moving average (SMA) of last N window","longDesc":"<br>\n <br>\n <b>StateFull : Yes<\/b>, operator store values  for n-1 th windows. <br>\n <b>Partitions : No<\/b>, sum is not unified on output ports. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: Expects KeyValPair where K is Object and V is Number.<br>\n <b>doubleSMA<\/b>: Emits simple moving average of N window as Double.<br>\n <b>floatSMA<\/b>: Emits simple moving average of N window as Float.<br>\n <b>longSMA<\/b>: Emits simple moving average of N window as Long.<br>\n <b>integerSMA<\/b>: Emits simple moving average of N window as Integer.<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>windowSize<\/b>: Number of windows to keep state on<br>\n <br>","displayName":"Simple moving average"},{"name":"com.datatorrent.lib.multiwindow.SortedMovingWindow","properties":[{"name":"comparator","canGet":false,"canSet":true,"type":"java.util.Comparator","properties":[]},{"name":"function","canGet":false,"canSet":true,"type":"com.google.common.base.Function","properties":[]},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"windowSize","canGet":true,"canSet":false,"description":"n","type":"int"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[{"name":"errorOutput","optional":true,"error":true,"tupleType":"class java.lang.Object"},{"name":"sortedOutput","optional":true,"error":false,"tupleType":"class java.lang.Object"}],"shortDesc":"<p>A sliding window class that sorts all incoming tuples within the window and emit them in the right order<\/p><br>\n <p>Generally, Given tuples T, keys K, windows W","longDesc":"All T within Window W are split into |K| buckets and <br>\n sort the bucket in the order that Tp_Ki < Tq_Ki if (comparator.compare(Tp_Ki, Tq_Ki) < 0 || ((Tp_Ki instance of Comparable) && Tp_Ki.compareTo(Tq_Ki) <0))<\/p>\n\n <b>Properties<\/b>:<br>\n <b>T<\/b> is the tuple object the operator can process <br>\n <b>K<\/b> is the key object used to categorize the tuples withint the sliding window<br>\n <b>function<\/b>: is used transform the tuple T to group key K. It's used to split all tuples into |K| group and sorted them in the group<br>\n by default: function is SingleKeyMappingFunction which map all t to null (all tuples are grouped into one group)\n <br><b>comparator<\/b>: is used to determine the order of the tuple<br>\n by default: comparator is null which means the tuple must be comparable\n <p><\/p>","displayName":"Sorted moving window"},{"name":"com.datatorrent.lib.pigquery.PigCrossOperator","properties":[],"inputPorts":[{"name":"inport1","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input port 1."},{"name":"inport2","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input port 2."}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Output port."}],"shortDesc":"This class implements Apache Pig Cross operator semantic","longDesc":"\n <pre>\n Example\n Suppose we have relations A and B.\n\n A = LOAD 'data1' AS (a1:int,a2:int,a3:int);\n\n DUMP A;\n (1,2,3)\n (4,2,1)\n\n B = LOAD 'data2' AS (b1:int,b2:int);\n\n DUMP B;\n (2,4)\n (8,9)\n (1,3)\n In this example the cross product of relation A and B is computed.\n\n X = CROSS A, B;\n\n DUMP X;\n (1,2,3,2,4)\n (1,2,3,8,9)\n (1,2,3,1,3)\n (4,2,1,2,4)\n (4,2,1,8,9)\n (4,2,1,1,3)\n <\/pre>\n  <br>\n <b>StateFull : <\/b> Yes, tuples are collected over application window. <br>\n <b>Partitions : <\/b> No, will yield wrong result. <br>\n <br>\n This operator is pass thru operator. <br>\n <br>\n <b>Ports : <\/b> <br>\n <b> inport1 : <\/b> expects tuple of form Map&lt;String, Object&gt; <br>\n <b> inport2 : <\/b> expects tuple of form Map&lt;String, Object&gt; <br>\n <b> outport : <\/b> emits tuple of form Map&lt;String, Object&gt; <br>","displayName":"Pig cross operator"},{"name":"com.datatorrent.lib.pigquery.PigDistinctOperator","properties":[],"inputPorts":[{"name":"inport","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input port 1."}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Output port."}],"shortDesc":"Implements pig distinct operator semantic","longDesc":"\n <pre>\n Example\n\n Suppose we have relation A.\n\n A = LOAD 'data' AS (a1:int,a2:int,a3:int);\n\n DUMP A;\n (8,3,4)\n (1,2,3)\n (4,3,3)\n (4,3,3)\n (1,2,3)\n\n In this example all duplicate tuples are removed.\n\n X = DISTINCT A;\n\n DUMP X;\n (1,2,3)\n (4,3,3)\n (8,3,4)\n\n <\/pre>\n\n <b>StateFull : <\/b> Yes, tuples are collected over application window. <br>\n <b>Partitions : <\/b> Yes, operator is also unifier for output port. <br>\n <br>\n This operator is pass thru operator. <br>\n <br>\n <b>Ports : <\/b> <br>\n <b> inport : <\/b> expects tuple of form Map&lt;String, Object&gt; <br>\n <b> outport : <\/b> emits tuple of form Map&lt;String, Object&gt; <br>","displayName":"Pig distinct operator"},{"name":"com.datatorrent.lib.pigquery.PigFilterOperator","properties":[{"name":"condition","canGet":true,"canSet":true,"description":"Condition","type":"com.datatorrent.lib.streamquery.condition.Condition","properties":[]},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"inport","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input port."}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Output port."}],"shortDesc":"Class to implement Apache Pig filter statement semantic","longDesc":"<br>\n Stream rows passing condition are emitted on output port stream. <br>\n <br>\n <b>StateFull : NO,<\/b> all row data is processed in current time window. <br>\n <b>Partitions : Yes, <\/b> No Input dependency among input rows. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b> inport : <\/b> Input hash map(row) port, expects\n HashMap&lt;String,Object&gt;<<br>\n <b> outport : <\/b> Output hash map(row) port, emits\n HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <b> <br>\n <b> condition : <\/b> Select condition for selecting rows. <br>","displayName":"Pig filter operator"},{"name":"com.datatorrent.lib.pigquery.PigForeachOperator","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"inport","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input port 1."}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>"}],"shortDesc":"<p>PigForeachOperator class.<\/p>","displayName":"Pig foreach operator"},{"name":"com.datatorrent.lib.pigquery.PigGroupOperator","properties":[{"name":"groupByCondition","canGet":true,"canSet":true,"description":"GroupByCondition","type":"com.datatorrent.lib.pigquery.condition.PigGroupCondition","properties":[]},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"inport","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input port."}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.Object, java.util.List<java.util.Map<java.lang.String, java.lang.Object>>>","description":"Output port."}],"shortDesc":"Class implements Apache Pig Group operator sematic","longDesc":"<br>\n This operator does not support Group All semantic. <br>\n <pre>\n B = GROUP A BY age;\n\n DESCRIBE B;\n B: {group: int, A: {name: chararray,age: int,gpa: float}}\n\n ILLUSTRATE B;\n etc ...\n ----------------------------------------------------------------------\n | B     | group: int | A: bag({name: chararray,age: int,gpa: float}) |\n ----------------------------------------------------------------------\n |       | 18         | {(John, 18, 4.0), (Joe, 18, 3.8)}             |\n |       | 20         | {(Bill, 20, 3.9)}                             |\n ----------------------------------------------------------------------\n\n DUMP B;\n (18,{(John,18,4.0F),(Joe,18,3.8F)})\n (19,{(Mary,19,3.8F)})\n (20,{(Bill,20,3.9F)})\n <\/pre>\n <b>Ports : <\/b> <br>\n <b> inport : <\/b> expects tuple Map<String, Object> <br>\n <b>outport : <\/b> emits Map<Object, List<Map<String, Object>>> <br>\n\n <b>StateFull : <\/b> Yes, tuples are aggregated over application window. <br>\n <b>Partitions : <\/b> Yes, map unifier on output port. <br>\n\n <b>Properties : <\/b> <br>\n <b>groupByCondition : <\/b> Group condition. <br>\n <br>","displayName":"Pig group operator"},{"name":"com.datatorrent.lib.pigquery.PigJoinOperator","properties":[{"name":"joinCondition","canGet":true,"canSet":true,"description":"Condition","type":"com.datatorrent.lib.streamquery.condition.Condition","properties":[]},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"inport1","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input1 port."},{"name":"inport2","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input2 port."}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Output port."}],"shortDesc":"This class implements Pig Join(Inner) semantic on live stream","longDesc":"\n <pre>\n Example\n Suppose we have relations A and B.\n\n A = LOAD 'data1' AS (a1:int,a2:int,a3:int);\n\n DUMP A;\n (1,2,3)\n (4,2,1)\n (8,3,4)\n (4,3,3)\n (7,2,5)\n (8,4,3)\n\n B = LOAD 'data2' AS (b1:int,b2:int);\n\n DUMP B;\n (2,4)\n (8,9)\n (1,3)\n (2,7)\n (2,9)\n (4,6)\n (4,9)\n In this example relations A and B are joined by their first fields.\n\n X = JOIN A BY a1, B BY b1;\n\n DUMP X;\n (1,2,3,1,3)\n (4,2,1,4,6)\n (4,3,3,4,6)\n (4,2,1,4,9)\n (4,3,3,4,9)\n (8,3,4,8,9)\n (8,4,3,8,9)\n <\/pre>\n <br>\n <b>Ports : <\/b> <br>\n <b>inport1 : <\/b> expects tuple Map<String, Object>. <br>\n <b>inport2 : <\/b> expects tuple Map<String, Object>. <br>\n <b>outport : <\/b> emits joinde tuple Map<String, Object>. <br>\n <br>\n <b> StateFull : <\/b> Yes, values are aggregated over application window.  <br>\n <b> Partitions : <\/b> No, will yield worng results. <br>\n Operator is pass thru, output tuples are emitted in current time window.  <br>\n <br>\n <b>Properties : <\/b> <br>\n <b> joinCondition : <\/b> Tuple join condition.","displayName":"Pig join operator"},{"name":"com.datatorrent.lib.pigquery.PigJoinOuterOperator","properties":[{"name":"joinCondition","canGet":true,"canSet":true,"description":"Condition","type":"com.datatorrent.lib.streamquery.condition.Condition","properties":[]},{"name":"joinType","canGet":true,"canSet":true,"description":"int","type":"int"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"inport1","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input1 port."},{"name":"inport2","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input2 port."}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Output port."}],"shortDesc":"This class implements Pig Join(Outer) semantic on live stream","longDesc":"\n <br>\n <b>Ports : <\/b> <br>\n <b>inport1 : <\/b> expects tuple Map<String, Object>. <br>\n <b>inport2 : <\/b> expects tuple Map<String, Object>. <br>\n <b>outport : <\/b> emits joinde tuple Map<String, Object>. <br>\n <br>\n <b> StateFull : <\/b> Yes, values are aggregated over application window.  <br>\n <b> Partitions : <\/b> No, will yield worng results. <br>\n Operator is end window operator, left\/right\/full values are emitted at end window.  <br>\n <br>\n <b>Properties : <\/b> <br>\n <b> joinCondition : <\/b> Tuple join condition.","displayName":"Pig join outer operator"},{"name":"com.datatorrent.lib.pigquery.ThreeWayPigSplit","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"inport","optional":false,"tupleType":"class java.lang.Object","description":"Input port."}],"outputPorts":[],"shortDesc":"<p>\n Class to implement Pig split operator semantic","longDesc":"A split into node creates\n multiple streams from a single stream. <br>\n This operator implements following semantic.  <br>\n <pre>\n instream is f1:int, f2:int, f3:int\n\n The expression for split into is \"X IF f1<7, Y IF f2==5, Z IF (f3<6)\"\n\n For instream tuples (1,2,3) would produce (1,2,3) on X, (1,2,3) on Z (4,5,6)\n would produce (4,5,6) on X, (4,5,6) on Y (7,8,9) would produce (7,8,9) on Z\n\n This would match to split into metric for Pig\n <\/pre>","displayName":"Three way pig split"},{"name":"com.datatorrent.lib.script.JavaScriptOperator","properties":[{"name":"bindings","canGet":true,"canSet":false,"type":"java.util.Map","properties":[{"name":"empty","canGet":true,"canSet":false,"type":"boolean"}]},{"name":"engineByName","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"eval","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"invoke","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"passThru","canGet":false,"canSet":true,"type":"boolean"},{"name":"script","canGet":false,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"inBindings","optional":true,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>"}],"outputPorts":[{"name":"outBindings","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>"},{"name":"result","optional":true,"error":false,"tupleType":"class java.lang.Object"}],"shortDesc":"This operator executes JavaScript on tuples in for Map<String, Object>","longDesc":"Key\n is name of variable used in script code. Proper map values must be provided\n by UP stream operators.\n\n <b> Sample Usage Code : <\/b>\n\n <pre>\n \/\/ Add random integer generator operator\n SingleKeyValMap rand = dag.addOperator(&quot;rand&quot;, SingleKeyValMap.class);\n\n Script script = dag.addOperator(&quot;script&quot;, Script.class);\n \/\/ script.setEval(&quot;val = val*val;&quot;);\n script.addSetupScript(&quot;function square() { return val*val;}&quot;);\n script.setInvoke(&quot;square&quot;);\n dag.addStream(&quot;evalstream&quot;, rand.outport, script.inBindings);\n\n \/\/ Connect to output console operator\n ConsoleOutputOperator console = dag.addOperator(&quot;console&quot;,\n \t\tnew ConsoleOutputOperator());\n dag.addStream(&quot;rand_console&quot;, script.result, console.input);\n\n <\/pre>\n\n <b> Sample Input Operator(emit)<\/b>\n\n <pre>\n  \t.\n \t\t.\n \t\tpublic void emitTuples() {\n \t\t\tHashMap<String, Object> map = new HashMap<String, Object>();\n \t\t\tmap.put(\"val\", random.nextInt());\n \t\t\toutport.emit(map);\n \t\t\t.\n \t\t\t.\n \t\t}\n \t\t.\n \t\t.\n <\/pre>\n\n This operator does not checkpoint interpreted functions in the variable bindings because they are not serializable\n Use setupScript() to define functions, and do NOT define or assign functions to variables at run time","displayName":"Java script operator"},{"name":"com.datatorrent.lib.script.RubyOperator","properties":[{"name":"bindings","canGet":true,"canSet":false,"type":"java.util.Map","properties":[{"name":"empty","canGet":true,"canSet":false,"type":"boolean"}]},{"name":"eval","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"invoke","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"passThru","canGet":false,"canSet":true,"type":"boolean"},{"name":"script","canGet":false,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"inBindings","optional":true,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>"}],"outputPorts":[{"name":"outBindings","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>"},{"name":"result","optional":true,"error":false,"tupleType":"class java.lang.Object"}],"shortDesc":"Operator to execute ruby script on tuples","displayName":"Ruby operator"},{"name":"com.datatorrent.lib.statistics.DimensionsComputation","properties":[{"name":"aggregators","canGet":true,"canSet":true,"type":"[Lcom.datatorrent.lib.statistics.DimensionsComputation$Aggregator;"},{"name":"unifier","canGet":false,"canSet":true,"type":"com.datatorrent.api.Operator$Unifier","properties":[]}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[{"name":"output","optional":true,"error":false,"tupleType":"interface com.datatorrent.lib.statistics.DimensionsComputation$AggregateEvent"}],"shortDesc":"<p>DimensionsComputation class.<\/p>","displayName":"Dimensions computation"},{"name":"com.datatorrent.lib.statistics.DimensionsComputationUnifierImpl","properties":[{"name":"aggregators","canGet":false,"canSet":true,"type":"[Lcom.datatorrent.lib.statistics.DimensionsComputation$Aggregator;"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[],"outputPorts":[{"name":"output","optional":true,"error":false,"tupleType":"interface com.datatorrent.lib.statistics.DimensionsComputation$AggregateEvent"}],"shortDesc":"A {@link Unifier} implementation for {@link DimensionsComputation}.<br\/>","displayName":"Dimensions computation unifier impl"},{"name":"com.datatorrent.lib.statistics.MedianOperator","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Number","description":"Input data port."}],"outputPorts":[{"name":"median","optional":true,"error":false,"tupleType":"class java.lang.Number","description":"Output port"}],"shortDesc":"This operator computes median of incoming data","longDesc":"<br>\n <br>\n <b>Input Port(s) : <\/b><br>\n <b>data : <\/b> Data values input port. <br>\n <br>\n <b>Output Port(s) : <\/b> <br>\n <b>median : <\/b>Median output port. <br>\n <br>\n <b>StateFull : Yes<\/b>, value are aggregated over application window. <br>\n <b>Partitions : No<\/b>, no will yield wrong results. <br>\n <br>+","displayName":"Median operator"},{"name":"com.datatorrent.lib.statistics.ModeOperator","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.lang.Comparable<?>","description":"Input data port."}],"outputPorts":[{"name":"mean","optional":true,"error":false,"tupleType":"java.lang.Comparable<?>","description":"Output port"}],"shortDesc":"This operator computes weighted mean of incoming data","longDesc":"<br>\n <br>\n <b>Input Port(s) : <\/b><br>\n <b>data : <\/b> Data values input port. <br>\n <br>\n <b>Output Port(s) : <\/b> <br>\n <b>mode : <\/b>Mode value output port. <br>\n <br>\n <b>StateFull : Yes<\/b>, value are aggregated over application window. <br>\n <b>Partitions : No<\/b>, no will yeild wrong results. <br>\n <br>","displayName":"Mode operator"},{"name":"com.datatorrent.lib.statistics.StandardDeviation","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Number","description":"Input data port."}],"outputPorts":[{"name":"standardDeviation","optional":true,"error":false,"tupleType":"class java.lang.Number","description":"Standard deviation output port"},{"name":"variance","optional":true,"error":false,"tupleType":"class java.lang.Number","description":"Variance output port"}],"shortDesc":"This operator computes variance and standard deviation over incoming data","longDesc":"<br>\n <br>\n <b>Input Port(s) : <\/b><br>\n <b>data : <\/b> Data values input port. <br>\n <br>\n <b>Output Port(s) : <\/b> <br>\n <b>variance : <\/b>Variance value output port. <br>\n <b>standardDeviatin : <\/b>Variance value output port. <br>\n <br>\n <b>StateFull : Yes<\/b>, value are aggregated over application window. <br>\n <b>Partitions : No<\/b>, no will yield wrong results. <br>\n <br>","displayName":"Standard deviation"},{"name":"com.datatorrent.lib.statistics.WeightedMeanOperator","properties":[{"name":"VType","canGet":false,"canSet":true,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"},{"name":"average","canGet":true,"canSet":false,"type":"java.lang.Number"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Number","description":"Input data port."},{"name":"weight","optional":false,"tupleType":"class java.lang.Number","description":"Input weight port."}],"outputPorts":[{"name":"mean","optional":true,"error":false,"tupleType":"class java.lang.Number","description":"Output port"}],"shortDesc":"This operator computes weighted mean of incoming data","longDesc":"<br>\n <br>\n <b>Input Port(s) : <\/b><br>\n <b>data : <\/b> Data values input port. <br>\n <b>weight : <\/b> Current input data weight. <br>\n <br>\n <b>Output Port(s) : <\/b> <br>\n <b>mean : <\/b>Weighted mean output port. <br>\n <br>\n <b>StateFull : Yes<\/b>, value are aggregated over application window. <br>\n <b>Partitions : No<\/b>, no will yeild wrong results. <br>\n <br>","displayName":"Weighted mean operator"},{"name":"com.datatorrent.lib.stream.ArrayListAggregator","properties":[{"name":"size","canGet":true,"canSet":true,"description":"size of collection","type":"int"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"class java.lang.Object","description":"Input port."}],"outputPorts":[{"name":"output","optional":true,"error":false,"tupleType":"java.util.Collection<T>","description":"Collection output port."}],"shortDesc":"Creates a ArrayList tuple from incoming tuples","longDesc":"The size of the ArrayList before it is emitted is determined by property \\\"size\\\". If size == 0\n then the ArrayList (if not empty) is emitted in the endWindow call. Is size is specified then the ArrayList is emitted as soon as the size is\n reached as part of process(tuple), and no emit happens in endWindow. For size != 0, the operator is statefull.<p>\n <br>\n <b>Port<\/b>:<br>\n <b>input<\/b>: expects T<br>\n <b>output<\/b>: emits ArrayList&lt;T&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>size<\/b>: The size of ArrayList. If specified the ArrayList is emitted the moment it reaches this size.\n               If 0, the ArrayList is emitted in endWindow call. Default value is 0, <\/br>\n <br>","displayName":"Array list aggregator"},{"name":"com.datatorrent.lib.stream.ArrayListToItem","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.ArrayList<K>","description":"Input array list port."}],"outputPorts":[{"name":"item","optional":true,"error":false,"tupleType":"class java.lang.Object","description":"Output array item port."}],"shortDesc":"<p>\n Takes in an ArrayList and emits each item in the array; mainly used for\n breaking up a ArrayList tuple into Objects","longDesc":"<br>\n It is a pass through operator<br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects ArrayList&lt;K&gt;br> <b>item<\/b>: emits K<br>","displayName":"Array list to item"},{"name":"com.datatorrent.lib.stream.ConsolidatorKeyVal","properties":[],"inputPorts":[{"name":"in1","optional":false,"tupleType":"class java.lang.Object","description":"V1 type value input port."},{"name":"in2","optional":false,"tupleType":"class java.lang.Object","description":"V2 type value input port."},{"name":"in3","optional":true,"tupleType":"class java.lang.Object","description":"V3 type value input port."},{"name":"in4","optional":true,"tupleType":"class java.lang.Object","description":"V4 type value input port."},{"name":"in5","optional":true,"tupleType":"class java.lang.Object","description":"V5 type value input port."}],"outputPorts":[{"name":"out","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.util.ArrayList<java.lang.Object>>","description":"Key\/array values map output port."}],"shortDesc":"<p>\n Operator aggregates key\/value input from 5 ports of different types into\n key\/array list map, for each key","longDesc":"<br>\n Operator emits key\/array list map at end window, this end window operator. <br>\n <br>\n <b>StateFull : Yes<\/b>, values are collected over application window. <br>\n <b>Partitions : No<\/b>, will collect wrong results. <br>\n <br>\n <b>Ports : <\/b><br>\n <b>Input(s) : <\/b> 5 max input ports, 3 are optional. <br>\n <br>","displayName":"Consolidator key val"},{"name":"com.datatorrent.lib.stream.Counter","properties":[],"inputPorts":[{"name":"input","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[{"name":"output","optional":true,"error":false,"tupleType":"class java.lang.Integer"}],"shortDesc":"Counter counts the number of tuples delivered to it in each window and emits\n the count","longDesc":" <p>\n This is a pass through operator<br>\n <br>\n <b>StateFull : Yes<\/b>, tuples are counted over application window. <br>\n <b>Partitions : Yes<\/b>, count is unified at output port. <br>\n <b>Ports<\/b>:<br>\n <b>input<\/b>: expects Object<br>\n <b>output<\/b>: emits Integer<br>\n <br>","displayName":"Counter"},{"name":"com.datatorrent.lib.stream.DevNull","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Object","description":"Input any data type port."}],"outputPorts":[],"shortDesc":"Terminates a stream; does nothing to the tuple","longDesc":"Useful if you want to have a\n stream for monitoring purpose etc. In future STRAM may simply support a\n virtual stream and make this operator redundant<br>\n <br>\n <b>Port<\/b>:<br>\n <b>data<\/b>: expects K<br>\n <br>","displayName":"Dev null"},{"name":"com.datatorrent.lib.stream.DevNullCounter","properties":[{"name":"debug","canGet":true,"canSet":true,"description":"debug state","type":"boolean"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"rollingwindowcount","canGet":false,"canSet":true,"type":"int"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[],"shortDesc":"<p>\n Counts and then drops the tuple; mainly used for logging","longDesc":"Increments a count\n and writes the net number (rate) to console. Useful to benchmark other\n modules.<br>\n This operator is neither pass through nor windowed as far as data tuples are\n concerned. The logging is done during end of window call.<br>\n <br>\n <b>Port<\/b>:<br>\n <b>data<\/b>: expects K<br>\n <br>\n <b>Properties<\/b>: rollingwindowcount: Number of windows to average over.\n Results are written to the log<br>\n <br>","displayName":"Dev null counter"},{"name":"com.datatorrent.lib.stream.HashMapToKeyValPair","properties":[{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.HashMap<K, V>","description":"Input key\/vale map port."}],"outputPorts":[{"name":"key","optional":true,"error":false,"tupleType":"class java.lang.Object","description":"Key output port."},{"name":"keyval","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>","description":"key\/value pair output port."},{"name":"val","optional":true,"error":false,"tupleType":"class java.lang.Object","description":"Value output port."}],"shortDesc":"Takes a HashMap and emits its keys, keyvals, vals; used for breaking up a\n HashMap tuple into objects (keys, vals, or key\/val pairs)\n <p>\n This is a pass through operator<br>\n <br>\n <b>StateFull : No<\/b> <br>\n <b>Partitions : Yes <\/b><br>\n <br>\n <b>Ports<\/b>:<br>\n <b>data<\/b>: expects HashMap&lt;K,V&gt;<br>\n <b>key<\/b>: emits K<br>\n <b>keyval<\/b>: emits Entry&lt;K,V&gt;<br>\n <b>val<\/b>: emits V<br>\n <br>","displayName":"Hash map to key val pair"},{"name":"com.datatorrent.lib.stream.JsonByteArrayOperator","properties":[{"name":"concatenationCharacter","canGet":false,"canSet":true,"type":"char"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"input","optional":false,"tupleType":"byte[]","description":"Input byte array port."}],"outputPorts":[{"name":"flatmap","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.lang.Object>","description":"Output hash map port."},{"name":"jsonobject","optional":true,"error":false,"tupleType":"class org.codehaus.jettison.json.JSONObject","description":"Output JSONObject port."},{"name":"map","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.lang.Object>","description":"Output hash map port."}],"shortDesc":"Takes a json byte stream and emits a HashMap of key values\n <p>\n This is a pass through operator<br>\n <br>\n <b>Ports<\/b>:<br>\n <b>input<\/b>: expects json byte array &lt;K,V&gt;<br>\n <b>outputMap<\/b>: emits HashMap&lt;String,Object&gt;<br>\n <b>outputJsonObject<\/b>: emits JSONObject<br>\n <b>outputFlatMap<\/b>: emits HashMap&lt;String,Object&gt;<br>\n &nbsp&nbsp The key will be dot concatenated nested key names <br>\n &nbsp&nbsp eg: key: \"agentinfo.os.name\", value: \"Ubuntu\" <br>\n <br>","displayName":"Json byte array operator"},{"name":"com.datatorrent.lib.stream.KeyValPairToHashMap","properties":[{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, V>","description":"key\/value input port."}],"outputPorts":[{"name":"map","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>","description":"key\/value map output port."}],"shortDesc":"Takes a KeyValPair and emits a HashMap(1), Used for for converting KeyValPair\n to a HashMap(1) tuple\n <p>\n This is a pass through operator<br>\n <br>\n <b>Ports<\/b>:<br>\n <b>keyval<\/b>: expects KeyValPair&lt;K,V&gt;<br>\n <b>map<\/b>: emits HashMap&lt;K,V&gt;<br>\n <br>","displayName":"Key val pair to hash map"},{"name":"com.datatorrent.lib.stream.RoundRobinHashMap","properties":[{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"keys","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Object","description":"Value input port."}],"outputPorts":[{"name":"map","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>","description":"key\/value map output port."}],"shortDesc":"<p>\n Creates a HashMap tuple from incoming tuples","longDesc":"If keys[] are set, then each\n incoming tuple is the value of the key (in-order) till all keys get a value.\n Once all keys are assigned values, the tuple (HashMap) is emitted, the\n process of assigning values starts again<br>\n This is a stateful operator as it waits across window boundary to complete\n the HashTable<br>\n <br>\n <b> StateFull : Yes, <\/b>Operator maintains index of key across windows. <br>\n <b> Partitions : Yes <\/b> <br>\n <br>\n <b>Port<\/b>:<br>\n <b>data<\/b>: expects V<br>\n <b>map<\/b>: emits HashMap&lt;K,v&gt;<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>keys[]<\/b>: Set of keys to insert in the output tuple<\/b>","displayName":"Round robin hash map"},{"name":"com.datatorrent.lib.stream.StreamDuplicater","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.Object","description":"Input port."}],"outputPorts":[{"name":"out1","optional":true,"error":false,"tupleType":"class java.lang.Object","description":"Output port 1."},{"name":"out2","optional":true,"error":false,"tupleType":"class java.lang.Object","description":"Output port 2."}],"shortDesc":"Duplicates an input stream as is into two output streams; needed to allow separation of listeners into two streams with different properties (for example\n inline vs in-rack)<p>\n This is a pass through operator<br>\n <br>\n <b>Port Interface<\/b><br>\n <b>data<\/b>: expects &lt;K&gt;<br>\n <b>out1<\/b>: emits &lt;K&gt;<br>\n <b>out2<\/b>: emits &lt;K&gt;<br>\n <br>","displayName":"Stream duplicater"},{"name":"com.datatorrent.lib.stream.StreamMerger","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data1","optional":false,"tupleType":"class java.lang.Object","description":"Data port 1."},{"name":"data2","optional":false,"tupleType":"class java.lang.Object","description":"Data port 2."}],"outputPorts":[{"name":"out","optional":true,"error":false,"tupleType":"class java.lang.Object","description":"Output port."}],"shortDesc":"Merges two streams with identical schema and emits the tuples to the output port in order<p>\n This is a pass through operator<br>\n <b>Ports<\/b>:<br>\n <b>data1<\/b>: expects K<br>\n <b>data2<\/b>: expects K<br>\n <b>out<\/b>: emits K<br>\n <br>","displayName":"Stream merger"},{"name":"com.datatorrent.lib.streamquery.DeleteOperator","properties":[{"name":"condition","canGet":false,"canSet":true,"type":"com.datatorrent.lib.streamquery.condition.Condition","properties":[]},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"inport","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input port."}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Output port."}],"shortDesc":"This operator provides sql select query semantic on live data stream","longDesc":"<br>\n Stream rows passing condition are emitted on output port stream. <br>\n <br>\n <b>StateFull : NO,<\/b> all row data is processed in current time window. <br>\n <b>Partitions : Yes, <\/b> No Input dependency among input rows. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b> inport : <\/b> Input hash map(row) port, expects\n HashMap&lt;String,Object&gt;<<br>\n <b> outport : <\/b> Output hash map(row) port, emits\n HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <b> <br>\n <b> condition : <\/b> Select condition for selecting rows. <br>\n <b> columns : <\/b> Column names\/aggregate functions for select. <br>\n <br>","displayName":"Delete operator"},{"name":"com.datatorrent.lib.streamquery.DerbySqlStreamOperator","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"statement","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"bindings","optional":true,"tupleType":"java.util.ArrayList<java.lang.Object>"},{"name":"in1","optional":false,"tupleType":"java.util.HashMap<java.lang.String, java.lang.Object>"},{"name":"in2","optional":true,"tupleType":"java.util.HashMap<java.lang.String, java.lang.Object>"},{"name":"in3","optional":true,"tupleType":"java.util.HashMap<java.lang.String, java.lang.Object>"},{"name":"in4","optional":true,"tupleType":"java.util.HashMap<java.lang.String, java.lang.Object>"},{"name":"in5","optional":true,"tupleType":"java.util.HashMap<java.lang.String, java.lang.Object>"}],"outputPorts":[{"name":"result","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.lang.Object>"}],"shortDesc":"Embedded derby sql input operator.","displayName":"Derby sql stream operator"},{"name":"com.datatorrent.lib.streamquery.GroupByHavingOperator","properties":[{"name":"condition","canGet":false,"canSet":true,"type":"com.datatorrent.lib.streamquery.condition.Condition","properties":[]},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"inport","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input port."}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Output port."}],"shortDesc":"This operator provides sql group by query semantic on live data stream","longDesc":"<br>\n Stream rows satisfying given select condition are processed by group by\n column names and aggregate column function. <br>\n If having condition is specified for aggregate index(s), it must also be\n satisfied by row. HashMap of column name(s) and aggregate alias is emitted on\n output port. <br>\n <br>\n <b>StateFull : Yes,<\/b> Operator aggregates input over application window. <br>\n <b>Partitions : No, <\/b> will yield wrong result(s). <br>\n <br>\n <b>Ports<\/b>:<br>\n <b> inport : <\/b> Input hash map(row) port, expects\n HashMap&lt;String,Object&gt;<<br>\n <b> outport : <\/b> Output hash map(row) port, emits\n HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <b> <br>\n <b> condition : <\/b> Select condition for deleting rows. <br>\n <b> columnGroupIndexes : <\/b> Group by names list. <br>\n <b> indexes : <\/b> Select column indexes. <br>\n <b> havingConditions : <\/b> Having filter conditions for aggregate(s). <br>\n <br>","displayName":"Group by having operator"},{"name":"com.datatorrent.lib.streamquery.InnerJoinOperator","properties":[{"name":"joinCondition","canGet":true,"canSet":true,"description":"the joinCondition","type":"com.datatorrent.lib.streamquery.condition.Condition","properties":[]}],"inputPorts":[{"name":"inport1","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input port 1."},{"name":"inport2","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input port 2."}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Output port."}],"shortDesc":"This operator reads table row data from 2 table data input ports","longDesc":"<br>\n Operator joins row on given condition and selected names, emits\n joined result at output port.\n  <br>\n  <b>StateFull : Yes,<\/b> Operator aggregates input over application window. <br>\n  <b>Partitions : No, <\/b> will yield wrong result(s). <br>\n  <br>\n  <b>Ports : <\/b> <br>\n  <b> inport1 : <\/b> Input port for table 1, expects HashMap&lt;String, Object&gt; <br>\n  <b> inport1 : <\/b> Input port for table 2, expects HashMap&lt;String, Object&gt; <br>\n  <b> outport : <\/b> Output joined row port, emits HashMap&lt;String, ArrayList&lt;Object&gt;&gt; <br>\n  <br>\n  <b> Properties : <\/b>\n  <b> joinCondition : <\/b> Join condition for table rows. <br>\n  <b> table1Columns : <\/b> Columns to be selected from table1. <br>\n  <b> table2Columns : <\/b> Columns to be selected from table2. <br>\n  <br>","displayName":"Inner join operator"},{"name":"com.datatorrent.lib.streamquery.OrderByOperator","properties":[{"name":"descending","canGet":true,"canSet":true,"description":"isDescending","type":"boolean"}],"inputPorts":[{"name":"inport","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input port."}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Output port."}],"shortDesc":"<p>\n This operator provides sql oredr by operator semantic over luve stream data","longDesc":"<br>\n Input data rows are ordered by order rules, ordered result is emitted on output port. <br>\n <br>\n  *  <br>\n  <b>StateFull : Yes,<\/b> Operator aggregates input over application window. <br>\n  <b>Partitions : Yes, <\/b> This operator is also unifier on output port. <br>\n  <br>\n <b>Ports<\/b>:<br>\n <b> inport : <\/b> Input hash map(row) port, expects HashMap&lt;String,Object&gt;<<br>\n <b> outport : <\/b> Output hash map(row) port, emits  HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <\/b> <br>\n <b> oredrByRules : <\/b>List of order by rules for tuples.","displayName":"Order by operator"},{"name":"com.datatorrent.lib.streamquery.OuterJoinOperator","properties":[{"name":"fullJoin","canGet":true,"canSet":true,"type":"boolean"},{"name":"joinCondition","canGet":true,"canSet":true,"description":"the joinCondition","type":"com.datatorrent.lib.streamquery.condition.Condition","properties":[]}],"inputPorts":[{"name":"inport1","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input port 1."},{"name":"inport2","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input port 2."}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Output port."}],"shortDesc":"This operator provides sql left\/right\/full outer join metric semantic on\n live stream","longDesc":"<br>\n Please refer to {@link com.datatorrent.lib.streamquery.InnerJoinOperator} for\n details.\n\n <b> Properties : <\/b> <br>\n <b> isLeftJoin : <\/b> Left join flag. <br>\n <b> isFullJoin : <\/b> Full join flag. <br>","displayName":"Outer join operator"},{"name":"com.datatorrent.lib.streamquery.SelectFunctionOperator","properties":[],"inputPorts":[{"name":"inport","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input port."}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Output port."}],"shortDesc":"<p>\n This operator applies sql top\/limit semantic on incoming tuple(s)","longDesc":"<br>\n <b>StateFull : Yes,<\/b> Operator aggregates input over application window. <br>\n <b>Partitions : No, <\/b> will yield wrong result(s). <br>\n <br>\n <b>Ports : <\/b> <br>\n <b>inport : <\/b> expect tuple for type T. <br>\n <b>outport : <\/b> emits tuple for type T. <br>\n <br>\n <b> Properties : <\/b> <br>\n <b> functions : <\/b> Sql function for rows. <br>","displayName":"Select function operator"},{"name":"com.datatorrent.lib.streamquery.SelectOperator","properties":[{"name":"condition","canGet":false,"canSet":true,"type":"com.datatorrent.lib.streamquery.condition.Condition","properties":[]},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"inport","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input port."}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Output port."}],"shortDesc":"This operator provides sql select query semantic on live data stream","longDesc":"<br>\n Stream rows passing condition are emitted on output port stream. <br>\n <br>\n <b>StateFull : NO,<\/b> all row data is processed in current time window. <br>\n <b>Partitions : Yes, <\/b> No Input dependency among input rows. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b> inport : <\/b> Input hash map(row) port, expects\n HashMap&lt;String,Object&gt;<<br>\n <b> outport : <\/b> Output hash map(row) port, emits\n HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <b> <br>\n <b> condition : <\/b> Select condition for selecting rows. <br>\n <b> columns : <\/b> Column names\/aggregate functions for select. <br>\n <br>","displayName":"Select operator"},{"name":"com.datatorrent.lib.streamquery.SelectTopOperator","properties":[{"name":"percentage","canGet":true,"canSet":true,"type":"boolean"},{"name":"topValue","canGet":true,"canSet":true,"type":"int"}],"inputPorts":[{"name":"inport","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input port."}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Output port."}],"shortDesc":"This operator provides sql top select query semantic on live data stream","longDesc":"<br>\n Stream rows passing condition are emitted on output port stream. <br>\n <br>\n <b>StateFull : NO,<\/b> all row data is processed in current time window. <br>\n <b>Partitions : Yes, <\/b> No Input dependency among input rows. <br>\n <br>\n <b>Ports<\/b>:<br>\n <b> inport : <\/b> Input hash map(row) port, expects\n HashMap&lt;String,Object&gt;<<br>\n <b> outport : <\/b> Output hash map(row) port, emits\n HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <b> <br>\n <b> topValue : <\/b> top values count. <br>\n <b> isPercentage : <\/b> top values count is percentage flag.\n <br>","displayName":"Select top operator"},{"name":"com.datatorrent.lib.streamquery.UpdateOperator","properties":[{"name":"condition","canGet":false,"canSet":true,"type":"com.datatorrent.lib.streamquery.condition.Condition","properties":[]},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"inport","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Input port."}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>","description":"Output port."}],"shortDesc":"This operator provides sql select query semantic on live data stream","longDesc":"<br>\n  Stream rows passing condition are emitted on output port stream. <br>\n  <br>\n  <b>StateFull : NO,<\/b> all row data is processed in current time window. <br>\n  <b>Partitions : Yes, <\/b> No Input dependency among input rows. <br>\n  <br>\n <b>Ports<\/b>:<br>\n <b> inport : <\/b> Input hash map(row) port, expects HashMap&lt;String,Object&gt;<<br>\n <b> outport : <\/b> Output hash map(row) port, emits  HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <b> <br>\n <b> condition : <\/b> Select condition for selecting rows. <br>\n <b> columns : <\/b> Column names\/aggregate functions for select. <br>\n <br>","displayName":"Update operator"},{"name":"com.datatorrent.lib.testbench.CompareFilterTuples","properties":[{"name":"compareType","canGet":false,"canSet":true,"type":"int"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"value","canGet":false,"canSet":true,"type":"int"}],"inputPorts":[{"name":"inport","optional":false,"tupleType":"java.util.Map<k, java.lang.Integer>"}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<k, java.lang.Integer>"},{"name":"redisport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.Integer, java.lang.String>"}],"shortDesc":"<p>CompareFilterTuples class.<\/p>","displayName":"Compare filter tuples"},{"name":"com.datatorrent.lib.testbench.CountOccurance","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"inport","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[{"name":"dimensionOut","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>"},{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<k, java.lang.Integer>"},{"name":"total","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Integer>"}],"shortDesc":"<p>CountOccurance class.<\/p>","displayName":"Count occurance"},{"name":"com.datatorrent.lib.testbench.EventClassifier","properties":[{"name":"keyMap","canGet":false,"canSet":true,"type":"java.util.HashMap","properties":[{"name":"empty","canGet":true,"canSet":false,"type":"boolean"}]},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"event","optional":false,"tupleType":"java.util.HashMap<java.lang.String, java.lang.Double>"}],"outputPorts":[{"name":"data","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.lang.Double>"}],"shortDesc":"Takes a in stream event and adds to incoming keys to create a new tuple that is emitted on output port data","longDesc":"The aim is to create a load with pair of keys<p>\n <br>\n Examples of pairs include<br>\n publisher,advertizer<br>\n automobile,model<br>\n <br>\n The keys to be inserted are given by the property <b>keys<\/b>. Users can choose to insert their\n own values via property <b>values<\/b>. Insertion can be done as replacement, addition, multiply,\n or append (append is not yet supported)<br>. For each incoming key users can provide an insertion\n probability for the insert keys. This allows for randomization of the insert key choice<br><br>\n <br>\n <b>Tuple Schema<\/b>: Each tuple is HashMap<String, Double> on both the ports. Currently other schemas are not supported<br>\n <b>Port Interface<\/b><br>\n <b>data<\/b>: emits HashMap<String,Double><br>\n <b>event<\/b>: expects HashMap<String,Double><br>\n <br>\n <b>Properties<\/b>:\n None<br>\n <br>\n Compile time checks are:<br>\n <b>keys<\/b> cannot be empty<br>\n <b>values<\/b> if specified has to be comma separated doubles and their number must match the number of keys<br>\n <b>weights<\/b> if specified the format has to be \"key1:val1,val2,...,valn;key2:val1,val2,...,valn;...\", where n has to be\n number of keys in parameter <b>keys<\/b>. If not specified all weights are equal<br>\n <br>\n <br>\n <b>Benchmarks<\/b>: This node has been benchmarked at over 5 million tuples\/second in local\/inline mode<br>","displayName":"Event classifier"},{"name":"com.datatorrent.lib.testbench.EventClassifierNumberToHashDouble","properties":[{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.String"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"seedend","canGet":true,"canSet":true,"description":"seed end","type":"int"},{"name":"seedstart","canGet":true,"canSet":true,"description":"seed start","type":"int"}],"inputPorts":[{"name":"event","optional":false,"tupleType":"class java.lang.Number"}],"outputPorts":[{"name":"data","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.lang.Double>"}],"shortDesc":"Takes a in stream event and adds to incoming keys to create a new tuple that is emitted on output port data","longDesc":"The aim is to create a load with pair of keys<p>\n <br>\n Examples of pairs include<br>\n publisher,advertizer<br>\n automobile,model<br>\n <br>\n The keys to be inserted are given by the property <b>keys<\/b>. Users can choose to insert their\n own values via property <b>values<\/b>. Insertion can be done as replacement, addition, multiply,\n or append (append is not yet supported)<br>. For each incoming key users can provide an insertion\n probability for the insert keys. This allows for randomization of the insert key choice<br><br>\n <br>\n <b>Tuple Schema<\/b>: Each tuple is HashMap<String, Double> on both the ports. Currently other schemas are not supported<br>\n <b>Port Interface<\/b><br>\n <b>data<\/b>: emits HashMap<String,Double><br>\n <b>event<\/b>: expects HashMap<String,Double><br>\n <br>\n <b>Properties<\/b>:\n None<br>\n <br>\n Compile time checks are:<br>\n <b>keys<\/b> cannot be empty<br>\n <b>values<\/b> if specified has to be comma separated doubles and their number must match the number of keys<br>\n <b>weights<\/b> if specified the format has to be \"key1:val1,val2,...,valn;key2:val1,val2,...,valn;...\", where n has to be\n number of keys in parameter <b>keys<\/b>. If not specified all weights are equal<br>\n <br>\n <br>\n <b>Benchmarks<\/b>: This node has been benchmarked at over 5 million tuples\/second in local\/inline mode<br>","displayName":"Event classifier number to hash double"},{"name":"com.datatorrent.lib.testbench.EventGenerator","properties":[{"name":"keys","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"maxCountOfWindows","canGet":false,"canSet":true,"type":"int"},{"name":"rollingWindowCount","canGet":false,"canSet":true,"type":"int"},{"name":"tuplesBlast","canGet":false,"canSet":true,"type":"int"},{"name":"values","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"weights","canGet":false,"canSet":true,"type":"java.lang.String"}],"inputPorts":[],"outputPorts":[{"name":"count","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.lang.Number>"},{"name":"hash_data","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.lang.Double>"},{"name":"string_data","optional":true,"error":false,"tupleType":"class java.lang.String"}],"shortDesc":"Generates synthetic load","longDesc":"Creates tuples and keeps emitting them on the output port \"data\"<p>\n <br>\n The load is generated as per config parameters. This class is mainly meant for testing\n nodes.<br>\n It does not need to be windowed. It would just create tuple stream upto the limit set\n by the config parameters.<br>\n <b>Ports<\/b>:\n <b>string_data<\/b>: emits String<br>\n <b>hash_data<\/b>: emits HashMap<String,Double><br>\n <b>count<b>: emits HashMap<String, Number>, contains per window count of throughput<br>\n <br>\n <b>Tuple Schema<\/b>: Has two choices HashMap<String, Double>, or String<br><br>\n <b>Port Interface<\/b>:It has only one output port \"data\" and has no input ports<br><br>\n <b>Properties<\/b>:\n <b>keys<\/b> is a comma separated list of keys. This key are the <key> field in the tuple<br>\n <b>values<\/b> are comma separated list of values. This value is the <value> field in the tuple. If not specified the values for all keys are 0.0<br>\n <b>weights<\/b> are comma separated list of probability weights for each key. If not specified the weights are even for all keys<br>\n <b>tuples_blast<\/b> is the total number of tuples sent out before the thread returns control. The default value is 10000<br>\n <b>max_windows_count<\/b>The number of windows after which the node would shut down. If not set, the node runs forever<br>\n <br>\n Compile time checks are:<br>\n <b>keys<\/b> cannot be empty<br>\n <b>values<\/b> if specified has to be comma separated doubles and their number must match the number of keys<br>\n <b>weights<\/b> if specified has to be comma separated integers and number of their number must match the number of keys<br>\n <b>tuples_blast<\/b>If specified must be an integer<br>\n <br>\n\n Compile time error checking includes<br>\n <b>Benchmarks><\/b>: Send as many tuples in in-line mode, the receiver just counts the tuples and drops the object<br>\n String schema does about 26 Million tuples\/sec in throughput<br>\n HashMap schema does about 10 Million tuples\/sec in throughput<br>","displayName":"Event generator"},{"name":"com.datatorrent.lib.testbench.EventIncrementer","properties":[{"name":"delta","canGet":false,"canSet":true,"type":"double"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"increment","optional":false,"tupleType":"java.util.HashMap<java.lang.String, java.util.HashMap<java.lang.String, java.lang.Integer>>"},{"name":"seed","optional":false,"tupleType":"java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.Integer>>"}],"outputPorts":[{"name":"count","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.lang.Integer>"},{"name":"data","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.lang.String>"}],"shortDesc":"Takes in a seed stream on port seed and then on increments this data based on increments on port increment","longDesc":"Data is immediately emitted on output port data.\n Emits number of tuples on port count<p>\n The aim is to create a random movement\n <br>\n Examples of application includes<br>\n random motion<br>\n <br>\n <br>\n Description: tbd\n <br>\n <b>Tuple Schema<\/b>: Each tuple is HashMap<String, ArrayList> on both the ports. Currently other schemas are not supported<br>\n <b>Port Interface<\/b><br>\n <b>seed<\/b>: The seed data for setting up the incrementor data to work on<br>\n <b>increment<\/b>: Small random increments to the seed data. This now creates a randomized change in the seed<br>\n <b>data<\/b>: Output of seed + increment<br>\n <b>count<\/b>: Emits number of processed tuples per window<br>\n <br>\n <b>Properties<\/b>:\n <br>keys: In case the value has multiple dimensions. They can be accessed via keys<br>\n <br>delta: The max value from an increment. The value on increment port is treated as a \"percent\" of this delta<br>\n Compile time checks are:<br>\n <br>\n <b>Benchmarks<\/b>: The benchmark was done in local\/inline mode<br>\n Processing tuples on seed port are at 3.5 Million tuples\/sec<br>\n Processing tuples on increment port are at 10 Million tuples\/sec<br>\n <br>","displayName":"Event incrementer"},{"name":"com.datatorrent.lib.testbench.FilterClassifier","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.HashMap<java.lang.String, T>"}],"outputPorts":[{"name":"filter","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, T>"}],"shortDesc":"Filters the tuples as per the filter (pass through percent) and emits them","longDesc":"The aim is to create another stream representing a subsection of incoming load<p>\n <br>\n Examples of pairs include<br>\n publisher,advertizer<br>\n automobile,model<br>\n <br>\n <b>Ports<\/b>:\n <b>data<\/b>: expects HashMap<String,T>\n <b>filter<\/b>:\n The keys to be inserted are given by the property <b>keys<\/b>. Users can choose to insert their\n own values via property <b>values<\/b>.<br>\n For each incoming key users can provide an insertion\n probability for the insert keys. This allows for randomization of the insert key choice<br><br>\n <br>\n Benchmarks: This node has been benchmarked at over 22 million tuples\/second in local\/inline mode<br>\n\n <b>Tuple Schema<\/b>: Each tuple is HashMap<String, Double> on both the ports. Currently other schemas are not supported<br>\n <br>\n <b>Properties<\/b>:\n <br>\n Compile time checks are:<br>\n <br>","displayName":"Filter classifier"},{"name":"com.datatorrent.lib.testbench.FilteredEventClassifier","properties":[{"name":"keyMap","canGet":false,"canSet":true,"type":"java.util.HashMap","properties":[{"name":"empty","canGet":true,"canSet":false,"type":"boolean"}]},{"name":"keyWeights","canGet":false,"canSet":true,"type":"java.util.HashMap","properties":[{"name":"empty","canGet":true,"canSet":false,"type":"boolean"}]},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"passFilter","canGet":false,"canSet":true,"type":"int"},{"name":"totalFilter","canGet":false,"canSet":true,"type":"int"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.HashMap<java.lang.String, T>"}],"outputPorts":[{"name":"filter","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, T>"}],"shortDesc":"Takes in a stream data and filters the tuples, and only emits tuples as per pass filter numbers provided\n on output port filter","longDesc":"The aim is to create another stream representing a subsection of incoming load<p>\n <br>\n Examples of pairs include<br>\n publisher,advertizer<br>\n automobile,model<br>\n <br>\n The keys to be inserted are given by the property <b>keys<\/b>. Users can choose to insert their\n own values via property <b>values<\/b>.<br>\n For each incoming key users can provide an insertion\n probability for the insert keys. This allows for randomization of the insert key choice<br><br>\n <br>\n <b>Tuple Schema<\/b>: Each tuple is HashMap<String, Double> on both the ports. Currently other schemas are not supported<br>\n <b>Port Interface<\/b><br>\n <b>out_data<\/b>: Output port for emitting the new tuple<br>\n <b>in_data<\/b>: Input port for receiving the incoming tuple<br>\n <br>\n <b>Properties<\/b>:\n <b>keys<\/b> is a comma separated list of keys. This key are the insert keys in the tuple<br>\n <b>values<\/b> are comma separated list of values. This value is for insertion into the <value> field in the tuple. also called \"insert value\". If not specified the incoming values are not changed<br>\n <b>weights<\/b> are comma separated list of probability weights for each incoming key. For each incoming key the weights have to be provided. If this parameter is empty all the weights are even for all keys<br>\n <b>percent<b>A number between 0 and 100. This is the percent of the time a new tuple is created. If say the number is 1, then a randomly selected 1 tuple out of 100 would create an output typle<br>\n <br>\n Compile time checks are:<br>\n <b>keys<\/b> cannot be empty<br>\n <b>values<\/b> if not provided the incoming value is passed through<br>\n <b>weights<\/b> if specified the format has to be \"key1:val1,val2,...,valn;key2:val1,val2,...,valn;...\", where n has to be\n number of keys in parameter <b>keys<\/b>. If not specified all weights are equal<br>\n <b>filter<\/b> The first number has to be less than the second and both have to be positive<br>\n <br>\n <b>Benchmarks<\/b>: Blast as many tuples as possible in inline mode<br>\n This node has been benchmarked at over 20 million tuples\/second in local\/inline mode<br>\n <br>","displayName":"Filtered event classifier"},{"name":"com.datatorrent.lib.testbench.HttpStatusFilter","properties":[{"name":"filterStatus","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"inport","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.String>"}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Integer>"}],"shortDesc":"<p>HttpStatusFilter class.<\/p>","displayName":"Http status filter"},{"name":"com.datatorrent.lib.testbench.KeyValSum","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"inport","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Integer>"}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Integer>"}],"shortDesc":"<p>KeyValSum class.<\/p>","displayName":"Key val sum"},{"name":"com.datatorrent.lib.testbench.RandomEventGenerator","properties":[{"name":"maxcountofwindows","canGet":false,"canSet":true,"type":"int"},{"name":"maxvalue","canGet":true,"canSet":true,"type":"int"},{"name":"minvalue","canGet":true,"canSet":true,"type":"int"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"tuplesBlast","canGet":true,"canSet":true,"type":"int"},{"name":"tuplesBlastIntervalMillis","canGet":true,"canSet":true,"type":"int"}],"inputPorts":[],"outputPorts":[{"name":"integer_data","optional":true,"error":false,"tupleType":"class java.lang.Integer"},{"name":"string_data","optional":true,"error":false,"tupleType":"class java.lang.String"}],"shortDesc":"Generates synthetic load","longDesc":"Creates tuples using random numbers and keeps emitting them on the output port string_data and integer_data<p>\n <br>\n The load is generated as per config parameters. This class is mainly meant for testing nodes by creating a random number within\n a range at a very high throughput. This node does not need to be windowed. It would just create tuple stream upto the limit set\n by the config parameters.<br>\n <br>\n <b>Tuple Schema<\/b>: Has two choices Integer, or String<br><br>\n <b>Port Interface<\/b>\n <b>string_data<\/b>: Emits String tuples<br>\n <b>integer_data<\/b>: Emits Integer tuples<br>\n <b>Properties<\/b>:\n <b>key<\/b> is an optional parameter, the generator sends an HashMap if key is specified<br>\n <b>min_value<\/b> is the minimum value of the range of numbers. Default is 0<br>\n <b>max_value<\/b> is the maximum value of the range of numbers. Default is 100<br>\n <b>tuples_burst<\/b> is the total amount of tuples sent by the node before handing over control. The default\n value is 10000. A high value does not help as if window has space the control is immediately returned for mode processing<br>\n <b>string_schema<\/b> controls the tuple schema. For string set it to \"true\". By default it is \"false\" (i.e. Integer schema)<br>\n <br>\n Compile time checks are:<br>\n <b>min_value<\/b> has to be an integer<br>\n <b>max_value<\/b> has to be an integer and has to be >= min_value<br>\n <b>tuples_burst<\/b>If specified must be an integer<br>\n <br>\n <b>Benchmarks<\/b>: Blast as many tuples as possible in inline mode<br>\n This node has been benchmarked at over 10 million tuples\/second in local\/inline mode<br>\n<br>\n Compile time error checking includes<br>\n <br>","displayName":"Random event generator"},{"name":"com.datatorrent.lib.testbench.RedisSumOper","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"inport","optional":false,"tupleType":"class java.lang.Integer"}],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.Integer, java.lang.Integer>"}],"shortDesc":"<p>RedisSumOper class.<\/p>","displayName":"Redis sum oper"},{"name":"com.datatorrent.lib.testbench.SeedEventClassifier","properties":[{"name":"key1","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"key2","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"seedend","canGet":false,"canSet":true,"type":"int"},{"name":"seedstart","canGet":false,"canSet":true,"type":"int"}],"inputPorts":[{"name":"data1","optional":false,"tupleType":"class java.lang.Object"},{"name":"data2","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[{"name":"hash_data","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.util.HashMap<java.lang.String, T>>"},{"name":"string_data","optional":true,"error":false,"tupleType":"class java.lang.String"}],"shortDesc":"Generates seeds and merges data as it comes in from input ports (data1, and data2)","longDesc":"The new tuple is emitted\n on the output ports string_data and hash_data<p>\n <br>\n Examples of getting seed distributions include<br>\n Chages in mobile co-ordinates of a phone<br>\n Random changes on motion of an object<br>\n <br>\n The seed is created from the values of properties <b>seed_start<\/b>, and <b>seed_end<\/b>\n <br>\n <b>Default schema<\/b>:<br>\n Schema for port <b>data<\/b>: The default schema is HashMap<String, ArrayList<valueData>>, where valueData is class{String, Integer}<br>\n <b>String schema<\/b>: The string is \"key;valkey1:value1;valkey2:value2;...\"<br>\n <b>HashMap schema<\/b>: Key is String, and Value is a ArrrayList<String, Number><br>\n The value in both the schemas is an integer (for choice of strings, these are enum values)\n <br>\n <b>Port Interface<\/b><br>\n <b>data1<\/b>: Expects tuples of type <T><br>\n <b>data2<\/b>: Expects tuples of type <T><br>\n <b>string_data<\/b>: Emits new classified seed of schema String<br>\n <b>hash_data<\/b>: Emits new classified seed of schema HashMap<String, HashMap<String, T>><br>\n <br>\n <b>Properties<\/b>:\n <b>seed_start<\/b>: An integer for the seed to start from<br>\n <b>seed_end<\/b>: An integer for the seed to end with<br>\n <br>string_schema<\/b>: If set to true, operates in string schema mode<br>\n <br>key<\/b>: Classifier keys to be inserted in order for each incoming tuple. Format is \"key1,key1start, key1end; key2, key2start, key2end;...\"\n <br>\n Compile time checks are:<br>\n <b>seed_start<\/b>Has to be an integer<br>\n <b>sedd_end<\/b>Has to be an integer<br>\n <b>key<\/b>If provided has to be in format \"key1,key1start,key1end;key2, key2start, key2end; ...\"\n <br>\n <b>Benchmarks<\/b>: Blast as many tuples as possible in inline mode<br>\n String: Benchmarked at over 13 million tuples\/second in local\/in-line mode<br>\n Integer: Benchmarked at over 7 million tuples\/second in local\/in-line mode<br>\n <br>","displayName":"Seed event classifier"},{"name":"com.datatorrent.lib.testbench.SeedEventGenerator","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"seedend","canGet":false,"canSet":true,"type":"int"},{"name":"seedstart","canGet":false,"canSet":true,"type":"int"}],"inputPorts":[],"outputPorts":[{"name":"keyvalpair_list","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.util.ArrayList<com.datatorrent.lib.util.KeyValPair>>"},{"name":"string_data","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.lang.String>"},{"name":"val_data","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.lang.String>"},{"name":"val_list","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.Integer>>"}],"shortDesc":"Generates one time seed load based on range provided for the keys, and adds new classification to incoming keys","longDesc":"The new tuple is emitted\n on the output port keyvalpair_list, val_list, string_data, val_data<p>\n <br>\n Examples of getting seed distributions include<br>\n Clients data of a company for every clientId (key is clienId)<br>\n Persons age, gender, for every phone number (key is phone number)<br>\n Year, color, mileage for every car make (key is car make model)<br>\n <br>\n The classification to be done is based on the value of the property <b>key<\/b>. This property provides all the classification\n information and their ranges<br>The range of values for the key is given in the format described below<br>\n <br>\n <b>Benchmarks<\/b>: Generate as many tuples as possible in inline mode<br>\n HashMap<String, String>: 8 million\/sec with no classification; 1.8 million tuples\/sec with classification<br>\n HashMap<Sring, ArrayList<Integer>>: 8 million\/sec with no classification; 3.5 million tuples\/sec with classification<br>\n <br>\n <b>Default schema<\/b>:<br>\n Schema for port <b>data<\/b>: The default schema is HashMap<String, ArrayList<valueData>>, where valueData is class{String, Integer}<br>\n <b>String schema<\/b>: The string is \"key;valkey1:value1;valkey2:value2;...\"<br>\n <b>HashMap schema<\/b>: Key is String, and Value is a ArrrayList<String, Number><br>\n The value in both the schemas is an integer (for choice of strings, these are enum values)\n <br>\n <b>Port Interface<\/b><br>\n <b>data<\/b>: Output port for emitting the new classified seed<br>\n <br>\n <b>Properties<\/b>:\n <b>seed_start<\/b>: An integer for the seed to start from<br>\n <b>seed_end<\/b>: An integer for the seed to end with<br>\n <br>string_schema<\/b>: If set to true, operates in string schema mode<br>\n <br>key<\/b>: Classifier keys to be inserted randomly. Format is \"key1,key1start, key1end; key2, key2start, key2end;...\"\n <br>\n Compile time checks are:<br>\n <b>seed_start<\/b>Has to be an integer<br>\n <b>seed_end<\/b>Has to be an integer<br>\n <b>key<\/b>If provided has to be in format \"key1,key1start,key1end;key2, key2start, key2end; ...\"\n <br>\n <b>Benchmarks<\/b>: Blast as many tuples as possible in inline mode<br>\n With key: Benchmarked at over 1 million tuples\/second in local\/in-line mode<br>\n Without key: Benchmarked at over 4 million tuples\/second in local\/in-line mode<br>","displayName":"Seed event generator"},{"name":"com.datatorrent.lib.testbench.ThroughputCounter","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"rollingWindowCount","canGet":true,"canSet":true,"type":"int"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"java.util.HashMap<K, V>"}],"outputPorts":[{"name":"count","optional":true,"error":false,"tupleType":"java.util.HashMap<java.lang.String, java.lang.Number>"}],"shortDesc":"Developed for a demo","longDesc":"Stram now has this data for all streams via its web-service<br>\n Expects incoming stream to be a HashMap<String, Integer> and add all integer values to compute throughput. These\n values are throughput per window from upstream operators. On end of window this total and average is emitted<p>\n <br>\n <br>\n Benchmarks: This node has been benchmarked at over 5 million tuples\/second in local\/inline mode<br>\n\n <b>Tuple Schema<\/b>\n Each input tuple is HashMap<String, Integer><br>\n Output tuple is a HashMap<String, Integer>, where strings are throughputs, averages etc<br>\n <b>Port Interface<\/b><br>\n <b>count<\/b>: Output port for emitting the results<br>\n <b>data<\/b>: Input port for receiving the incoming tuple<br>\n <br>\n <b>Properties<\/b>:\n rolling_window_count: Number of windows to average over\n <br>\n Compile time checks are:<br>\n none\n <br>\n <b>Benchmarks<\/b>: Blast as many tuples as possible in inline mode<br>\n Benchmarked at over 17 million tuples\/second in local\/in-line mode<br>\n <br>","displayName":"Throughput counter"},{"name":"com.datatorrent.lib.testbench.TopOccurance","properties":[{"name":"n","canGet":true,"canSet":true,"type":"int"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"threshHold","canGet":true,"canSet":true,"type":"int"}],"inputPorts":[{"name":"inport","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Integer>"}],"outputPorts":[{"name":"gtThreshHold","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.Integer, java.lang.String>"},{"name":"outport","optional":true,"error":false,"tupleType":"java.util.Map<java.lang.Integer, java.lang.String>"}],"shortDesc":"<p>TopOccurance class.<\/p>","displayName":"Top occurance"},{"name":"com.datatorrent.lib.util.AlertEscalationOperator","properties":[{"name":"activated","canGet":true,"canSet":true,"type":"boolean"},{"name":"alertInterval","canGet":true,"canSet":true,"type":"long"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"timeout","canGet":true,"canSet":true,"type":"long"}],"inputPorts":[{"name":"in","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[{"name":"alert","optional":false,"error":false,"tupleType":"class java.lang.Object"}],"shortDesc":"<p>AlertEscalationOperator class.<\/p>","displayName":"Alert escalation operator"},{"name":"com.datatorrent.lib.util.AlertThreeLevelTimedEscalationOperator","properties":[{"name":"activated","canGet":true,"canSet":true,"type":"boolean"},{"name":"alertInterval","canGet":true,"canSet":true,"type":"long"},{"name":"levelOneAlertTime","canGet":true,"canSet":true,"type":"long"},{"name":"levelThreeAlertTime","canGet":true,"canSet":true,"type":"long"},{"name":"levelTwoAlertTime","canGet":true,"canSet":true,"type":"long"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"timeout","canGet":true,"canSet":true,"type":"long"}],"inputPorts":[{"name":"in","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[{"name":"alert","optional":false,"error":false,"tupleType":"class java.lang.Object"},{"name":"alert2","optional":true,"error":false,"tupleType":"class java.lang.Object"},{"name":"alert3","optional":true,"error":false,"tupleType":"class java.lang.Object"}],"shortDesc":"Alert Escalation Operator intended for use with Alerts.","displayName":"Alert three level timed escalation operator"},{"name":"com.datatorrent.lib.util.ArrayHashMapFrequent","properties":[{"name":"least","canGet":true,"canSet":true,"description":"least flag","type":"boolean"}],"inputPorts":[],"outputPorts":[{"name":"mergedport","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Integer>"}],"shortDesc":"Combiner for an output port that emits object with Map<K,V> interface and has the processing done\n with sticky key partition, i.e","longDesc":"each one key belongs only to one partition. The final output of the\n combiner is a simple merge into a single object that implements Map","displayName":"Array hash map frequent"},{"name":"com.datatorrent.lib.util.BaseFilteredKeyValueOperator","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[],"outputPorts":[],"shortDesc":"Base class for operators that enables filtering of of keys to be processed<p>\n By default no filtering would be done as inverse is set to true and filterBy would be empty unless set<br>\n <br>\n <b>Ports<\/b>: None<br>\n <br>\n <b>Properties<\/b>:<br>\n <b>inverse<\/b>: if set to true the key in the filter will block tuple","longDesc":"Default is true<br>\n <b>filterBy<\/b>: List of keys to filter on. Default is an empty filter<br>\n <br>\n <b>Specific compile time checks<\/b>: None<br>\n <b>Specific run time checks<\/b>: None<br>\n <br>\n <b>Benchmarks<\/b>: Not done as there are no ports on this operator<br>\n <br>\n <br>","displayName":"Base filtered key value operator"},{"name":"com.datatorrent.lib.util.BaseKeyOperator","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[],"outputPorts":[],"shortDesc":"Base class for operators that allows cloneKey for enabling users to use mutable objects<p>","displayName":"Base key operator"},{"name":"com.datatorrent.lib.util.BaseKeyValueOperator","properties":[{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[],"outputPorts":[],"shortDesc":"Base class for operators that allows cloneValue and cloneKey for enabling users to use mutable objects<p>","displayName":"Base key value operator"},{"name":"com.datatorrent.lib.util.BaseLineTokenizer","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"splitBy","canGet":true,"canSet":true,"description":"splitBy","type":"java.lang.String"},{"name":"splitTokenBy","canGet":true,"canSet":true,"description":"splitTokenBy","type":"java.lang.String"}],"inputPorts":[{"name":"data","optional":false,"tupleType":"class java.lang.String"}],"outputPorts":[],"shortDesc":"Base class for splitting lines into tokens and tokens into sub-tokens","longDesc":"Base class for line split operators.<br>\n processToken, and processSubToken are called for each token. Users should override calls backs to intercept at any level.<p>\n This operator is a base class for pass through operators<br>\n <br>\n Ideal for applications like word count\n Ports:<br>\n <b>data<\/b>: expects String<br>","displayName":"Base line tokenizer"},{"name":"com.datatorrent.lib.util.BaseMatchOperator","properties":[{"name":"cmp","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"key","canGet":true,"canSet":true,"description":"key","type":"java.lang.Object"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseMatchOperator$supported_type"},{"name":"value","canGet":true,"canSet":true,"description":"value","type":"double"}],"inputPorts":[],"outputPorts":[],"shortDesc":"Base class that sets up the operator functionality needed for match based\n operators\n <p>\n <br>\n Ports:<br>\n none <br>\n Properties:<br>\n <b>key<\/b>: The key on which compare is done<br>\n <b>value<\/b>: The value to compare with<br>\n <b>comp<b>: The compare function","longDesc":"Supported values are \"lte\", \"lt\", \"eq\",\n \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n Compile time checks<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\",\n \"gte\"<br>\n <br>\n Run time checks<br>\n none<br>","displayName":"Base match operator"},{"name":"com.datatorrent.lib.util.BaseNumberKeyValueOperator","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[],"outputPorts":[],"shortDesc":"Base class for operators that take in &lt;K,V extends Number&gt;","longDesc":"Provides basic methods for value conversion<p>\n <br>\n <b>Benchmarks<\/b>: Not done as emit is done by sub-classes<br>\n <br>\n <br>\n <br>","displayName":"Base number key value operator"},{"name":"com.datatorrent.lib.util.BaseNumberValueOperator","properties":[{"name":"VType","canGet":false,"canSet":true,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"}],"inputPorts":[],"outputPorts":[],"shortDesc":"Base class for operators that take in V extends Number","longDesc":"Provides basic methods for value conversion<p>\n <br>\n <b>Benchmarks<\/b>: Not done as there is emit tuple is done by sub-classes<br>\n <br>\n <br>\n <br>","displayName":"Base number value operator"},{"name":"com.datatorrent.lib.util.BaseUniqueKeyCounter","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[],"outputPorts":[],"shortDesc":"Count unique occurrences of keys within an application window","displayName":"Base unique key counter"},{"name":"com.datatorrent.lib.util.BaseUniqueKeyValueCounter","properties":[{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[],"outputPorts":[],"shortDesc":"Count unique occurances of keys within a window<p>\n <br>\n <b>Benchmarks<\/b>: Blast as many tuples as possible in inline mode<br>\n Operator processes > 110 million tuples\/sec","longDesc":"Only one tuple per unique key is emitted on end of window, so this operator is not bound by outbound throughput<br>","displayName":"Base unique key value counter"},{"name":"com.datatorrent.lib.util.DimensionTimeBucketSumOperator","properties":[{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"timeBucketFlags","canGet":false,"canSet":true,"type":"int"},{"name":"timeKeyName","canGet":false,"canSet":true,"type":"java.lang.String"},{"name":"timeZone","canGet":false,"canSet":true,"type":"java.util.TimeZone","properties":[{"name":"DSTSavings","canGet":true,"canSet":false,"type":"int"},{"name":"ID","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"displayName","canGet":true,"canSet":false,"type":"java.lang.String"},{"name":"rawOffset","canGet":true,"canSet":true,"type":"int"}]}],"inputPorts":[{"name":"in","optional":false,"tupleType":"java.util.Map<java.lang.String, java.lang.Object>"}],"outputPorts":[{"name":"out","optional":false,"error":false,"tupleType":"java.util.Map<java.lang.String, java.util.Map<java.lang.String, java.lang.Number>>","description":"First String key is the bucket Second String key is the key Third String\n key is the field"}],"shortDesc":"<p>DimensionTimeBucketSumOperator class.<\/p>","displayName":"Dimension time bucket sum operator"},{"name":"com.datatorrent.lib.util.JavaScriptFilterOperator","properties":[{"name":"functionName","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"setupScript","canGet":true,"canSet":true,"type":"java.lang.String"}],"inputPorts":[{"name":"in","optional":false,"tupleType":"class java.lang.Object"}],"outputPorts":[{"name":"out","optional":false,"error":false,"tupleType":"class java.lang.Object"}],"shortDesc":"The filter operator that uses JavaScript, intended for use with alerts","displayName":"Java script filter operator"},{"name":"com.datatorrent.lib.util.UnifierArrayHashMapFrequent","properties":[{"name":"least","canGet":true,"canSet":true,"description":"least flag","type":"boolean"}],"inputPorts":[],"outputPorts":[{"name":"mergedport","optional":true,"error":false,"tupleType":"java.util.ArrayList<java.util.HashMap<K, java.lang.Integer>>"}],"shortDesc":"Combiner for an output port that emits object with Map<K,V> interface and has the processing done\n with sticky key partition, i.e","longDesc":"each one key belongs only to one partition. The final output of the\n combiner is a simple merge into a single object that implements Map","displayName":"Unifier array hash map frequent"},{"name":"com.datatorrent.lib.util.UnifierArrayList","properties":[],"inputPorts":[],"outputPorts":[{"name":"mergedport","optional":true,"error":false,"tupleType":"java.util.ArrayList<K>","description":"Output port"}],"shortDesc":"Unifier for array list output port.","displayName":"Unifier array list"},{"name":"com.datatorrent.lib.util.UnifierBooleanAnd","properties":[],"inputPorts":[],"outputPorts":[{"name":"mergedport","optional":true,"error":false,"tupleType":"class java.lang.Boolean"}],"shortDesc":"Combiner for an output port that emits object with Map<K,V> interface and has the processing done\n with sticky key partition, i.e","longDesc":"each one key belongs only to one partition. The final output of the\n combiner is a simple merge into a single object that implements Map","displayName":"Unifier boolean and"},{"name":"com.datatorrent.lib.util.UnifierBooleanOr","properties":[],"inputPorts":[],"outputPorts":[{"name":"mergedport","optional":true,"error":false,"tupleType":"class java.lang.Boolean"}],"shortDesc":"Combiner for an output port that emits object with Map<K,V> interface and has the processing done\n with sticky key partition, i.e","longDesc":"each one key belongs only to one partition. The final output of the\n combiner is a simple merge into a single object that implements Map","displayName":"Unifier boolean or"},{"name":"com.datatorrent.lib.util.UnifierCountOccurKey","properties":[],"inputPorts":[],"outputPorts":[{"name":"outport","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>","description":"Key\/occurrence value pair output port."}],"shortDesc":"This unifier aggregates occurrence of key on output port and emits key\/total occurrence value pair.","displayName":"Unifier count occur key"},{"name":"com.datatorrent.lib.util.UnifierHashMap","properties":[],"inputPorts":[],"outputPorts":[{"name":"mergedport","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>"}],"shortDesc":"Combiner for an output port that emits object with Map<K,V> interface and has the processing done\n with sticky key partition, i.e","longDesc":"each one key belongs only to one partition. The final output of the\n combiner is a simple merge into a single object that implements Map","displayName":"Unifier hash map"},{"name":"com.datatorrent.lib.util.UnifierHashMapFrequent","properties":[{"name":"least","canGet":true,"canSet":true,"description":"least flag","type":"boolean"}],"inputPorts":[],"outputPorts":[{"name":"mergedport","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Integer>"}],"shortDesc":"Combiner for an output port that emits object with Map<K,V> interface and has the processing done\n with sticky key partition, i.e","longDesc":"each one key belongs only to one partition. The final output of the\n combiner is a simple merge into a single object that implements Map","displayName":"Unifier hash map frequent"},{"name":"com.datatorrent.lib.util.UnifierHashMapInteger","properties":[],"inputPorts":[],"outputPorts":[{"name":"mergedport","optional":true,"error":false,"tupleType":"java.util.HashMap<K, java.lang.Integer>"}],"shortDesc":"Combiner for an output port that emits object with Map<K,Integer> interface and has the processing done\n with round robin partitions","longDesc":"The combiner needs to add values of a key from every partition","displayName":"Unifier hash map integer"},{"name":"com.datatorrent.lib.util.UnifierHashMapRange","properties":[],"inputPorts":[],"outputPorts":[{"name":"mergedport","optional":true,"error":false,"tupleType":"java.util.HashMap<K, com.datatorrent.lib.util.HighLow<V>>"}],"shortDesc":"Combiner for an output port that emits object with Map<K,ArrayList<V>(2)> interface and has the processing done\n with round robin partition","longDesc":"The first element in the ArrayList is high, the next is low","displayName":"Unifier hash map range"},{"name":"com.datatorrent.lib.util.UnifierHashMapSumKeys","properties":[{"name":"filterBy","canGet":false,"canSet":true,"type":"[Ljava.lang.Object;"},{"name":"inverse","canGet":true,"canSet":true,"description":"the value of inverse","type":"boolean"},{"name":"keyValPairStreamCodec","canGet":true,"canSet":false,"type":"java.lang.Class"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":false,"canSet":true,"type":"java.lang.Class"}],"inputPorts":[],"outputPorts":[{"name":"mergedport","optional":true,"error":false,"tupleType":"java.util.HashMap<K, V>"}],"shortDesc":"Combiner for an output port that emits object with Map<K,V> interface and has the processing done\n with round robin partition for a Sum metric, i.e","longDesc":"key,vals pairs need to be combined back together","displayName":"Unifier hash map sum keys"},{"name":"com.datatorrent.lib.util.UnifierKeyValRange","properties":[],"inputPorts":[],"outputPorts":[{"name":"mergedport","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.KeyValPair<K, com.datatorrent.lib.util.HighLow<V>>"}],"shortDesc":"Combiner for an output port that emits object with Map<K,ArrayList<V>(2)> interface and has the processing done\n with round robin partition","longDesc":"The first element in the ArrayList is high, the next is low","displayName":"Unifier key val range"},{"name":"com.datatorrent.lib.util.UnifierMap","properties":[],"inputPorts":[],"outputPorts":[{"name":"mergedport","optional":true,"error":false,"tupleType":"java.util.Map<K, V>"}],"shortDesc":"Combiner for an output port that emits object with Map<K,V> interface and has the processing done\n with sticky key partition, i.e","longDesc":"each one key belongs only to one partition. The final output of the\n combiner is a simple merge into a single object that implements Map","displayName":"Unifier map"},{"name":"com.datatorrent.lib.util.UnifierRange","properties":[],"inputPorts":[],"outputPorts":[{"name":"mergedport","optional":true,"error":false,"tupleType":"com.datatorrent.lib.util.HighLow<V>"}],"shortDesc":"cd\n Combiner for an output port that emits object with ArrayList<V>(2) interface and has the processing done\n with round robin partition","longDesc":"The first element in the ArrayList is high, the next is low","displayName":"Unifier range"},{"name":"com.datatorrent.lib.util.UnifierSumNumber","properties":[{"name":"VType","canGet":false,"canSet":true,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"},{"name":"name","canGet":true,"canSet":true,"type":"java.lang.String"},{"name":"type","canGet":true,"canSet":false,"type":"com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE"}],"inputPorts":[],"outputPorts":[{"name":"mergedport","optional":true,"error":false,"tupleType":"class java.lang.Number"}],"shortDesc":"Combiner for an output port that emits object with <V> interface and has the processing done\n with round robin partitioning","longDesc":"The final tuple is sum of all partition values","displayName":"Unifier sum number"}]}