{
   "operatorClasses" : [
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port on which tuples are received.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.AllAfterMatchMap",
         "tags" : [
            "filter",
            "compare",
            "numeric",
            "key value"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator takes Maps, whose values are numbers, as input tuples.&nbsp;\n It then performs a numeric comparison on the values corresponding to one of the keys in the input tuple maps.&nbsp;\n All tuples processed by the operator before the first successful comparison are not output by the operator,\n all tuples processed by the operator after and including a successful comparison are output by the operator",
         "longDesc" : "\n <p>\n A compare metric is done on input tuple based on the property \"key\",\n \"value\", and \"cmp\" type. All tuples are emitted (inclusive) once a match is made.\n The comparison is done by getting double value from the Number.\n This module is a pass through<br>\n <br>\n <b> StateFull : Yes, </b> Count is aggregated over application window(s). <br>\n <b> Partitions : No, </b> will yield wrong result. <br>\n <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>allafter</b>: emits Map&lt;K,V extends Number&gt; if compare function\n returns true<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\",\n \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\",\n \"gte\"<br>\n <b>Specific run time checks</b>: None<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "allafter",
               "optional" : true,
               "description" : "The output port on which all tuples after a match are emitted.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "displayName" : "Emit All After Match (Number)"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port on which tuples are received.",
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.AllAfterMatchStringValueMap",
         "tags" : [
            "filter",
            "compare",
            "numeric",
            "key value",
            "string"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator takes Maps, whose values are numeric strings, as input tuples.&nbsp;\n It then performs a numeric comparison on the values corresponding to one of the keys in the input tuple maps.&nbsp;\n All tuples processed by the operator before the first successful comparison are not output by the operator,\n all tuples processed by the operator after and including a successful comparison are output by the operator",
         "longDesc" : "\n <p>\n A compare metric is done on input tuple based on the property \"key\",\n \"value\", and \"cmp\". All tuples are emitted (inclusive) once a match is made.\n The comparison is done by getting double value from the Number.\n </p>\n <p>\n This module is a pass through<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map<K, String><br>\n <b>allafter</b>: emits HashMap<K, String> if compare function returns true<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\",\n \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\",\n \"gte\"<br>\n <br>\n <b>Specific run time checks</b>:<br>\n The key exists in the HashMap<br>\n Value converts to Double successfully<br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "allafter",
               "optional" : true,
               "description" : "The output port on which all tuples after a match are emitted.",
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "displayName" : "Emit All After Match (String)"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "This is the input port that receives key value pairs.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.BottomNMap",
         "tags" : [
            "filter",
            "rank",
            "key value"
         ],
         "properties" : [
            {
               "name" : "ascending",
               "type" : "boolean",
               "canSet" : false,
               "description" : "false",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "n",
               "type" : "int",
               "canSet" : true,
               "description" : "n",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator takes an input stream of key value pairs is ordered by key,\n and the bottom N of the ordered tuples per key are emitted on port \"bottom\" at the end of window",
         "longDesc" : " <p>\n Input stream of key value pairs is ordered by key, and bottom N of the\n ordered tuples per key are emitted on port \"bottom\" at the end of window\n </p>\n <p>\n This is an end of window operator. At the end of window all data is flushed.\n Thus the data set is windowed and no history is kept of previous windows<br>\n The operator assumes that the key, val pairs in the incoming tuple is\n immutable. If the tuple is mutable users should override cloneKey(), and\n cloneValue()<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V&gt;<br>\n <b>bottom</b>: emits HashMap&lt;K, ArrayList&lt;V&gt;&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>N</b>: The number of top values to be emitted per key<br>\n <br>\n <b>Specific compile time checks are</b>:<br>\n N: Has to be >= 1<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "bottom",
               "optional" : true,
               "description" : "The output port on which the bottom N tuples for each key are emitted.",
               "tupleType" : "java.util.HashMap<K, java.util.ArrayList<V>>"
            }
         ],
         "displayName" : "Bottom N"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "This is the input port that receives key value pairs.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.BottomNUniqueMap",
         "tags" : [
            "filter",
            "rank",
            "unique",
            "key value"
         ],
         "properties" : [
            {
               "name" : "ascending",
               "type" : "boolean",
               "canSet" : false,
               "description" : "false",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "n",
               "type" : "int",
               "canSet" : true,
               "description" : "n",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator takes an input stream of key value pairs,\n orders them by key, and the bottom N of the ordered unique tuples per key are emitted on port \"top\" at the end of window",
         "longDesc" : " <p>\n Input stream of key value pairs are ordered by key, and bottom N of the ordered unique tuples per key are emitted on\n port \"top\" at the end of window\n </p>\n <p>\n This is an end of window module<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V&gt;<br>\n <b>bottom</b>: emits HashMap&lt;K, ArrayList&lt;HashMap&lt;V,Integer&gt;&gt;&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>N</b>: The number of top values to be emitted per key<br>\n <br>\n <b>Specific compile time checks are</b>:<br>\n N: Has to be >= 1<br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "bottom",
               "optional" : true,
               "description" : "The output port on which the unique bottom n tuples per key are emitted.",
               "tupleType" : "java.util.HashMap<K, java.util.ArrayList<java.util.HashMap<V, java.lang.Integer>>>"
            }
         ],
         "displayName" : "Bottom N Unifier Map"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port which receives incoming key value pairs.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.CompareExceptCountMap",
         "tags" : [
            "count",
            "key value"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator produces a count of how many tuples of value type Number satisfy and do not satisfy a specified compare function",
         "longDesc" : " <p>\n A count is done on how many tuples of value type Number satisfy the compare function. The function is given by\n \"key\", \"value\", and \"cmp\". If a tuple passed the test count is incremented. On end of window count is emitted on the output port \"count\".\n The comparison is done by getting double value from the Number.\n </p>\n <p>\n This module is an end of window module. If no tuple comes in during a window 0 is emitted on both ports, thus no matter what one Integer\n tuple is emitted on each port<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s). <br>\n <b>Partitions : Yes, </b> count is unified at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>count</b>: emits Integer<br>\n <b>except</b>: emits Integer<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "description" : "The output port on which the number of tuples satisfying the compare function is emitted.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "except",
               "optional" : true,
               "description" : "The output port on which the number of tuples not satisfying the compare function is emitted.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "description" : "The output port which emits filtered key value pairs.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "displayName" : "Count All Who Don't Compare Generic"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port which receives incoming key value pairs.",
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.CompareExceptCountStringMap",
         "tags" : [
            "count",
            "key value",
            "string"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "emitError",
               "type" : "boolean",
               "canSet" : true,
               "description" : "emitError",
               "canGet" : true
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator produces a count of how many tuples of value type String satisfy the compare function",
         "longDesc" : " <p>\n A count is done on how many tuples of value type String satisfy the compare function. The function is given by\n \"key\", \"value\", and \"compare\". If a tuple passed the test count is incremented. On end of window count is emitted on the output port \"count\".\n The comparison is done by getting double value from the Number.\n </p>\n <p>\n This module is an end of window module. If no tuple comes in during a window 0 is emitted on both ports, thus no matter what one Integer\n tuple is emitted on each port<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s). <br>\n <b>Partitions : Yes, </b> count is unified at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,String&gt;<br>\n <b>count</b>: emits Integer<br>\n <b>except</b>: emits Integer<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "description" : "The output port on which the number of tuples satisfying the compare function is emitted.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "except",
               "optional" : true,
               "description" : "The output port on which the number of tuples not satisfying the compare function is emitted.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "description" : "The output port which emits filtered key value pairs.",
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "displayName" : "Count All Who Don't Compare String"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port on which key value pairs are received.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.DistinctMap",
         "tags" : [
            "filter",
            "unique",
            "key value"
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator computes and emits distinct key,val pairs (i.e drops duplicates)",
         "longDesc" : " <p>\n Computes and emits distinct key,val pairs (i.e drops duplicates)\n </p>\n <p>\n This is a pass through operator<br>\n <br>\n This module is same as a \"FirstOf\" metric on any key,val pair. At end of window all data is flushed.<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s). <br>\n <b>Partitions : Yes, </b> distinct output is unified by unifier hash map operator. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Input data port expects Map&lt;K,V&gt;<br>\n <b>distinct</b>: Output data port, emits HashMap&lt;K,V&gt;(1)<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "distinct",
               "optional" : true,
               "description" : "The output port on which distinct key value pairs are emitted.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "displayName" : "Emit Distinct Keyval Pairs"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port on which key value pairs are received.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.FilterKeyVals",
         "tags" : [
            "filter",
            "key value"
         ],
         "properties" : [
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "inverse",
               "canGet" : true
            },
            {
               "name" : "keyVals",
               "type" : "java.util.HashMap",
               "canSet" : true,
               "description" : "keyvals hash",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "empty",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of tuples using a set of specified key value pairs.&nbsp;\n Tuples that match the filter are emitted by the operator",
         "longDesc" : " <p>\n Filters the incoming stream based of specified key,val pairs, and emits those that match the filter. If\n property \"inverse\" is set to \"true\", then all key,val pairs except those specified by in keyvals parameter are emitted\n </p>\n <p>\n Operator assumes that the key, val pairs are immutable objects. If this operator has to be used for mutable objects,\n override \"cloneKey()\" to make copy of K, and \"cloneValue()\" to make copy of V.<br>\n This is a pass through node<br>\n <br>\n <b>StateFull : No, </b> tuple are processed in current window. <br>\n <b>Partitions : Yes, </b> no dependency among input tuples. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects HashMap&lt;K,V&gt;<br>\n <b>filter</b>: emits HashMap&lt;K,V&gt;(1)<br>\n <br>\n <b>Properties</b>:<br>\n <b>keyvals</b>: The keyvals is key,val pairs to pass through, rest are filtered/dropped.<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "filter",
               "optional" : true,
               "description" : "The output port on which filtered key value pairs are emitted.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "displayName" : "Filter Keyval Pairs"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port on which key value pairs are received.",
               "tupleType" : "java.util.Map<K, java.util.HashMap<K, V>>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.FilterKeysHashMap",
         "tags" : [
            "filter",
            "key value"
         ],
         "properties" : [
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "inverse",
               "canGet" : true
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "keys",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs based on the keys specified by property \"keys\"",
         "longDesc" : " <p>\n Filters the incoming stream based of keys specified by property \"keys\". If\n property \"inverse\" is set to \"true\", then all keys except those specified by \"keys\" are emitted\n </p>\n <p>\n Operator assumes that the key, val pairs are immutable objects. If this operator has to be used for mutable objects,\n override \"cloneKey()\" to make copy of K, and \"cloneValue()\" to make copy of V.<br>\n This is a pass through node.<br>\n <br>\n <b>StateFull : No, </b> tuple are processed in current window. <br>\n <b>Partitions : Yes, </b> no dependency among input tuples. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Expects Map&lt;K, HashMap&lt;K,V&gt;&gt. Filters are applied only on keys of second hash map.<br>\n <b>filter</b>: Emits HashMap&lt;K, HashMap&lt;K,V&gt;&gt.<br>\n <br>\n <b>Properties</b>:<br>\n <b>keys</b>: The keys to pass through, rest are filtered/dropped. A comma separated list of keys.<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "filter",
               "optional" : true,
               "description" : "The output port on which filtered key value pairs are emitted.",
               "tupleType" : "java.util.HashMap<K, java.util.HashMap<K, V>>"
            }
         ],
         "displayName" : "Filter Keyval Pairs By Key HashMap"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port on which key value pairs are received.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.FilterKeysMap",
         "tags" : [
            "filter",
            "key value"
         ],
         "properties" : [
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "inverse",
               "canGet" : true
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "keys",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs based on the keys specified by property \"keys\".",
         "longDesc" : " <p>\n Filters the incoming stream based of keys specified by property \"keys\". If\n property \"inverse\" is set to \"true\", then all keys except those specified by \"keys\" are emitted\n </p>\n <p>\n Operator assumes that the key, val pairs are immutable objects. If this operator has to be used for mutable objects,\n override \"cloneKey()\" to make copy of K, and \"cloneValue()\" to make copy of V.<br>\n This is a pass through node<br>\n <br>\n <b>StateFull : No, </b> tuple are processed in current window. <br>\n <b>Partitions : Yes, </b> no dependency among input tuples. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Expects Map&lt;K,V&gt;<br>\n <b>filter</b>: Emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>keys</b>: The keys to pass through, rest are filtered/dropped. A comma separated list of keys<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "filter",
               "optional" : true,
               "description" : "The output port on which filtered key value pairs are emitted.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "displayName" : "Filter Keyval Pairs By Key Generic"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port on which tuples are recieved.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.algo.FilterValues",
         "tags" : [
            "filter"
         ],
         "properties" : [
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "inverse",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "java.lang.Object",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "values",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of values by the specified set of filter values",
         "longDesc" : " <p>\n Filters incoming stream and emits values as specified by the set of values to filter. If\n property \"inverse\" is set to \"true\", then all keys except those specified by \"keys\" are emitted. The values are expected to be immutable.\n </p>\n <p>\n This operator should not be used with mutable objects. If this operator has immutable Objects, override \"cloneCopy\" to ensure a new copy is sent out.\n This is a pass through node<br>\n <br>\n <b>StateFull : No, </b> tuple are processed in current window. <br>\n <b>Partitions : Yes, </b> no dependency among input tuples. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expect T (a POJO)<br>\n <b>filter</b>: emits T (a POJO)<br>\n <br>\n <b>Properties</b>:<br>\n <b>keys</b>: The keys to pass through. Those not in the list are dropped. A comma separated list of keys<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "filter",
               "optional" : true,
               "description" : "The output port on which tuples satisfying the filter are emitted.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "displayName" : "Filter Values"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The port on which key value pairs are received.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.FirstMatchMap",
         "tags" : [
            "filter",
            "key value",
            "numeric"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs by obtaining the values corresponding to a specified key,\n and comparing those values to a specified number.&nbsp;The first key value pair, in each window, to satisfy the comparison is emitted",
         "longDesc" : " <p>\n A compare metric on a Number tuple based on the property \"key\", \"value\", and \"cmp\"; the first match is emitted.\n  The comparison is done by getting double value from the Number.\n </p>\n <p>\n This module is a pass through<br>\n The operators by default assumes immutable keys. If the key is mutable, use cloneKey to make a copy<br>\n <br>\n <b>StateFull : Yes, </b> tuple are processed in current window. <br>\n <b>Partitions : No, </b>will yield wrong results. <br>\n <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>first</b>: emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "first",
               "optional" : true,
               "description" : "The output port on which the first satisfying key value pair is emitted.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "displayName" : "Emit First Match (Number)"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The port on which key value pairs are received.",
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.FirstMatchStringMap",
         "tags" : [
            "filter",
            "key value",
            "string"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs by obtaining the values corresponding to a specified key,\n and comparing those values to a specified number.&nbsp;The first key value pair, in each window, to satisfy the comparison is emitted",
         "longDesc" : " <p>\n A compare metric on a tuple with value type String, based on the property \"key\", \"value\", and \"cmp\"; the first match is emitted. The comparison is done by getting double\n value from the Number.\n </p>\n <p>\n This module is a pass through<br>\n <br>\n <b>StateFull : Yes, </b> tuple are processed in current window. <br>\n <b>Partitions : No, </b>will yield wrong results. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,String&gt;><br>\n <b>first</b>: emits HashMap&lt;K,String&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "first",
               "optional" : true,
               "description" : "The output port on which the first satisfying key value pair is emitted.",
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "displayName" : "Emit First Match (String)"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "This is the input port that receives key value pairs.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.FirstN",
         "tags" : [
            "filter",
            "key value"
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "n",
               "type" : "int",
               "canSet" : true,
               "description" : "n",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs by emitting the first N key value pairs with a specified key in each window",
         "longDesc" : " <p>\n Emits first N tuples of a particular key.\n </p>\n <p>\n This module is a pass through module<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s). <br>\n <b>Partitions : No, </b> will yield wrong results. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Input data port expects HashMap&lt;K,V&gt;<br>\n <b>bottom</b>: Output data port, emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>N</b>: The number of top values to be emitted per key<br>\n <br>\n <b>Specific compile time checks are</b>:<br>\n N: Has to be >= 1<br>\n <br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "first",
               "optional" : true,
               "description" : "The output port on which the first N key value pairs are emitted.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "displayName" : "First N Keyval Pairs Matching Key"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port on which incoming key value pairs are received.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.FirstTillMatch",
         "tags" : [
            "filter",
            "key value",
            "numeric"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs by obtaining the values corresponding to a specified key,\n and comparing those values to a specified number.&nbsp;For each window, all key value pairs are emitted by the operator until a value satisfying the comparison is encountered",
         "longDesc" : " <p>\n All key.val pairs with val sub-classed from Number are emitted till the first match;  A compare metric is done based on the property \"key\",\n \"value\", and \"cmp\". Then on no tuple is emitted in that window. The comparison is done by getting double value of the Number.\n </p>\n <p>\n This module is a pass through<br>\n <br>\n <b>StateFull : Yes, </b> tuple are processed in current window. <br>\n <b>Partitions : No, </b>will yield wrong results. <br>\n <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Input port, expects HashMap&lt;K,V&gt;<br>\n <b>first</b>: Output port, emits HashMap&lt;K,V&gt; if compare function returns true<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "first",
               "optional" : true,
               "description" : "The output port on which key value pairs are emitted until the first match.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "displayName" : "Emit Keyval Pairs Until Match (Number)"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port on which incoming key value pairs are received.",
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.FirstTillMatchString",
         "tags" : [
            "filter",
            "key value",
            "string"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs by obtaining the values corresponding to a specified key,\n and comparing those values to a specified number.&nbsp;The first key value pair, in each window, to satisfy the comparison is emitted",
         "longDesc" : " <p>\n All key,val pairs with val of type String are emitted till the first match;  A compare metric is done based on the property \"key\", \"value\",\n and \"cmp\". Then on no tuple is emitted in that window. The comparison is done by getting double value of the Number.\n </p>\n <p>\n This module is a pass through<br>\n <br>\n <b>StateFull : Yes, </b> tuple are processed in current window. <br>\n <b>Partitions : No, </b>will yield wrong results. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Input port, expects HashMap&lt;K,String&gt;<br>\n <b>first</b>: Output port, emits HashMap&lt;K,String&gt; if compare function returns true<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n Compile time checks<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "first",
               "optional" : true,
               "description" : "The output port on which key value pairs are emitted until the first match.",
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "displayName" : "Emit Keyval Pairs Until Match (String)"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : true,
               "description" : "The input port on which individual tuples are received for sorting.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "name" : "datalist",
               "optional" : true,
               "description" : "The input port on which lists of tuples are received for sorting.",
               "tupleType" : "java.util.ArrayList<K>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.InsertSortDesc",
         "tags" : [
            "rank"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "size",
               "type" : "int",
               "canSet" : true,
               "description" : "size",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator takes the values it recieves each window and outputs them in ascending order at the end of each window",
         "longDesc" : " <p>\n Incoming tuple is inserted into already existing sorted list in a descending order. At the end of the window the resultant sorted list is emitted on the output ports.\n </p>\n <p>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s). <br>\n <b>Partitions : No, </b> will yield wrong results. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects K<br>\n <b>datalist</b>: expects ArrayList&lt;K&gt;<br>\n <b>sortlist</b>: emits ArrayList&lt;K&gt;<br>\n <b>sorthash</b>: emits HashMap&lt;K,Integer&gt;<br>\n <br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "sort",
               "optional" : true,
               "description" : "The output port on which a sorted descending list of tuples is emitted.",
               "tupleType" : "java.util.ArrayList<K>"
            },
            {
               "error" : false,
               "name" : "sorthash",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            }
         ],
         "displayName" : "Sort Descending"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port on which key value pairs are received.",
               "tupleType" : "java.util.HashMap<K, java.util.ArrayList<V>>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.InvertIndexArray",
         "tags" : [
            "key value"
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator takes a stream of key value pairs each window,\n and outputs a set of inverted key value pairs at the end of each window.&nbsp;\n The values in the key value pairs received by this operator are an array lists, which may multiple values",
         "longDesc" : " <p>\n Inverts the index and sends out the tuple on output port \"index\" at the end of the window.\n </p>\n <p>\n This is an end of window operator<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s). <br>\n <b>Partitions : Yes, </b> inverted indexes are unified by instance of same operator. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects HashMap&lt;K,ArrayList&lt;V&gt;&gt;<br>\n <b>index</b>: emits HashMap&lt;V,ArrayList&lt;K&gt;&gt;(1), one HashMap per V<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "index",
               "optional" : true,
               "description" : "The output port or which inverted key value pairs are emitted.",
               "tupleType" : "java.util.HashMap<V, java.util.ArrayList<K>>"
            }
         ],
         "displayName" : "Invert Keyval Pairs (Array)"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port on which key value pairs are received.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.LastMatchMap",
         "tags" : [
            "filter",
            "key value",
            "numeric"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs by obtaining the values corresponding to a specified key,\n and comparing those values to a specified number.&nbsp;The last key value pair, in each window, to satisfy the comparison is emitted",
         "longDesc" : " <p>\n A compare function is  operated on a tuple value sub-classed from Number based on the property \"key\", \"value\", and \"cmp\". Every tuple\n is checked and the last one that passes the condition is send during end of window on port \"last\". The comparison is done by getting double\n value from the Number.\n </p>\n <p>\n This module is an end of window module<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s). <br>\n <b>Partitions : No, </b> will yield wrong result. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>last</b>: emits Map&lt;K,V&gt; in end of window for the last tuple on which the compare function is true<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "last",
               "optional" : true,
               "description" : "The output port on which the last key value pair to satisfy the comparison function is emitted.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "displayName" : "Emit Last Match (Number)"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port on which key value pairs are received.",
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.LastMatchStringMap",
         "tags" : [
            "filter",
            "key value",
            "string"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs by obtaining the values corresponding to a specified key,\n and comparing those values to a specified number.&nbsp;The last key value pair, in each window, to satisfy the comparison is emitted",
         "longDesc" : " <p>\n A compare function is operated on a tuple value of type String based on the property \"key\", \"value\", and \"cmp\". Every tuple\n is checked and the last one that passes the condition is send during end of window on port \"last\". The comparison is done by getting double\n value from the Number.\n <p>\n This module is an end of window module<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s). <br>\n <b>Partitions : No, </b> will yield wrong result. <br>\n <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,String&gt;<br>\n <b>last</b>: emits HashMap&lt;K,String&gt; in end of window for the last tuple on which the compare function is true<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "last",
               "optional" : true,
               "description" : "The output port on which the last key value pair to satisfy the comparison function is emitted.",
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "displayName" : "Emit Last Match (Number)"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port on which tuples are received.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.algo.LeastFrequentKey",
         "tags" : [
            "filter",
            "count"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of values by emitting the value or values (if there is a tie)\n that occurred the fewest number of times within each window to the output port \"list\".&nbsp;\n One of the values is emitted to the output port \"least\" at the end of each window",
         "longDesc" : " <p>\n Occurrences of each tuple is counted and at the end of window any of the least frequent tuple is emitted on output port 'least'\n All keys with same least frequency value least are emitted on output port 'list'.<br>\n This module is an end of window module<br>\n In case of a tie any of the least key would be emitted. The list port would however have all the tied keys\n <br>\n <b>StateFull : Yes, </b> tuple are compared across application window(s). <br>\n <b>Partitions : Yes, </b> least keys are unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects K<br>\n <b>least</b>: emits HashMap&lt;K,Integer&gt;(1), Where K is the least occurring key in the window.\n               In case of tie any of the least key would be emitted<br>\n <b>list</b>: emits ArrayList&lt;HashMap&lt;K,Integer&gt;(1)&gt, Where the list includes all the keys that are least frequent<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "least",
               "optional" : true,
               "description" : "The output port on which one of the tuples,\n which occurred the least number of times,\n is emitted.",
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "list",
               "optional" : true,
               "description" : "The output port on which all the tuples,\n which occurred the least number of times,\n is emitted.",
               "tupleType" : "java.util.ArrayList<java.util.HashMap<K, java.lang.Integer>>"
            }
         ],
         "displayName" : "Emit Least Frequent Value"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port on which key value pairs are received.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.LeastFrequentKeyMap",
         "tags" : [
            "filter",
            "key value",
            "count"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs by finding the key or keys (if there is a tie) that occur the fewest number of times within each window.&nbsp;\n A list of the corresponding key value pairs are then output to the port named \"list\" and one of the corresponding key value pairs is output to the port \"least\", at the end of each window",
         "longDesc" : " <p>\n Occurrences of each key is counted and at the end of window any of the least frequent key is emitted on output port least and all least frequent\n keys on output port list.\n </p>\n <p>\n This module is an end of window module. In case of a tie any of the least key would be emitted. The list port would however have all the tied keys<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compared across application window(s). <br>\n <b>Partitions : Yes, </b> least keys are unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V&gt;, V is ignored/not used<br>\n <b>least</b>: emits HashMap&lt;K,Integer&gt;(1); where String is the least frequent key, and Integer is the number of its occurrences in the window<br>\n <b>list</b>: emits ArrayList&lt;HashMap&lt;K,Integer&gt;(1)&gt;; Where the list includes all the keys are least frequent<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "least",
               "optional" : true,
               "description" : "The output port on which one of the tuples,\n which occurred the least number of times,\n is emitted.",
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "list",
               "optional" : true,
               "description" : "The output port on which all the tuples,\n which occurred the least number of times,\n is emitted.",
               "tupleType" : "java.util.ArrayList<java.util.HashMap<K, java.lang.Integer>>"
            }
         ],
         "displayName" : "Emit Least Frequent Key"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "This is the input port which receives key value pairs.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.LeastFrequentKeyValueMap",
         "tags" : [
            "filter",
            "key value",
            "count"
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs by finding the value or values (if there is a tie),\n for each key, that occur the fewest number of times within each window.&nbsp;\n Each key and its corresponding least values are emitted at the end of each window",
         "longDesc" : " <p>\n Occurrences of all values for each key is counted and at the end of window the least frequent values are emitted on output port least per key.\n </p>\n <p>\n This module is an end of window module<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V&gt;<br>\n <b>least</b>: Output port, emits HashMap&lt;K,HashMap&lt;V,Integer&gt;&gt;(1)<br>\n <br>\n <b>Properties</b>: None<br>\n <br>\n <b>Compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None <br>\n <br>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Benchmark table for LeastFrequentKeyValueMap&lt;K,V&gt; operator template\">\n <tr><th>In-Bound</th><th>Out-bound</th><th>Comments</th></tr>\n <tr><td><b>&gt; 30 Million K,V pairs/s</b></td><td>Emits only 1 tuple per window per key</td><td>In-bound throughput is the main determinant of performance.\n The benchmark was done with immutable objects. If K or V are mutable the benchmark may be lower</td></tr>\n </table><br>\n </p>\n <p>\n <b>Function Table (K=String,V=Integer);</b>:\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Function table for LeastFrequentKeyValueMap&lt;K,V&gt; operator template\">\n <tr><th rowspan=2>Tuple Type (api)</th><th>In-bound (process)</th><th>Out-bound (emit)</th></tr>\n <tr><th><i>data</i>(Map&lt;K,V&gt;)</th><th><i>least</i>(HashMap&lt;K,HashMap&lt;Integer&gt;&gt;)</th></tr>\n <tr><td>Begin Window (beginWindow())</td><td>N/A</td><td>N/A</td></tr>\n <tr><td>Data (process())</td><td>{a=1,b=5,c=110}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=55,c=2000,b=45}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{d=2}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=55,b=5,c=22}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{h=20,a=2,z=5}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=4,c=110}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=4,z=5}</td><td></td></tr>\n <tr><td>End Window (endWindow())</td><td>N/A</td><td>{a={1=1,2=1},b={45=1},c={2000=1,22=1},d={2=1},h={20=1},z={5=2}</td></tr>\n </table>\n <br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "least",
               "optional" : true,
               "description" : "The output port on which the least frequent key value pairs are emitted.",
               "tupleType" : "java.util.HashMap<K, java.util.HashMap<V, java.lang.Integer>>"
            }
         ],
         "displayName" : "Emit Lest Frequent Keyval Pair"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port on which key value pairs are received.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MatchAllMap",
         "tags" : [
            "filter",
            "key value"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs by obtaining the values corresponding to a specified key,\n and comparing those values to a specified number.&nbsp;\n If the comparison returns true for all key value pairs within a window, then a true is emitted at the end of the window.&nbsp;\n Otherwise a false is emitted at the end of the window",
         "longDesc" : " <p>\n Each tuple is tested for the compare function. The function is given by\n \"key\", \"value\", and \"cmp\". If all tuples passes a Boolean(true) is emitted, else a Boolean(false) is emitted on end of window on the output port \"all\".\n The comparison is done by getting double value from the Number.\n </p>\n <p>\n This module is an end of window module<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compared across application window(s). <br>\n <b>Partitions : Yes, </b> match status is unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>all</b>: emits Boolean<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "all",
               "optional" : true,
               "description" : "The output port on which true is emitted if all key value pairs satisfy the specified comparison function.",
               "tupleType" : "class java.lang.Boolean"
            }
         ],
         "displayName" : "Emit All Matching Values (Number)"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port on which key value pairs are received.",
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MatchAllStringMap",
         "tags" : [
            "filter",
            "key value"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs by obtaining the values corresponding to a specified key,\n and comparing those values to a specified number.&nbsp;\n If the comparison returns true for all key value pairs within a window,\n then a true is emitted at the end of the window.&nbsp;\n Otherwise a false is emitted at the end of the window",
         "longDesc" : " <p>\n Each tuple is tested for the compare function. The function is given by\n \"key\", \"value\", and \"cmp\". If all tuples passes a Boolean(true) is emitted, else a Boolean(false) is emitted on end of window on the output port \"all\".\n The comparison is done by getting double value from the Number.\n </p>\n <p>\n This module is an end of window module<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compared across application window(s). <br>\n <b>Partitions : Yes, </b> match status is unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,String&gt;<br>\n <b>all</b>: emits Boolean<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <b>Specific run time checks</b>: None<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "all",
               "optional" : true,
               "description" : "The output port on which true is emitted if all key value pairs satisfy the specified comparison function.",
               "tupleType" : "class java.lang.Boolean"
            }
         ],
         "displayName" : "Emit All Matching Values (String)"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port which receives key value pairs.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MatchAnyMap",
         "tags" : [
            "filter",
            "key value"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs by obtaining the values corresponding to a specified key,\n and comparing those values to a specified number.&nbsp;\n If the comparison returns true for any of the key value pairs within a window,\n then a true is emitted at the end of the window.&nbsp;\n Otherwise a false is emitted at the end of the window",
         "longDesc" : " <p>\n Each tuple is tested for the compare function. The function is given by\n \"key\", \"value\", and \"compare\". If any tuple passes a Boolean(true) is emitted, else a Boolean(false) is emitted on the output port \"any\".\n The comparison is done by getting double value from the Number.\n </p>\n <p>\n This module is a pass through as it emits the moment the condition is met<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compared across application window(s). <br>\n <b>Partitions : Yes, </b> match status is unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>any</b>: emits Boolean<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <b>Specific run time checks</b>: None<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "any",
               "optional" : true,
               "description" : "The output port that emits true at the end of an application window if any tuple satisfies the comparison.",
               "tupleType" : "class java.lang.Boolean"
            }
         ],
         "displayName" : "Emit Boolean For Match (Number)"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port which receives key value pairs.",
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MatchAnyStringMap",
         "tags" : [
            "filter",
            "key value",
            "string"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs by obtaining the values corresponding to a specified key,\n and comparing those values to a specified number.&nbsp;\n If the comparison returns true for any of the key value pairs within a window,\n then a true is emitted at the end of the window.&nbsp;Otherwise a false is emitted at the end of the window",
         "longDesc" : " <p>\n Each tuple is tested for the compare function. The function is given by\n \"key\", \"value\", and \"compare\". If any tuple passes a Boolean(true) is emitted, else a Boolean(false) is emitted on the output port \"any\".\n The comparison is done by getting double value from the Number.\n </p>\n <p>\n This module is a pass through as it emits the moment the condition is met<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compared across application window(s). <br>\n <b>Partitions : Yes, </b> match status is unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map<K,String><br>\n <b>any</b>: emits Boolean<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "any",
               "optional" : true,
               "description" : "The output port that emits true at the end of an application window if any tuple satisfies the comparison.",
               "tupleType" : "class java.lang.Boolean"
            }
         ],
         "displayName" : "Emit Boolean For Match (String)"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port which receives incoming key value pairs.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MatchMap",
         "tags" : [
            "filter",
            "key value",
            "numeric"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs by obtaining the values corresponding to a specified key,\n and comparing those values to a specified number.&nbsp;If a key value pair satisfies the comparison, then it is emitted",
         "longDesc" : " <p>\n A compare function is imposed based on the property \"key\", \"value\", and \"cmp\". If the tuple\n passed the test, it is emitted on the output port match. The comparison is done by getting double\n value from the Number. Both output ports are optional, but at least one has to be connected.\n </p>\n <p>\n This module is a pass through<br>\n <br>\n <b>StateFull : No, </b> tuple is processed in current application window. <br>\n <b>Partitions : Yes, </b> match status is unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>match</b>: emits HashMap&lt;K,V&gt<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "description" : "The output port which emits filtered key value pairs.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "displayName" : "Emit Matching Keval Pairs (Number)"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port which receives incoming key value pairs.",
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MatchStringMap",
         "tags" : [
            "filter",
            "key value",
            "string"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "emitError",
               "type" : "boolean",
               "canSet" : true,
               "description" : "emitError",
               "canGet" : true
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs by obtaining the values corresponding to a specified key,\n and comparing those values to a specified number.&nbsp;\n If a key value pair satisfies the comparison, then it is emitted",
         "longDesc" : " <p>\n A compare function is imposed based on the property \"key\", \"value\", and \"cmp\". If the tuple\n passed the test, it is emitted on the output port \"match\". The comparison is done by getting double\n value from the Number. Both output ports are optional, but at least one has to be connected.\n </p>\n <p>\n This module is a pass through<br>\n <br>\n <b>StateFull : No, </b> tuple is processed in current application window. <br>\n <b>Partitions : Yes, </b> match status is unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,String&gt;<br>\n <b>match</b>: emits HashMap&lt;K,String&gt; if compare function returns true<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "description" : "The output port which emits filtered key value pairs.",
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "displayName" : "Emit Matching Keyval Pairs (String)"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port which receives incoming tuples.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MostFrequentKey",
         "tags" : [
            "filter",
            "count"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of values by emitting the value or values (if there is a tie)\n that occurred the largest number of times within each window to the output port \"list\".&nbsp;\n One of the values is emitted to the output port \"least\" at the end of each window",
         "longDesc" : " <p>\n Occurrences of each tuple is counted and at the end of window any of the most frequent tuple is emitted on output port least and all least frequent\n tuples on output port list\n </p>\n <p>\n This module is an end of window module<br>\n In case of a tie any of the least key would be emitted. The list port would however have all the tied keys\n <br>\n  <b>StateFull : Yes</b>, Values are compared all over  application window can be > 1. <br>\n  <b>Partitions : Yes</b>, Result is unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects K<br>\n <b>most</b>: emits HashMap&lt;K,Integer&gt;(1), Where K is the least occurring key in the window. In case of tie any of the least key would be emitted<br>\n <b>list</b>: emits ArrayList&lt;HashMap&lt;K,Integer&gt;(1)&gt, Where the list includes all the keys that are least frequent<br>\n <br>\n <b>Properties</b>: None<br>\n <br>\n <b>Compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "list",
               "optional" : true,
               "tupleType" : "java.util.ArrayList<java.util.HashMap<K, java.lang.Integer>>"
            },
            {
               "error" : false,
               "name" : "most",
               "optional" : true,
               "description" : "The output port on which all the tuples,\n which occurred the most number of times,\n is emitted.",
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            }
         ],
         "displayName" : "Emit Most Frequent Value"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port which receives incoming key value pairs.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MostFrequentKeyMap",
         "tags" : [
            "filter",
            "key value",
            "count"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs by finding the key or keys (if there is a tie)\n that occur the largest number of times within each window.&nbsp;\n A list of the corresponding key value pairs are then output to the port named \"list\" and one of the corresponding key value pairs is output to the port \"most\", at the end of each window",
         "longDesc" : " <p>\n Occurrences of each key is counted and at the end of window any of the most frequent key is emitted on output port least and all least frequent\n keys on output port list.\n </p>\n <p>\n This module is an end of window module. In case of a tie any of the least key would be emitted. The list port would however have all the tied keys<br>\n <br>\n  <b>StateFull : Yes</b>, Values are compared all over  application window can be > 1. <br>\n  <b>Partitions : Yes</b>, Result is unified on output port. <br>\n  <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V&gt;, V is ignored/not used<br>\n <b>most</b>: emits HashMap&lt;K,Integer&gt;(1); where String is the least frequent key, and Integer is the number of its occurrences in the window<br>\n <b>list</b>: emits ArrayList&lt;HashMap&lt;K,Integer&gt;(1)&gt;; Where the list includes all the keys are least frequent<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "list",
               "optional" : true,
               "tupleType" : "java.util.ArrayList<java.util.HashMap<K, java.lang.Integer>>"
            },
            {
               "error" : false,
               "name" : "most",
               "optional" : true,
               "description" : "The output port on which all the tuples,\n which occurred the most number of times,\n is emitted.",
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            }
         ],
         "displayName" : "Emit Most Frequent Key"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "This is the input port which receives key value pairs.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MostFrequentKeyValueMap",
         "tags" : [
            "filter",
            "key value",
            "count"
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters the incoming stream of key value pairs by finding the value or values (if there is a tie),\n for each key, that occur the largest number of times within each window.&nbsp;\n Each key and its corresponding most values are emitted at the end of each window",
         "longDesc" : " <p>\n Occurrences of all values for each key is counted and at the end of window the most frequent values are emitted on output port least per key\n </p>\n <p>\n This module is an end of window module<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects HashMap&lt;K,V&gt;<br>\n <b>most</b>: emits HashMap&lt;String, HashMap&lt;String, Integer&gt;&gt;(1)<br>\n <br>\n <br>\n <b>Properties</b>: None<br>\n <br>\n <b>Compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None <br>\n <br>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Benchmark table for MostFrequentKeyValueMap&lt;K,V&gt; operator template\">\n <tr><th>In-Bound</th><th>Out-bound</th><th>Comments</th></tr>\n <tr><td><b>&gt; 30 Million K,V pairs/s</b></td><td>Emits only 1 tuple per window per key</td><td>In-bound throughput is the main determinant of performance.\n The benchmark was done with immutable objects. If K or V are mutable the benchmark may be lower</td></tr>\n </table><br>\n </p>\n <p>\n <b>Function Table (K=String,V=Integer);</b>:\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Function table for MostFrequentKeyValueMap&lt;K,V&gt; operator template\">\n <tr><th rowspan=2>Tuple Type (api)</th><th>In-bound (process)</th><th>Out-bound (emit)</th></tr>\n <tr><th><i>data</i>(HashMap&lt;K,V&gt;)</th><th><i>most</i>(HashMap&lt;K,HashMap&lt;Integer&gt;&gt;)</th></tr>\n <tr><td>Begin Window (beginWindow())</td><td>N/A</td><td>N/A</td></tr>\n <tr><td>Data (process())</td><td>{a=1,b=5,c=110}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=55,c=2000,b=45}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{d=2}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=55,b=5,c=22}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{h=20,a=2,z=5}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=4,c=110}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=4,z=5}</td><td></td></tr>\n <tr><td>End Window (endWindow())</td><td>N/A</td><td>{a={4=2,55=2},b={5=2},c={110=2},d={2=1},h={20=1},z={5=2}</td></tr>\n </table>\n <br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "most",
               "optional" : true,
               "description" : "The output port which emits a map from keys to their most values.",
               "tupleType" : "java.util.HashMap<K, java.util.HashMap<V, java.lang.Integer>>"
            }
         ],
         "displayName" : "Emit Most Frequent Keyval Pair"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "An input port which receives incoming tuples.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "name" : "data1",
               "optional" : true,
               "description" : "An input port which receives incoming tuples.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.algo.PartitionableUniqueCount",
         "tags" : [
            "algorithm",
            "count",
            "key value"
         ],
         "properties" : [
            {
               "name" : "cumulative",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator counts the number of times a key exists in a window.&nbsp;\n A map from keys to counts is emitted at the end of each window",
         "longDesc" : " <p></p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "tupleType" : "com.datatorrent.lib.util.KeyHashValPair<K, java.lang.Integer>"
            }
         ],
         "displayName" : "Count Key Appearances"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "This is the input port which receives tuples.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.algo.Sampler",
         "tags" : [
            "filter"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "passrate",
               "type" : "int",
               "canSet" : true,
               "description" : "passrate",
               "canGet" : true
            },
            {
               "name" : "totalrate",
               "type" : "int",
               "canSet" : true,
               "description" : "totalrate",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator takes a stream of tuples as input, and emits each tuple with a specified probability",
         "longDesc" : " <p>\n Emits the tuple as per probability of pass rate out of total rate. <br>\n <br>\n An efficient filter to allow sample analysis of a stream. Very useful is the incoming stream has high throughput.\n </p>\n <p>\n <br>\n <b> StateFull : No, </b> tuple is processed in current window. <br>\n <b> Partitions : Yes. </b> No state dependency among input tuples. <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects K<br>\n <b>sample</b>: emits K<br>\n <br>\n <b>Properties</b>:<br>\n <b>passrate</b>: Sample rate out of a total of totalrate. Default is 1<br>\n <b>totalrate</b>: Total rate (divisor). Default is 100<br>\n <br>\n <b>Specific compile time checks are</b>: None<br>\n passrate is positive integer<br>\n totalrate is positive integer<br>\n passrate and totalrate are not compared (i.e. passrate &lt; totalrate) check is not done to allow users to make this operator a passthrough (all) during testing<br>\n <br>\n <b>Specific run time checks are</b>: None<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "sample",
               "optional" : true,
               "description" : "This is the output port which emits the sampled tuples.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "displayName" : "Sampler"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "This is the input port that receives key value pairs.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.TopNUnique",
         "tags" : [
            "filter",
            "rank"
         ],
         "properties" : [
            {
               "name" : "ascending",
               "type" : "boolean",
               "canSet" : false,
               "description" : "true",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "n",
               "type" : "int",
               "canSet" : true,
               "description" : "n",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator orders tuples per key and emits the top N unique tuples per key at the end of the window",
         "longDesc" : " <p>\n Orders tuples per key and emits top N unique tuples per key on end of window.\n </p>\n <p>\n This is an end of window module<br>\n At the end of window all data is flushed. Thus the data set is windowed and no history is kept of previous windows<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Input data port expects HashMap&lt;K,V&gt;<br>\n <b>top</b>: Output data port, emits HashMap&lt;K, ArrayList&lt;V&gt;&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>N</b>: The number of top values to be emitted per key<br>\n <br>\n <b>Specific compile time checks are</b>:<br>\n N: Has to be >= 1<br>\n <br>\n <b>Specific run time checks are</b>: None<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "top",
               "optional" : true,
               "description" : "The output port which emits the top N unique values per key.",
               "tupleType" : "java.util.HashMap<K, java.util.ArrayList<java.util.HashMap<V, java.lang.Integer>>>"
            }
         ],
         "displayName" : "Top N Unique Values Per Key"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port which receives incoming tuples.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.algo.UniqueCounter",
         "tags" : [
            "count"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator counts the number of times a key exists in a window.&nbsp;A map from keys to counts is emitted at the end of each window",
         "longDesc" : " <p>\n Counts the number of times a key exists in a window; Count is emitted at end of window in a single HashMap.\n </p>\n <p>\n This is an end of window operator<br>\n <br>\n <b>StateFull : yes, </b> Tuples are aggregated over application window(s). <br>\n <b>Partitions : Yes, </b> Unique count is unified at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects K<br>\n <b>count</b>: emits HashMap&lt;K,Integer&gt;<br>\n <b>Properties</b>: None<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "description" : "The output port which emits a map from keys to the number of times they occurred within an application window.",
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            }
         ],
         "displayName" : "Count Unique Keys"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port that receives key value pairs.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.UniqueKeyValCounter",
         "tags" : [
            "count",
            "key value"
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator counts the unique occurrences of key value pairs within each window,\n and emits a map from key value pairs to counts at the end of each window",
         "longDesc" : " <p>\n Count unique occurrences of key,val pairs within a window, and emits one HashMap tuple.\n </p>\n <p>\n This is an end of window operator<br>\n <br>\n <b>StateFull : yes, </b> Tuples are aggregated over application window(s). <br>\n <b>Partitions : Yes, </b> Unique count is unified at output port. <br>\n <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects HashMap&lt;K,V&gt;<br>\n <b>count</b>: emits HashMap&lt;HashMap&lt;K,V&gt;(1),Integer&gt;(1)<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "description" : "The output port which emits key/unique value count pairs.",
               "tupleType" : "java.util.HashMap<java.util.HashMap<K, V>, java.lang.Integer>"
            }
         ],
         "displayName" : "Count Unique Keyval Pairs"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "The input port that receives key value pairs.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.UniqueValueCount",
         "tags" : [
            "count",
            "key value"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator counts the number of unique values corresponding to a key within a window.&nbsp;\n At the end of each window each key, its count of unique values, and its set of unique values is emitted",
         "longDesc" : " <p>\n Counts no. of unique values of a key within a window.<br>\n Emits {@link InternalCountOutput} which contains the key, count of its unique values.<br>\n When the operator is partitioned, the unifier uses the internal set of values to\n compute the count of unique values again.<br>\n <br>\n Partitions: yes, uses {@link UniqueCountUnifier} to merge partitioned output.<br>\n Stateful: no<br>\n <br></br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "description" : "The output port which emits key/unique value count pairs.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>"
            }
         ],
         "displayName" : "Unique Values Per Key"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port which receives key value pairs.",
               "tupleType" : "java.util.Map<K, ?>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.UniqueValueMap",
         "tags" : [
            "count",
            "key value"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator counts the number of unique values corresponding to a key within a window.&nbsp;\n At the end of each window each key/unique count pair is emitted",
         "longDesc" : " <p>\n Count unique occurrences of vals for every key within a window, and emits Key,Integer pairs tuple.\n </p>\n <p>\n This is an end of window operator. It uses sticky key partition and default unifier<br>\n <br>\n <b>StateFull : Yes, </b> Tuple are aggregated across application window(s). <br>\n <b>Partitions : Yes, </b> Top values are unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V&gt;<br>\n <b>count</b>: emits HashMap&lt;K,Integer&gt;<br>\n <br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "description" : "The output port which emits key/unique value count pairs.",
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            }
         ],
         "displayName" : "Count Unique Values Per Key (Map)"
      },
      {
         "inputPorts" : [
            {
               "name" : "in1",
               "optional" : false,
               "description" : "The input port on which tuples for plotting are received.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.chart.TimeSeriesAverageChartOperator",
         "tags" : [
            "output operator"
         ],
         "properties" : [
            {
               "name" : "chartType",
               "type" : "com.datatorrent.lib.chart.ChartOperator$Type",
               "canSet" : false,
               "description" : "The chart type",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "xAxisLabel",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "yAxisLabel",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "yNumberType",
               "type" : "com.datatorrent.lib.chart.XYChartOperator$NumberType",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This is a chart operator that plots the average value for each window",
         "longDesc" : " <p>\n This is the chart operator that plots the average (mean) value of Y for each window.  X will be based on the timestamp derived from the window id\n </p>",
         "category" : "Charting",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "chart",
               "optional" : true,
               "description" : "The output port of the chart operator.  The data of this will be shipped to the module that draws the chart.",
               "tupleType" : "java.util.Map<K, java.util.Map<X, Y>>"
            }
         ],
         "displayName" : "Time Series Average Chart"
      },
      {
         "inputPorts" : [
            {
               "name" : "in1",
               "optional" : false,
               "description" : "The input port on which tuples for plotting are received.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.chart.TimeSeriesCandleStickChartOperator",
         "tags" : [
            "output operator"
         ],
         "properties" : [
            {
               "name" : "chartType",
               "type" : "com.datatorrent.lib.chart.ChartOperator$Type",
               "canSet" : false,
               "description" : "The chart type",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "xAxisLabel",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "yAxisLabel",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "yNumberType",
               "type" : "com.datatorrent.lib.chart.XYChartOperator$NumberType",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This is a chart operator that produces a candlestick plot out of values",
         "longDesc" : " <p>\n This is the chart operator that plots the candle stick of Y for each window.  X will be based on the timestamp derived from the window id\n </p>",
         "category" : "Charting",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "chart",
               "optional" : true,
               "description" : "The output port of the chart operator.  The data of this will be shipped to the module that draws the chart.",
               "tupleType" : "java.util.Map<K, java.util.Map<X, Y>>"
            }
         ],
         "displayName" : "Time Series Candle Stick Chart"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.ApacheGenRandomLogs",
         "tags" : [
            "log",
            "input operator",
            "generate"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "Generates apache server log entries",
         "longDesc" : "The apache access log has the following\n format\n\n %s %h %l %u %t \"%r\" %s %b \"%{Referer}\" \"%{User-agent}\"\n\n %s - server name - server0.mydomain.com:80 .......................  server9.mydomain.com:80\n %h - The ip address of the client\n %l - The identity of the client typically \"-\"\n %u - The username of the user if HTTP authentication was used otherwise \"-\"\n %t - The time the request was received e.g., [31/May/2013:08:03:46 -0700]\n %r - The HTTP request string e.g., \"GET /favicon.ico HTTP/1.1\"\n %s - The status code of the response e.g., 404\n %b - The number of bytes in the response\n %{Referer} - The referer web site reported by the client, \"-\" if there is none\n %{User-agent} - Unique string identifying the client browser e.g.,\n \t\t\t\t\t\t\t\"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1468.0 Safari/537.36\"\n\n Putting it all together a sample log string looks like :\n --------------------------------------------------------\n 127.0.0.1 - [31/May/2013:09:05:49 -0700] \"GET /favicon.ico HTTP/1.1\" 304 210 \"-\"\n \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.22 (KHTML, like Gecko) Ubuntu Chromium/25.0.1364.160 Chrome/25.0.1364.160 Safari/537.22\"",
         "category" : "Input/Output",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "This is the output port which emits generated log strings.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "displayName" : "Generate Random Apache Logs"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "This input port which receives collection tuples.",
               "tupleType" : "java.util.Collection<E>"
            }
         ],
         "name" : "com.datatorrent.lib.io.CollectionMultiConsoleOutputOperator",
         "tags" : [
            "output operator"
         ],
         "properties" : [
            {
               "name" : "debug",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "silent",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This output operator receives collections as tuples.&nbsp;\n The contents of each collection is written out to the container's stdout",
         "longDesc" : " <p>\n This is for specific use case for collection where I want to print each key\n value pair in different line <br>\n Mainly to be used for debugging. Users should be careful to not have this\n node listen to a high throughput stream<br>\n <br>\n </p>",
         "category" : "Input/Output",
         "outputPorts" : [],
         "displayName" : "Container Stdout Output"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "This is the input port which receives the tuples that will be written to stdout.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.io.ConsoleOutputOperator",
         "tags" : [
            "output operator"
         ],
         "properties" : [
            {
               "name" : "debug",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "silent",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the silent",
               "canGet" : true
            },
            {
               "name" : "stringFormat",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "Writes tuples to stdout of the container",
         "longDesc" : " <p>\n Mainly to be used for debugging. Users should be careful to not have this node listen to a high throughput stream<br>\n <br>\n </p>",
         "category" : "Input/Output",
         "outputPorts" : [],
         "displayName" : "Console Output"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.FtpInputOperator",
         "tags" : [
            "ftp",
            "input operator"
         ],
         "properties" : [
            {
               "name" : "delay",
               "type" : "long",
               "canSet" : true,
               "description" : "the delay",
               "canGet" : true
            },
            {
               "name" : "filePath",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the filePath",
               "canGet" : true
            },
            {
               "name" : "ftpServer",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the ftpServer",
               "canGet" : true
            },
            {
               "name" : "gzip",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the isGzip",
               "canGet" : true
            },
            {
               "name" : "localPassiveMode",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the localPassiveMode",
               "canGet" : true
            },
            {
               "name" : "numberOfTuples",
               "type" : "int",
               "canSet" : true,
               "description" : "the numberOfTuples",
               "canGet" : true
            },
            {
               "name" : "password",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the password",
               "canGet" : true
            },
            {
               "name" : "port",
               "type" : "int",
               "canSet" : true,
               "description" : "the port",
               "canGet" : true
            },
            {
               "name" : "userName",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the userName",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator emits each line as different tuple for a give file hosted on a ftp server",
         "longDesc" : " <p>\n <b>Ports</b>:<br>\n <b>outport</b>: emits &lt;String&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>filePath</b> : Path for file to be read. <br>\n <b>delay</b>: Thread sleep interval after emitting line.<br>\n <b>numberOfTuples</b>: Number of tuples to be emitted in a single emit Tuple call.<br>\n <b>ftpServer</b>: The ftp server where the file is hosted.<br>\n <b>port</b>: Port of the ftp server.<br>\n <b>userName</b>: The user name used to login to ftp server. Default is anonymous.<br>\n <b>password</b>: The password used to login to ftp server.<br>\n <b>isGzip</b>: If the format of the file is gzip.<br>\n </p>",
         "category" : "Input/Output",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "description" : "This is the output port which emits tuples read from and FTP server.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "displayName" : "FTP Input"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "The input port which receives tuples for processing.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.io.HttpGetMapOperator",
         "tags" : [
            "http",
            "input operator"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "url",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "Operator to take in map of key value pairs and make a HTTP GET request with the key value pairs from the map\n as query parameters in the request",
         "longDesc" : " <p>\n If output port is connected, the response is emitted as {@link String} through the output port.\n </p>",
         "category" : "Input/Output",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "description" : "The output port which emits retrieved tuples.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "displayName" : "Http Get Map"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.HttpJsonChunksInputOperator",
         "tags" : [
            "http",
            "input operator"
         ],
         "properties" : [
            {
               "name" : "active",
               "type" : "boolean",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "url",
               "type" : "java.net.URI",
               "canSet" : true,
               "canGet" : false,
               "properties" : [
                  {
                     "name" : "absolute",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "authority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "fragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "host",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "opaque",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "path",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "port",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "query",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawAuthority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawFragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawPath",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawQuery",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawSchemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawUserInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "scheme",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "schemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "userInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            }
         ],
         "shortDesc" : "This operator reads in JSON data and outputs it as a map",
         "longDesc" : " <p>\n (entities on stream delimited by leading length)\n Incoming data is interpreted as JSONObject and converted to {@link java.util.Map}.<br>\n If second rawOutput is connected then content is streamed to this port as it is.\n <br>\n </p>",
         "category" : "Input/Output",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outputPort",
               "optional" : true,
               "description" : "The single output port of this input operator.\n Collects asynchronously emitted tuples and flushes in container thread.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "error" : false,
               "name" : "rawOutput",
               "optional" : true,
               "description" : "The output port which emits retrieved tuples.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "displayName" : "Http Json Chunks Input"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.HttpLinesInputOperator",
         "tags" : [
            "http",
            "input operator"
         ],
         "properties" : [
            {
               "name" : "active",
               "type" : "boolean",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "url",
               "type" : "java.net.URI",
               "canSet" : true,
               "canGet" : false,
               "properties" : [
                  {
                     "name" : "absolute",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "authority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "fragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "host",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "opaque",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "path",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "port",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "query",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawAuthority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawFragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawPath",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawQuery",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawSchemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawUserInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "scheme",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "schemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "userInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            }
         ],
         "shortDesc" : "Incoming data is interpreted as lines of plain text and each tuple output is a line in the content",
         "longDesc" : " <p></p>",
         "category" : "Input/Output",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outputPort",
               "optional" : true,
               "description" : "The single output port of this input operator.\n Collects asynchronously emitted tuples and flushes in container thread.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "error" : false,
               "name" : "rawOutput",
               "optional" : true,
               "description" : "The output port which emits retrieved tuples.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "displayName" : "Http Lines Input"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "The input port which receives tuples for processing.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.io.HttpOutputOperator",
         "tags" : [
            "http",
            "output operator"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "resourceURL",
               "type" : "java.net.URI",
               "canSet" : true,
               "canGet" : false,
               "properties" : [
                  {
                     "name" : "absolute",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "authority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "fragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "host",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "opaque",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "path",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "port",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "query",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawAuthority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawFragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawPath",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawQuery",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawSchemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawUserInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "scheme",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "schemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "userInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "url",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "Sends tuple as POST with JSON content to the given URL",
         "longDesc" : " <p>\n Data of type {@link java.util.Map} is converted to JSON. All other types are sent in their {@link Object#toString()} representation.<br>\n <br>\n </p>",
         "category" : "Input/Output",
         "outputPorts" : [],
         "displayName" : "Http Output"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "The input port which receives tuples for processing.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.io.HttpPostOutputOperator",
         "tags" : [
            "http",
            "output operator"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "url",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "Sends tuple as POST with JSON content to the given URL",
         "longDesc" : " <p>\n Data of type {@link java.util.Map} is converted to JSON. All other types are sent in their {@link Object#toString()} representation.<br>\n <br>\n </p>",
         "category" : "Input/Output",
         "outputPorts" : [],
         "displayName" : "Http Output"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.io.MapMultiConsoleOutputOperator",
         "tags" : [
            "output operator"
         ],
         "properties" : [
            {
               "name" : "debug",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "silent",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator writes tuples which are maps to standard out of the container",
         "longDesc" : " <p>\n This is for specific use case for map where I want to print each key value\n pair in different line <br>\n Mainly to be used for debugging. Users should be careful to not have this\n node listen to a high throughput stream<br>\n <br>\n </p>",
         "category" : "Input/Output",
         "outputPorts" : [],
         "displayName" : "Map Console Output"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.PubSubWebSocketInputOperator",
         "tags" : [
            "http",
            "input operator"
         ],
         "properties" : [
            {
               "name" : "active",
               "type" : "boolean",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "ioThreadMultiplier",
               "type" : "int",
               "canSet" : true,
               "description" : "the IO thread multiplier",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "uri",
               "type" : "java.net.URI",
               "canSet" : true,
               "description" : "the URI",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "absolute",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "authority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "fragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "host",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "opaque",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "path",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "port",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "query",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawAuthority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawFragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawPath",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawQuery",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawSchemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawUserInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "scheme",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "schemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "userInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            }
         ],
         "shortDesc" : "This operator reads JSON objects from the given URL and converts them into maps",
         "longDesc" : " <p></p>",
         "category" : "Input/Output",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outputPort",
               "optional" : true,
               "description" : "The single output port of this input operator.\n Collects asynchronously emitted tuples and flushes in container thread.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "displayName" : "Pub Sub Web Socket Input"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "The input port",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.io.PubSubWebSocketOutputOperator",
         "tags" : [
            "http",
            "input operator"
         ],
         "properties" : [
            {
               "name" : "ioThreadMultiplier",
               "type" : "int",
               "canSet" : true,
               "description" : "the IO thread multiplier",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "numRetries",
               "type" : "int",
               "canSet" : true,
               "description" : "the number of retries",
               "canGet" : true
            },
            {
               "name" : "topic",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "uri",
               "type" : "java.net.URI",
               "canSet" : true,
               "description" : "the URI",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "absolute",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "authority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "fragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "host",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "opaque",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "path",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "port",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "query",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawAuthority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawFragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawPath",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawQuery",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawSchemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawUserInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "scheme",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "schemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "userInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "waitMillisRetry",
               "type" : "int",
               "canSet" : true,
               "description" : "wait in milliseconds",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator writes maps as JSON objects to the given URL",
         "longDesc" : " <p></p>",
         "category" : "Input/Output",
         "outputPorts" : [],
         "displayName" : "Pub Sub Web Socket Output"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.SimpleSinglePortInputOperator",
         "tags" : [
            "input operator"
         ],
         "properties" : [
            {
               "name" : "active",
               "type" : "boolean",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This an input operator which passes data from an asynchronous data source to a port processing thread",
         "longDesc" : " <p>\n This operator handles hand over from asynchronous input to port processing thread (tuples\n must be emitted by container thread). If derived class implements\n {@link Runnable} to perform synchronous IO, this class will manage the thread\n according to the operator lifecycle.\n </p>",
         "category" : "Input/Output",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outputPort",
               "optional" : true,
               "description" : "The single output port of this input operator.\n Collects asynchronously emitted tuples and flushes in container thread.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "displayName" : "Asynchronous Input Processing"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "This is the output port which receives the tuples that will be output to an smtp server.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.io.SmtpOutputOperator",
         "tags" : [
            "stmp",
            "output operator"
         ],
         "properties" : [
            {
               "name" : "content",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "contentType",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "from",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "smtpHost",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "smtpPassword",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "smtpPort",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "smtpUserName",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "subject",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "useSsl",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator outputs data to an smtp server",
         "longDesc" : " <p></p>",
         "category" : "Input/Output",
         "outputPorts" : [],
         "displayName" : "Smtp Output"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.WebSocketInputOperator",
         "tags" : [
            "http",
            "input operator"
         ],
         "properties" : [
            {
               "name" : "active",
               "type" : "boolean",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "ioThreadMultiplier",
               "type" : "int",
               "canSet" : true,
               "description" : "the IO thread multiplier",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "uri",
               "type" : "java.net.URI",
               "canSet" : true,
               "description" : "the URI",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "absolute",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "authority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "fragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "host",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "opaque",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "path",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "port",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "query",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawAuthority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawFragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawPath",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawQuery",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawSchemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawUserInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "scheme",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "schemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "userInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            }
         ],
         "shortDesc" : "Reads via WebSocket from given URL as input stream.&nbsp;\n Incoming data is interpreted as JSONObject and converted to {@link java.util.Map}",
         "longDesc" : " <p></p>",
         "category" : "Input/Output",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outputPort",
               "optional" : true,
               "description" : "The single output port of this input operator.\n Collects asynchronously emitted tuples and flushes in container thread.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "displayName" : "JSON Map Input"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "The input port",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.io.WebSocketOutputOperator",
         "tags" : [
            "http",
            "input operator"
         ],
         "properties" : [
            {
               "name" : "ioThreadMultiplier",
               "type" : "int",
               "canSet" : true,
               "description" : "the IO thread multiplier",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "numRetries",
               "type" : "int",
               "canSet" : true,
               "description" : "the number of retries",
               "canGet" : true
            },
            {
               "name" : "uri",
               "type" : "java.net.URI",
               "canSet" : true,
               "description" : "the URI",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "absolute",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "authority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "fragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "host",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "opaque",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "path",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "port",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "query",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawAuthority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawFragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawPath",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawQuery",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawSchemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawUserInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "scheme",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "schemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "userInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "waitMillisRetry",
               "type" : "int",
               "canSet" : true,
               "description" : "wait in milliseconds",
               "canGet" : true
            }
         ],
         "shortDesc" : "Reads via WebSocket from given URL as input stream.&nbsp;Incoming data is interpreted as JSONObject and converted to {@link java.util.Map}",
         "longDesc" : " <p></p>",
         "category" : "Input/Output",
         "outputPorts" : [],
         "displayName" : "JSON Map Output"
      },
      {
         "inputPorts" : [
            {
               "name" : "percentage input",
               "optional" : true,
               "description" : "Tuples received on this input port will be sent to a Percentage Widget."
            },
            {
               "name" : "pieChart input",
               "optional" : true,
               "description" : "Tuples received on this input port will be sent to a Pie Chart Widget for display."
            },
            {
               "name" : "simple input",
               "optional" : true,
               "description" : "Tuples received on this input port will be sent to a Simple Widget for display."
            },
            {
               "name" : "time series input",
               "optional" : true,
               "description" : "Tuples received on this input port will be sent to a Time Series Widget for display."
            },
            {
               "name" : "topN input",
               "optional" : true,
               "description" : "Tuples received on this input port will be sent to a Top N Widget for display."
            }
         ],
         "name" : "com.datatorrent.lib.io.WidgetOutputOperator",
         "tags" : [
            "dt",
            "output operator"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator outputs data in a format that can be displayed in DT UI widgets",
         "longDesc" : " <p>\n There are 4 input ports each of which is compatible to one widget\n  <li>simpleInput is used for simple input widget. It takes any object and push the toString() value to the UI</li>\n  <li>timeSeriesInput is used for a widget of bar chart of series number values at certain times. It takes a Long for time and a Number for value </li>\n  <li>percentageInput is used for either the percentage gadget or progress bar. It takes int value between 0 and 100 as input</li>\n  <li>topNInput is used for N key value table widget. It takes a Map as input</li><br>\n\n  By default it outputs data to WebSocket channel specified by DT gateway.<br>\n  If DT gateway is not specified, it will use output data to console.\n </p>",
         "category" : "Input/Output",
         "outputPorts" : [],
         "displayName" : "DT Widget Output"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "The input port",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.io.WidgetOutputOperator$1",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "ioThreadMultiplier",
               "type" : "int",
               "canSet" : true,
               "description" : "the IO thread multiplier",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "numRetries",
               "type" : "int",
               "canSet" : true,
               "description" : "the number of retries",
               "canGet" : true
            },
            {
               "name" : "uri",
               "type" : "java.net.URI",
               "canSet" : true,
               "description" : "the URI",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "absolute",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "authority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "fragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "host",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "opaque",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "path",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "port",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "query",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawAuthority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawFragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawPath",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawQuery",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawSchemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawUserInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "scheme",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "schemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "userInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "waitMillisRetry",
               "type" : "int",
               "canSet" : true,
               "description" : "wait in milliseconds",
               "canGet" : true
            }
         ]
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.fs.DirectoryScanInputOperator",
         "tags" : [
            "fs local",
            "directory",
            "input operator"
         ],
         "properties" : [
            {
               "name" : "directoryPath",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "directoryPath the path of directory being scanned.",
               "canGet" : true
            },
            {
               "name" : "fileCountPerEmit",
               "type" : "int",
               "canSet" : true,
               "description" : "fileCountPerEmit the number of file records that are output per emit",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "scanIntervalInMilliSeconds",
               "type" : "int",
               "canSet" : true,
               "description" : "scanIntervalInMilliSeconds the interval at which the directory is being scanned",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator scans for files in a local directory and emits tuples read from the files",
         "longDesc" : " <p>\n Since the operator can be deployed anywhere in the cluster the directory\n to be scanned should be available on all nodes of the cluster.\n Not to be used for HDFS.\n </p>",
         "category" : "Input/Output",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "This output port emits FileInfoRecords, which provide path,\n type, and size information about the files scanned by the operator.",
               "tupleType" : "class com.datatorrent.lib.io.fs.FileInfoRecord"
            }
         ],
         "displayName" : "Local FS File Input"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "This is the input port which receives tuples to be written out to HDFS.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.io.fs.HdfsExactlyOnceOutputOperator",
         "tags" : [
            "hdfs",
            "files",
            "output operator"
         ],
         "properties" : [
            {
               "name" : "append",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "bufferSize",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "filePath",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "replication",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "totalBytesWritten",
               "type" : "long",
               "canSet" : false,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator writes out tuples to hdfs while obeying the exactly once constraint",
         "longDesc" : " <p>\n The Operator creates file <window_id>.tmp during beginwindow and writes the tuples to it.\n It moves the file to <window_id> in the end window.\n If the operator fails and recovers, checks if the file <window_id> exists during begin window. If it does,\n then the operator doesn't process anything during that window. If it doesn't, then the operator deletes\n the <window_id>.tmp file if it exists, creates new and starts writing to it.\n </p>",
         "category" : "Input/Output",
         "outputPorts" : [],
         "displayName" : "HDFS Exactly Once Output"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.fs.HdfsTextFileInputOperator",
         "tags" : [
            "hdfs",
            "file",
            "input operator"
         ],
         "properties" : [
            {
               "name" : "filePath",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "linesEachWindow",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator reads tuples from an HDFS text file",
         "longDesc" : " <p></p>",
         "category" : "Input/Output",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "HDFSOutput",
               "optional" : true,
               "description" : "This is the output port which emits text read from an HDFS text file.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "displayName" : "HDFS Text File Input"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.fs.HdfsWordInputOperator",
         "tags" : [
            "hdfs",
            "file",
            "input operator"
         ],
         "properties" : [
            {
               "name" : "filePath",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "tupleSize",
               "type" : "int",
               "canSet" : true,
               "description" : "the tupleSize",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator reads tuples of a specified byte size from an HDFS file",
         "longDesc" : " <p></p>",
         "category" : "Input/Output",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "HDFSOutput",
               "optional" : true,
               "description" : "This is the output port which emits bytes read from an HDFS file.",
               "tupleType" : "byte[]"
            }
         ],
         "displayName" : "HDFS Byte File Input"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.fs.LocalFsInputOperator",
         "tags" : [
            "local fs",
            "file",
            "output operator"
         ],
         "properties" : [
            {
               "name" : "filePath",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "sleepInterval",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator opens a given file from the local file system.&nbsp;\n Each line is emitted on the output port.&nbsp;\n The thread waits for the given sleep interval after emitting a line",
         "longDesc" : " <p>\n <b>Ports</b>:<br>\n <b>outport</b>: emits &lt;String&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>filePath</b> : Path for file to be read. <br>\n <b>sleepInterval</b>: Thread sleep interval after emitting line.<br>\n <br>\n </p>",
         "category" : "Input/Output",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "This is the output port which emits the lines read from a specified file.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "displayName" : "Local FS Line File Input"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.fs.TailFsInputOperator",
         "tags" : [
            "local fs",
            "file",
            "input operator"
         ],
         "properties" : [
            {
               "name" : "delay",
               "type" : "long",
               "canSet" : true,
               "description" : "the delay",
               "canGet" : true
            },
            {
               "name" : "delimiter",
               "type" : "char",
               "canSet" : true,
               "description" : "the delimiter",
               "canGet" : true
            },
            {
               "name" : "end",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the end",
               "canGet" : true
            },
            {
               "name" : "filePath",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the filePath",
               "canGet" : true
            },
            {
               "name" : "numberOfTuples",
               "type" : "int",
               "canSet" : true,
               "description" : "the numberOfTuples",
               "canGet" : true
            },
            {
               "name" : "position",
               "type" : "long",
               "canSet" : true,
               "description" : "the position",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator implements \"tail -f\" command.&nbsp;If the operator has reached the end of the file, it will wait till more\n data comes",
         "longDesc" : " <p>\n <b>Ports</b>:<br>\n <b>outport</b>: emits &lt;String&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>filePath</b> : Path for file to be read. <br>\n <b>delay</b>: Thread sleep interval after emitting line.<br>\n <b>position</b>: The position from where to start reading the file.<br>\n <b>numberOfTuples</b>: number of tuples to be emitted in a single emit Tuple call.<br>\n <b>end</b>: if the user wants to start tailing from end.<br>\n <br>\n </p>",
         "category" : "Input/Output",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "description" : "This is the output port, which emits lines from the specified files.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "displayName" : "Tail Input"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.jms.ActiveMQSinglePortStringInputOperator",
         "tags" : [
            "jms",
            "input operator",
            "string"
         ],
         "properties" : [
            {
               "name" : "ackMode",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the message acknowledgment mode",
               "canGet" : true
            },
            {
               "name" : "batch",
               "type" : "int",
               "canSet" : true,
               "description" : "the batch",
               "canGet" : true
            },
            {
               "name" : "bufferSize",
               "type" : "int",
               "canSet" : true,
               "description" : "the buffer size",
               "canGet" : true
            },
            {
               "name" : "clientId",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the clientId",
               "canGet" : true
            },
            {
               "name" : "connection",
               "type" : "javax.jms.Connection",
               "canSet" : false,
               "description" : "the connection",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "clientID",
                     "type" : "java.lang.String",
                     "canSet" : true,
                     "canGet" : true
                  },
                  {
                     "name" : "exceptionListener",
                     "type" : "javax.jms.ExceptionListener",
                     "canSet" : true,
                     "canGet" : true,
                     "properties" : []
                  },
                  {
                     "name" : "metaData",
                     "type" : "javax.jms.ConnectionMetaData",
                     "canSet" : false,
                     "canGet" : true,
                     "properties" : [
                        {
                           "name" : "JMSMajorVersion",
                           "type" : "int",
                           "canSet" : false,
                           "canGet" : true
                        },
                        {
                           "name" : "JMSMinorVersion",
                           "type" : "int",
                           "canSet" : false,
                           "canGet" : true
                        },
                        {
                           "name" : "JMSProviderName",
                           "type" : "java.lang.String",
                           "canSet" : false,
                           "canGet" : true
                        },
                        {
                           "name" : "JMSVersion",
                           "type" : "java.lang.String",
                           "canSet" : false,
                           "canGet" : true
                        },
                        {
                           "name" : "JMSXPropertyNames",
                           "type" : "java.util.Enumeration",
                           "canSet" : false,
                           "canGet" : true,
                           "properties" : []
                        },
                        {
                           "name" : "providerMajorVersion",
                           "type" : "int",
                           "canSet" : false,
                           "canGet" : true
                        },
                        {
                           "name" : "providerMinorVersion",
                           "type" : "int",
                           "canSet" : false,
                           "canGet" : true
                        },
                        {
                           "name" : "providerVersion",
                           "type" : "java.lang.String",
                           "canSet" : false,
                           "canGet" : true
                        }
                     ]
                  }
               ]
            },
            {
               "name" : "connectionFactoryClass",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "connectionFactoryProperties",
               "type" : "java.util.Map",
               "canSet" : true,
               "description" : "reference to mutable properties",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "empty",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "consumer",
               "type" : "javax.jms.MessageConsumer",
               "canSet" : false,
               "description" : "the message consumer",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "messageListener",
                     "type" : "javax.jms.MessageListener",
                     "canSet" : true,
                     "canGet" : true,
                     "properties" : []
                  },
                  {
                     "name" : "messageSelector",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "consumerName",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the consumer name",
               "canGet" : true
            },
            {
               "name" : "destination",
               "type" : "javax.jms.Destination",
               "canSet" : false,
               "description" : "the destination",
               "canGet" : true,
               "properties" : []
            },
            {
               "name" : "durable",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the durability of the consumer",
               "canGet" : true
            },
            {
               "name" : "maximumReceiveMessages",
               "type" : "long",
               "canSet" : true,
               "description" : "the maximum of received messages",
               "canGet" : true
            },
            {
               "name" : "messageSize",
               "type" : "int",
               "canSet" : true,
               "description" : "the message size",
               "canGet" : true
            },
            {
               "name" : "messagesReceived",
               "type" : "long",
               "canSet" : true,
               "description" : "the count of messages received",
               "canGet" : true
            },
            {
               "name" : "password",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "replyProducer",
               "type" : "javax.jms.MessageProducer",
               "canSet" : false,
               "description" : "the message producer",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "deliveryMode",
                     "type" : "int",
                     "canSet" : true,
                     "canGet" : true
                  },
                  {
                     "name" : "destination",
                     "type" : "javax.jms.Destination",
                     "canSet" : false,
                     "canGet" : true,
                     "properties" : []
                  },
                  {
                     "name" : "disableMessageID",
                     "type" : "boolean",
                     "canSet" : true,
                     "canGet" : true
                  },
                  {
                     "name" : "disableMessageTimestamp",
                     "type" : "boolean",
                     "canSet" : true,
                     "canGet" : true
                  },
                  {
                     "name" : "priority",
                     "type" : "int",
                     "canSet" : true,
                     "canGet" : true
                  },
                  {
                     "name" : "timeToLive",
                     "type" : "long",
                     "canSet" : true,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "session",
               "type" : "javax.jms.Session",
               "canSet" : false,
               "description" : "the session",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "acknowledgeMode",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "messageListener",
                     "type" : "javax.jms.MessageListener",
                     "canSet" : true,
                     "canGet" : true,
                     "properties" : []
                  },
                  {
                     "name" : "transacted",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "subject",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the name of the destination",
               "canGet" : true
            },
            {
               "name" : "topic",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the topic",
               "canGet" : true
            },
            {
               "name" : "transacted",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the transacted",
               "canGet" : true
            },
            {
               "name" : "tuplesBlast",
               "type" : "int",
               "canSet" : true,
               "description" : "the tuplesBlast",
               "canGet" : true
            },
            {
               "name" : "url",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "user",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "verbose",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This is a single port input operator,\n which consumes messages from an ActiveMQ message bus and emits strings",
         "longDesc" : " <p></p>",
         "category" : "Messaging",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outputPort",
               "optional" : true,
               "description" : "This is the single output port, which emits tuples read from ActiveMQ messages.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "displayName" : "Active MQ Single Port Input (String)"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "This is the input port which receives apache log lines.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.ApacheLogParseMapOutputOperator",
         "tags" : [
            "apache",
            "regex"
         ],
         "properties" : [
            {
               "name" : "logRegex",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the logRegex",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "regexGroups",
               "type" : "[Ljava.lang.String;",
               "canSet" : true,
               "description" : "the groups",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator parses apache logs one line at a time (each tuple is a log line), using the given regex.&nbsp;\n A mapping from log line sections to values is created for each log line and emitted",
         "longDesc" : " <p>\n This is a pass through operator<br>\n <br>\n <b>StateFull : No </b><br>\n <b>Partitions : Yes</b>, No dependency among input values. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects String<br>\n <b>output</b>: emits Map<br>\n <br>\n <b>Properties</b>:<br>\n <b>logRegex</b>: defines the regex <br>\n <b>groupMap</b>: defines the mapping from the group ids to the names <br>\n </p>",
         "category" : "Logs",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "description" : "This is the output port which emits one tuple for each Apache log line.\n Each tuple is a Map whose keys represent various sections of a log line,\n and whose values represent the contents of those sections.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "displayName" : "Apache Log Parse Map"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "This is the input port which receives apache log lines.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.ApacheLogParseOperator",
         "tags" : [
            "apache"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "Parse Apache log lines one line at a time.&nbsp;\n Regex (getAccessLogRegex) is used as a parser.&nbsp;\n The fields extracted include i/p (outputIPAddress), url (outputUrl),\n status code (outputStatusCode), bytes (outputBytes), referer (outputReferer),\n and agent (outputAgent)",
         "longDesc" : " <p>\n This is a pass through operator<br>\n <br>\n <b>StateFull : No </b><br>\n <b>Partitions : Yes</b>, No dependency among input values. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects String<br>\n <b>outputIPAddress</b>: emits String<br>\n <b>outputUrl</b>: emits String<br>\n <b>outputStatusCode</b>: emits String<br>\n <b>outputBytes</b>: emits String<br>\n <b>outputReferer</b>: emits String<br>\n <b>outputAgent</b>: emits String<br>\n <br>\n <b>Properties</b>: none<br>\n </p>",
         "category" : "Logs",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outputAgent",
               "optional" : true,
               "description" : "IP Agent, output port.",
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputBytes",
               "optional" : true,
               "description" : "Number of bytes served, output port.",
               "tupleType" : "class java.lang.Long"
            },
            {
               "error" : false,
               "name" : "outputIPAddress",
               "optional" : true,
               "description" : "Client IP address, output port.",
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputReferer",
               "optional" : true,
               "description" : "Referer name, output port.",
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputStatusCode",
               "optional" : true,
               "description" : "Apache status log, output port.",
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputUrl",
               "optional" : true,
               "description" : "Access url port, output port.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "displayName" : "Apache Log Parse"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.ApacheVirtualLogParseOperator",
         "tags" : [
            "apache"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "Parse Apache log lines one line at a time.&nbsp;\n Regex (getAccessLogRegex) is used as a parser.&nbsp;\n The fields extracted include i/p (outputIPAddress), url (outputUrl),\n status code (outputStatusCode), bytes (outputBytes), referer (outputReferer),\n and agent (outputAgent).&nbsp;Each of the fields are emitted to a separate output port",
         "longDesc" : " <p>\n Please refer to docs for {@link com.datatorrent.lib.logs.ApacheLogParseOperator} documentation.\n More output ports in this operator.\n </p>",
         "category" : "Logs",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "clientDataUsage",
               "optional" : true,
               "description" : "This output port emits client data usage contained in log file lines.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "outServerStatus",
               "optional" : true,
               "description" : "This output port emits the status associated with each server in a log file line.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.String>"
            },
            {
               "error" : false,
               "name" : "outUrlStatus",
               "optional" : true,
               "description" : "This output port emits the status codes corresponding to each url in a log file line.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.String>"
            },
            {
               "error" : false,
               "name" : "outputAgent",
               "optional" : true,
               "description" : "This output port emits the agents contained in the log file lines.",
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputBytes",
               "optional" : true,
               "description" : "This output pot emits a Map for each log file line,\n which contains all the information extracted from the log file line.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "outputIPAddress",
               "optional" : true,
               "description" : "This output port emits the IPAddresses contained in log file lines.",
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputReferer",
               "optional" : true,
               "description" : "This output port emits the referers contained in the log file lines.",
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputServerName",
               "optional" : true,
               "description" : "This output port emits the servernames contained in the log file lines.",
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputServerName1",
               "optional" : true,
               "description" : "This output port emits the servernames contained in the log file lines.",
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputStatusCode",
               "optional" : true,
               "description" : "This output port emits status codes contained in log file lines.",
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputUrl",
               "optional" : true,
               "description" : "This output port emits URLs contained in log file lines.",
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "viewCount",
               "optional" : true,
               "description" : "This output port emits the view counts contained in log file lines.",
               "tupleType" : "class java.lang.Integer"
            }
         ],
         "displayName" : "Apache Virtual Log Parse"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "tupleType" : "java.util.Map<java.lang.String, com.datatorrent.lib.logs.DimensionObject<java.lang.String>>"
            }
         ],
         "name" : "com.datatorrent.lib.logs.DimensionAggregationUnifier",
         "tags" : [
            "aggregation",
            "unifier"
         ],
         "properties" : [],
         "shortDesc" : "This unifier ingests tuples that are Maps from Strings to DimensionObjects and sums the corresponding DimensionObjects.&nbsp;\n A Map from Strings to aggregated DimensionObjects is emitted by the unifier",
         "longDesc" : " <p></p>",
         "category" : "Logs",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.String, com.datatorrent.lib.logs.DimensionObject<java.lang.String>>"
            }
         ],
         "displayName" : "Dimension Aggregation Unifier"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "This is the input port, which receives strings.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.FilteredLineToTokenArrayList",
         "tags" : [
            "string"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.String;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "splitBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitBy",
               "canGet" : true
            },
            {
               "name" : "splitTokenBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitTokenBy",
               "canGet" : true
            }
         ],
         "shortDesc" : "<p>\n Splits String objects into tokens, and emits filtered keys as and ArrayList",
         "longDesc" : " <p>\n An ArrayList of all tokens that pass the filter are emitted.\n </p>\n <p>\n This module is a pass through<br>\n <br>\n <b>StateFull : No, </b> tokens are processed in current window. <br>\n <b>Partitions : Yes, </b> No state dependency in output tokens. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Input port, expects String<br>\n <b>tokens</b>: Output port, emits ArrayList<Object><br>\n <br>\n <b>Properties</b>:<br>\n <b>splitby</b>: The characters used to split the line. Default is \";\\t \"<br>\n <b>splittokenby</b>: The characters used to split a token into key,val pair. If not specified the value is set to null. Default is \",\", i.e. tokens are split<br>\n <b>filterby</b>: Only emit the keys (comma separated_that are in filterby<br>\n <br>\n <br>\n <br>\n </p>",
         "category" : "Logs",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "splittokens",
               "optional" : true,
               "description" : "This output port emits a map from tokens to sub tokens.",
               "tupleType" : "java.util.ArrayList<java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.String>>>"
            },
            {
               "error" : false,
               "name" : "tokens",
               "optional" : true,
               "description" : "This emits the tokens a string is broken up into.",
               "tupleType" : "java.util.ArrayList<java.lang.String>"
            }
         ],
         "displayName" : "Filtered Line To Token ArrayList"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "This is the input port, which receives strings.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.FilteredLineToTokenHashMap",
         "tags" : [
            "string"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.String;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "splitBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitBy",
               "canGet" : true
            },
            {
               "name" : "splitTokenBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitTokenBy",
               "canGet" : true
            }
         ],
         "shortDesc" : "<p>\n Splits the String tuples into tokens and emits filtered keys as a HashMap",
         "longDesc" : " <p>\n A HashMap of all filtered tokens are emitted on output port \"tokens\". <br>\n </p>\n <p>\n First token in line is treated as key and rest are put into values array list. <br>\n HashMap of token and array values are emitted on output port.\n This module is a pass through<br>\n <br>\n <b>StateFull : No, </b> tokens are processed in current window. <br>\n <b>Partitions : Yes, </b> No state dependency in output tokens. <br>\n <br>\n Ports:<br>\n <b>data</b>: Input port, expects String<br>\n <b>tokens</b>: Output port, emits HashMap<String, Object><br>\n <br>\n <b>Properties</b>:<br>\n <b>splitby</b>: The characters used to split the line. Default is \";\\t \"<br>\n <b>splittokenby</b>: The characters used to split a token into key,val pair.\n Default is \"\", i.e. tokens are not split, and key is set to token, and val is\n null<br>\n <b>filterby</b>: Only emit the keys (comma separated) that are in filterby<br>\n <br>\n </p>",
         "category" : "Logs",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "tokens",
               "optional" : true,
               "description" : "This output port emits the split strings.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.String>>"
            }
         ],
         "displayName" : "Filtered Line To Token HashMap"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "This is the input port, which receives strings.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.FilteredLineTokenizerKeyVal",
         "tags" : [
            "string",
            "key value"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.String;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "splitBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitBy",
               "canGet" : true
            },
            {
               "name" : "splitTokenBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitTokenBy",
               "canGet" : true
            }
         ],
         "shortDesc" : "Splits lines into tokens, and tokens into sub-tokens and emits key,val pairs in a HashMap.&nbsp;\n Each token is emitted as a key value pair only if the key is allowed by the specified filter",
         "longDesc" : " <p>\n This module is a pass through. Ideal for applications like log\n processing where only a few keys are to be processed<br>\n <br>\n <b>StateFull : No, </b> tokens are processed in current window. <br>\n <b>Partitions : Yes, </b> No state dependency in output tokens. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects String<br>\n <b>tokens</b>: emits HashMap&lt;String,String&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>splitby</b>: The characters used to split the line. Default is \";\\t \"<br>\n <b>splittokenby</b>: The characters used to split a token into key,val pair.\n Default is \"\", i.e. tokens are not split, and key is set to token, and val is\n null<br>\n <b>filterby</b>: Only emit the keys (comma separated) that are in filterby\n <br>\n </p>",
         "category" : "Logs",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "tokens",
               "optional" : true,
               "description" : "This output port emits key value pairs where the key is a token in an input string,\n and the value is a sub token of the key token.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.String>"
            }
         ],
         "displayName" : "Filtered Line Tokenizer Key Value"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "This is the input port, which receives strings.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.LineToTokenArrayList",
         "tags" : [
            "string"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "splitBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitBy",
               "canGet" : true
            },
            {
               "name" : "splitTokenBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitTokenBy",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator splits string objects into tokens and sub tokens.&nbsp;\n This operator emits a list of tokens, as well as a map from tokens to sub tokens",
         "longDesc" : " <p>\n An ArrayList of all tkns are emitted on output port \"tokens\".\n An ArrayList of all subtokens are emitted on port splittokens<p>\n This module is a pass through. Ideal for applications like log processing<br>\n <br>\n <b>StateFull : No, </b> tokens are processed in current window. <br>\n <b>Partitions : Yes, </b> output port unifier operator. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects String<br>\n <b>tokens</b>: emits ArrayList&lt;String&gt;<br>\n <b>splittokens</b>: emits ArrayList&lt;HashMap&lt;String,ArrayList&lt;String&gt;&gt;&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>splitby</b>: The characters used to split the line. Default is \";\\t \"<br>\n <b>splittokenby</b>: The characters used to split a token into key,val1,val2,.... If not specified the value is set to null. Default is \"\", i.e. tokens are not split<br>\n </p>",
         "category" : "Logs",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "splittokens",
               "optional" : true,
               "description" : "This output port emits a map from tokens to sub tokens.",
               "tupleType" : "java.util.ArrayList<java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.String>>>"
            },
            {
               "error" : false,
               "name" : "tokens",
               "optional" : true,
               "description" : "This emits the tokens a string is broken up into.",
               "tupleType" : "java.util.ArrayList<java.lang.String>"
            }
         ],
         "displayName" : "Line To Token (ArrayList)"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "This is the input port, which receives strings.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.LineToTokenHashMap",
         "tags" : [
            "string"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "splitBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitBy",
               "canGet" : true
            },
            {
               "name" : "splitTokenBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitTokenBy",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator splits string objects into tokens.&nbsp;\n A key value pair is emitted where the key is the first token in an input tuple\n and the value is a list of the other tokens in an input tuple., and emits as a HashMap where the first token",
         "longDesc" : " <p>\n This module is a pass through<br>\n <br>\n <b>StateFull : No, </b> tokens are processed in current window. <br>\n <b>Partitions : Yes, </b> output port unifier operator. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Input port, expects String<br>\n <b>tokens</b>: Output port, emits HashMap&lt;String, ArrayList&lt;String&gt;&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>splitby</b>: The characters used to split the line. Default is \";\\t \"<br>\n <b>splittokenby</b>: The characters used to split a token into key,val1,val2,.... Default is \"\", i.e. tokens are not split, and key=token, val=\"\"<br>\n </p>",
         "category" : "Logs",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "tokens",
               "optional" : true,
               "description" : "This output port emits the split strings.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.String>>"
            }
         ],
         "displayName" : "Line To Token (HashMap)"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "This is the input port, which receives strings.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.LineTokenizer",
         "tags" : [
            "string"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "splitBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitBy",
               "canGet" : true
            },
            {
               "name" : "splitTokenBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitTokenBy",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator splits lines into tokens and emits token strings on the output port",
         "longDesc" : " <p>\n This module is a pass through. Ideal for applications like word count, or log\n processing<br>\n <br>\n <b>StateFull : No, </b> tokens are processed in current window. <br>\n <b>Partitions : Yes, </b> No state dependency in output tokens. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects String<br>\n <b>tokens</b>: emits String<br>\n <br>\n <b>Properties</b>:<br>\n <b>splitby</b>: The characters used to split the line. Default is \";\\t \"<br>\n <br>\n <br>\n </p>",
         "category" : "Logs",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "tokens",
               "optional" : true,
               "description" : "The is the output port that emits string tokens.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "displayName" : "Line Tokenizer"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "This is the input port, which receives strings.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.LineTokenizerKeyVal",
         "tags" : [
            "string",
            "key value"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "splitBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitBy",
               "canGet" : true
            },
            {
               "name" : "splitTokenBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitTokenBy",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator splits lines into tokens, and tokens into sub-tokens.&nbsp;\n Emitted tuples are key value pairs where tokens are the keys and sub tokens are the values",
         "longDesc" : " <p>\n Useful to convert String (log lines) into a POJO (HashMap)\n </p>\n <p>\n This module is a pass through<br>\n <br>\n <b>StateFull : No, </b> tokens are processed in current window. <br>\n <b>Partitions : Yes, </b>output unifier. <br>\n <br>\n <br>\n Ideal for applications like log processing<br>\n <b>Ports</b>:<br>\n <b>data</b>: expects String<br>\n <b>tokens</b>: emits HashMap&lt;String,String&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>splitby</b>: The characters used to split the line. Default is \";\\t \"<br>\n <b>splittokenby</b>: The characters used to split a token into key,val pair. Default is \"\", i.e. tokens are not split, and key is set to token, and val is null<br>\n <br>\n </p>",
         "category" : "Logs",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "tokens",
               "optional" : true,
               "description" : "This output port emits key value pairs where the key is a token in an input string,\n and the value is a sub token of the key token.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.String>"
            }
         ],
         "displayName" : "Line Tokenizer Key Value"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "This is the input port which receives multi dimensional data.",
               "tupleType" : "java.util.Map<java.lang.String, java.util.Map<java.lang.String, java.lang.Number>>"
            }
         ],
         "name" : "com.datatorrent.lib.logs.MultiWindowDimensionAggregation",
         "tags" : [
            "aggregation"
         ],
         "properties" : [
            {
               "name" : "dimensionArray",
               "type" : "java.util.List",
               "canSet" : true,
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "empty",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "dimensionKeyVal",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "operationType",
               "type" : "com.datatorrent.lib.logs.MultiWindowDimensionAggregation$AggregateOperation",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "timeBucket",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "windowSize",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This class aggregates the value of given dimension across windows",
         "longDesc" : " <p></p>",
         "category" : "Logs",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "description" : "This is the output port which emits aggregated dimensions.",
               "tupleType" : "java.util.Map<java.lang.String, com.datatorrent.lib.logs.DimensionObject<java.lang.String>>"
            }
         ],
         "displayName" : "Multi Window Dimension Aggregation"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input log line port.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.RegexMatchMapOperator",
         "tags" : [
            "regex"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "regex",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the regex",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator parses unstructured log data into named fields",
         "longDesc" : "\n <p>Uses a regex with named capturing groups (http://www.regular-expressions.info/named.html) to extract portions of a string read\n from the input port into a Map<String,String>. The capturing group name is used as the key name. The captured value is used as\n the value.</p>\n\n <p>For example, given the input:\n   <br><code>12345 \"foo bar\" baz;goober</code></p>\n\n <p>And the regular expression:\n   <br><code>(?&lt;id&gt;\\d+) \"(?&lt;username&gt;[^\"]+)\" (?&lt;action&gt;[^;]+);(?&lt;cookie&gt;.+)</code></p>\n\n <p>The operator would emit a Map containing:<br>\n  <table>\n  <tr><th>KEY</th><th>VAL</th></tr>\n  <tr><td>id</td><td>12345</td></tr>\n  <tr><td>username</td><td>foo bar</td></tr>\n  <tr><td>action</td><td>baz</td></tr>\n  <tr><td>cookie</td><td>goober</td></tr>\n  </table>\n\n <p>In the case where the regex does not match the input, nothing is emitted.</p>\n\n <p>Uses the named-regexp library originally from Google, but now maintained\n by Anthony Trinh (https://github.com/tony19/named-regexp).</p>\n\n This is a passthrough operator<br>\n <br>\n <b>StateFull : No </b><br>\n <b>Partitions : Yes</b>, No dependency among input values. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects String<br>\n <b>output</b>: emits Map<br>\n <br>\n <b>Properties</b>:<br>\n <b>regex</b>: defines the regex <br>",
         "category" : "Logs",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "description" : "The output port which emits a map from input string section names to input string section values.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "displayName" : "Regex Match Map"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port that takes a number.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.Average",
         "tags" : [
            "average",
            "numeric",
            "end window"
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "average",
               "type" : "java.lang.Number",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ],
         "shortDesc" : "Emits the average of values at the end of window",
         "longDesc" : " <p>\n This is an end window operator. This can not be partitioned. Partitioning\n this will yield incorrect result.<br>\n <b>Ports</b>:<br>\n <b>data</b>: expects V extends Number<br>\n <b>average</b>: emits V extends Number<br>\n <br>\n <br>\n <b>Properties</b>: None<br>\n <b>Specific compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None<br>\n <p>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "average",
               "optional" : true,
               "description" : "Output port that emits average as a number.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "displayName" : "Average"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port that takes a key value pair.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, ? extends java.lang.Number>"
            }
         ],
         "name" : "com.datatorrent.lib.math.AverageKeyVal",
         "tags" : [
            "average",
            "number",
            "end window",
            "key value"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "Emits the average of values for each key at the end of window",
         "longDesc" : " <p>\n <br>User can block or only enable certain keys by setting filter-keys/inverse operator properties.\n <br> Block Key : inverse=true\n <br> Enable Key : inverse=false\n This is an end window operator. This can not be partitioned. Partitioning\n this will yield incorrect result.<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>averagePort(s)</b>: emits KeyValPair&lt;K,V extends Number&gt;</b><br>\n <br>Output ports are optional.\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple (default : true).<br>\n <b>filterBy</b>: List of keys to filter on.<br>\n <br>\n <b>Specific compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None<br>\n <p>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "doubleAverage",
               "optional" : true,
               "description" : "Double average output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Double>"
            },
            {
               "error" : false,
               "name" : "intAverage",
               "optional" : true,
               "description" : "Integer average output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "longAverage",
               "optional" : true,
               "description" : "Long average output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Long>"
            }
         ],
         "displayName" : "Average Key Value"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port that takes a map of &lt;key,value&gt;.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.AverageMap",
         "tags" : [
            "average",
            "numeric",
            "end window",
            "key value",
            "aggregate"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "Emits the average value for each key at the end of window",
         "longDesc" : " <p>\n This is an end window operator. This can not be partitioned. Partitioning\n this will yield incorrect result.<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects HashMap&lt;K,V extends Number&gt;<br>\n <b>average</b>: emits HashMap&lt;K,V extends Number&gt;</b><br>\n <br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>\n <b>Specific compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None<br>\n <p>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "average",
               "optional" : true,
               "description" : "Average output port that emits a hashmap.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "displayName" : "Average Map"
      },
      {
         "inputPorts" : [
            {
               "name" : "base",
               "optional" : false,
               "description" : "Input port that takes a number&nbsp; It stores the value for base comparison.",
               "tupleType" : "class java.lang.Number"
            },
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port that takes a number.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.Change",
         "tags" : [
            "change",
            "key value",
            "numeric",
            "percentage"
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ],
         "shortDesc" : "Operator compares data values arriving on input port with base value input operator",
         "longDesc" : " \n <p>\n Arriving base value is stored in operator for comparison, old base value is overwritten.&nbsp;\n This emits &lt;change in value,percentage change&gt;.\n Operator expects values arriving on data input port and base value input operator.\n Change in value and percentage change in values are emitted on separate ports.<br>\n This operator can not be partitioned, since copies won't get consecutive operators. <br>\n This is StateFull operator, tuples that arrive on base port are kept in\n cache forever.<br>\n <br>\n <b>Input Ports</b>:<br>\n <b>data</b>: expects V extends Number, Data values<br>\n <b>base</b>: expects V extends Number, Base Value stored for comparison<br>\n\n <b>Output Ports</b>:<br>\n <b>change</b>: emits V extends Number,  Diff from base value<br>\n <b>percent</b>: emits Doubl, percent change in value compared to base value.<br>\n <br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>\n <b>Specific compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None<br>\n <br>\n\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "change",
               "optional" : true,
               "description" : "Output port that emits change in value compared to base value.",
               "tupleType" : "class java.lang.Number"
            },
            {
               "error" : false,
               "name" : "percent",
               "optional" : true,
               "description" : "Output port that emits percent change in data value compared to base value.",
               "tupleType" : "class java.lang.Double"
            }
         ],
         "displayName" : "Change"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port that takes in a number.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.ChangeAlert",
         "tags" : [
            "change",
            "key value",
            "numeric",
            "percentage"
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "percentThreshold",
               "type" : "double",
               "canSet" : true,
               "description" : "threshold value",
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ],
         "shortDesc" : "Compares consecutive input data values, emits &lt;value,percent change value&gt; pair on alert output port, if percent change exceeds certain thresh hold value",
         "longDesc" : " <p>\n Operator is StateFull since current value is stored for comparison in next window. <br>\n This operator can not be partitioned, partitioning will result in inconsistent base value\n across replicated copies.\n <br>\n\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>alert</b>: emits KeyValPair&lt;K,KeyValPair&lt;V,Double&gt;&gt;(1)<br>\n <br>\n <b>Properties</b>:<br>\n <b>threshold</b>: The threshold of change between consecutive tuples of the\n same key that triggers an alert tuple<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>\n <b>Specific compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "alert",
               "optional" : true,
               "description" : "Output port which emits a key value pair.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<V, java.lang.Double>"
            }
         ],
         "displayName" : "Change Alert"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port that takes a key value pair.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.ChangeAlertKeyVal",
         "tags" : [
            "change",
            "key value",
            "numeric",
            "percentage"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "percentThreshold",
               "type" : "double",
               "canSet" : true,
               "description" : "threshold value",
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "Operator compares consecutive values arriving at input port mapped by keys, emits &lt;key,percent change&gt; pair on output alert port if percent change exceeds percentage threshold set in operator",
         "longDesc" : " <p>\n StateFull : Yes, current key/value is stored in operator for comparison in\n next successive windows. <br>\n Partition(s): No, base comparison value will be inconsistent across\n instantiated copies. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>alert</b>: emits KeyValPair&lt;K,KeyValPair&lt;V,Double&gt;&gt;(1)<br>\n <br>\n <b>Properties</b>:<br>\n <b>threshold</b>: The threshold of change between consecutive tuples of the\n same key that triggers an alert tuple<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "alert",
               "optional" : true,
               "description" : "Key,Percent Change output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, com.datatorrent.lib.util.KeyValPair<V, java.lang.Double>>"
            }
         ],
         "displayName" : "Change Alert Key Value"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port that takes a map of &lt;key,value&gt;.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.ChangeAlertMap",
         "tags" : [
            "change",
            "key value",
            "numeric",
            "percentage",
            "map"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "percentThreshold",
               "type" : "double",
               "canSet" : true,
               "description" : "threshold value",
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "Operator stores  &lt;key,value&gt; pair in hash map across the windows for comparison and emits hash map of &lt;key,percent change in value for each key&gt; if percent change\n exceeds preset threshold",
         "longDesc" : " <p>\n\n StateFull : Yes, key/value pair in current window are stored for comparison in next window. <br>\n Partition : No, will yield wrong result, base value won't be consistent across instances. <br>\n\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>alert</b>: emits HashMap&lt;K,HashMap&lt;V,Double&gt;&gt;(1)<br>\n <br>\n <b>Properties</b>:<br>\n <b>threshold</b>: The threshold of change between consecutive tuples of the same key that triggers an alert tuple<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "alert",
               "optional" : true,
               "description" : "Output port which emits a hashmap of key, percentage change.",
               "tupleType" : "java.util.HashMap<K, java.util.HashMap<V, java.lang.Double>>"
            }
         ],
         "displayName" : "Change Alert Map"
      },
      {
         "inputPorts" : [
            {
               "name" : "base",
               "optional" : false,
               "description" : "Base value input port, stored in base map for comparison.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            },
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port that takes key value pairs.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.ChangeKeyVal",
         "tags" : [
            "change",
            "key value"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "Operator compares &lt;key,value&gt; pairs arriving at data and base input ports and stores &lt;key,value&gt; pairs arriving at base port in hash map across the windows",
         "longDesc" : " <p/>\n The &lt;key,value&gt; pairs that arrive at data port are compared with base value if the key exists in the hash map.&nbsp;\n Change value and percentage are emitted on separate ports.\n StateFull : Yes, base map values are stored across windows. <br>\n Partitions : Yes, values on the base port are replicated across all partitions. However the order of tuples on the\n output stream may change.\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>base</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>change</b>: emits KeyValPair&lt;K,V&gt;(1)<br>\n <b>percent</b>: emits KeyValPair&lt;K,Double&gt;(1)<br>\n <br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "change",
               "optional" : true,
               "description" : "Key, Change output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            },
            {
               "error" : false,
               "name" : "percent",
               "optional" : true,
               "description" : "Key, Percentage Change pair output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Double>"
            }
         ],
         "displayName" : "Change Key Value"
      },
      {
         "inputPorts" : [
            {
               "name" : "base",
               "optional" : false,
               "description" : "Base key,value map input port, for comparison.",
               "tupleType" : "java.util.Map<K, V>"
            },
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port that takes in a map of &lt;key,value&gt;.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.ChangeMap",
         "tags" : [
            "change",
            "key value",
            "number",
            "map"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "Operator takes input from two ports and stores input arriving at base port for comparison across the windows",
         "longDesc" : " <p>\n &lt;key,value&gt; maps arriving are compared with base map, on per key basis.For all existing keys, map of &lt;key,change&gt; and &lt;key,percent change&gt; are emitted on separate ports.\n <br>\n StateFull : Yes, base values are stored across windows for comparison. <br>\n Partitions : Yes, values on the base port are replicated across all partitions. The order of tuples from output port may\n change.\n <br>\n <p/>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>base</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>change</b>: emits HashMap&lt;K,V&gt;(1)<br>\n <b>percent</b>: emits HashMap&lt;K,Double&gt;(1)<br>\n <br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "change",
               "optional" : true,
               "description" : "Output port emits map for key, change.",
               "tupleType" : "java.util.HashMap<K, V>"
            },
            {
               "error" : false,
               "name" : "percent",
               "optional" : true,
               "description" : "Output port emits map for key,percentage change.",
               "tupleType" : "java.util.HashMap<K, java.lang.Double>"
            }
         ],
         "displayName" : "Change Map"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port which receives incoming key value pairs.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.CompareExceptMap",
         "tags" : [
            "comparison",
            "key value",
            "number",
            "hash map"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "Operator compares based on the property \"key\", \"value\", and \"compare\"",
         "longDesc" : " <p>\n The comparison is done by getting double value from the Number.\n Passed tuples are emitted on the output port \"compare\".&nbsp; \n Failed tuples are emitted on port \"except\".\n Both output ports are optional, but at least one has to be connected.\n This module is a pass through<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V&gt;<br>\n <b>compare</b>: emits HashMap&lt;K,V&gt;<br>\n <b>except</b>: emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n Compile time checks<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <b>Specific run time checks</b>:<br>\n Does the incoming HashMap have the key<br>\n Is the value of the key a number<br>\n <p>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Benchmark table for CompareExceptMap&lt;K,V extends Number&gt; operator template\">\n <tr><th>In-Bound</th><th>Out-bound</th><th>Comments</th></tr>\n <tr><td><b>5 Million K,V pairs/s</b></td><td>Each tuple is emitted if emitError is set to true</td><td>In-bound rate determines performance as every tuple is emitted.\n Immutable tuples were used in the benchmarking. If you use mutable tuples and have lots of keys, the benchmarks may be lower</td></tr>\n </table><br>\n <p>\n <b>Function Table (K=String, V=Integer); emitError=true; key=a; value=3; cmp=eq)</b>:\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Function table for CompareExceptMap&lt;K,V extends Number&gt; operator template\">\n <tr><th rowspan=2>Tuple Type (api)</th><th>In-bound (process)</th><th colspan=2>Out-bound (emit)</th></tr>\n <tr><th><i>data</i>(HashMap&lt;K,V&gt;)</th><th><i>compare</i>(HashMap&lt;K,V&gt;)</th><th><i>except</i>(HashMap&lt;K,V&gt;)</th></tr>\n <tr><td>Begin Window (beginWindow())</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>\n <tr><td>Data (process())</td><td>{a=2,b=20,c=1000}</td><td></td><td>{a=2,b=20,c=1000}</td></tr>\n <tr><td>Data (process())</td><td>{a=3,b=40,c=2}</td><td>{a=3,b=40,c=2}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=10,b=5}</td><td></td><td>{a=10,b=5}</td></tr>\n <tr><td>Data (process())</td><td>{d=55,b=12}</td><td></td><td>{d=55,b=12}</td></tr>\n <tr><td>Data (process())</td><td>{d=22,a=4}</td><td></td><td>{d=22,a=4}</td></tr>\n <tr><td>Data (process())</td><td>{d=4,a=3,g=5,h=44}</td><td>{d=4,a=3,g=5,h=44}</td><td></td></tr>\n <tr><td>End Window (endWindow())</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>\n </table>\n <br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "compare",
               "optional" : true,
               "description" : "Output port that emits a hashmap of matched tuples after comparison.",
               "tupleType" : "java.util.HashMap<K, V>"
            },
            {
               "error" : false,
               "name" : "expect",
               "optional" : true,
               "description" : "Output port that emits a hashmap of non matching tuples after comparison.",
               "tupleType" : "java.util.HashMap<K, V>"
            },
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "description" : "The output port which emits filtered key value pairs.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "displayName" : "Compare Except Map"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port which receives incoming key value pairs.",
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.math.CompareExceptStringMap",
         "tags" : [
            "comparison",
            "key value",
            "string",
            "hash map"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "emitError",
               "type" : "boolean",
               "canSet" : true,
               "description" : "emitError",
               "canGet" : true
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "Operator compares String tuples based on the property \"key\", \"value\", and \"cmp\".&nbsp; Both matching and non matching tuples are emitted on respective ports",
         "longDesc" : "\n \n <p>\n If the tuple passed the test, it is emitted on the output port \"compare\".\n If the tuple fails it is emitted on port \"except\".\n The comparison is done parsing a double value from the String. \n Both output ports are optional, but at least one has to be connected.\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,String&gt;<br>\n <b>compare</b>: emits HashMap&lt;K,String&gt;<br>\n <b>except</b>: emits HashMap&lt;K,String&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <b>Specific run time checks</b>:<br>\n Does the incoming HashMap have the key<br>\n Is the value of the key a number<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "compare",
               "optional" : true,
               "description" : "Output port that emits a hashmap of matching string tuples after comparison.",
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            },
            {
               "error" : false,
               "name" : "except",
               "optional" : true,
               "description" : "Output port that emits a hashmap of non matching string tuples after comparison.",
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            },
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "description" : "The output port which emits filtered key value pairs.",
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "displayName" : "Compare Except String Map"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port which receives incoming key value pairs.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.CompareMap",
         "tags" : [
            "comparison",
            "key value",
            "numeric",
            "map"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator compares tuples subclassed from Number based on the property \"key\", \"value\", and \"cmp\", and matching tuples are emitted",
         "longDesc" : " <p>\n If the tuple passed the test, it is emitted on the output port \"compare\".&nbsp; The comparison is done by getting double value from the Number.\n Both output ports are optional, but at least one has to be connected.\n This module is a pass through<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>compare</b>: emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n CompareMap string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n <b>Specific run time checks</b>:<br>\n Does the incoming HashMap have the key<br>\n Is the value of the key a number<br>\n <p>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Benchmark table for CompareMap&lt;K,V extends Number&gt; operator template\">\n <tr><th>In-Bound</th><th>Out-bound</th><th>Comments</th></tr>\n <tr><td><b>8 Million K,V pairs/s</b></td><td>Each matched tuple is emitted</td><td>In-bound rate and number of tuples that match determine performance.\n Immutable tuples were used in the benchmarking. If you use mutable tuples and have lots of keys, the benchmarks may be lower</td></tr>\n </table><br>\n <p>\n <b>Function Table (K=String,V=Integer); emitError=true; key=a; value=3; cmp=eq)</b>:\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Function table for CompareMap&lt;K,V extends Number&gt; operator template\">\n <tr><th rowspan=2>Tuple Type (api)</th><th>In-bound (process)</th><th>Out-bound (emit)</th></tr>\n <tr><th><i>data</i>(Map&lt;K,V&gt;)</th><th><i>compare</i>(HashMap&lt;K,V&gt;)</th></tr>\n <tr><td>Begin Window (beginWindow())</td><td>N/A</td><td>N/A</td></tr>\n <tr><td>Data (process())</td><td>{a=2,b=20,c=1000}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=3,b=40,c=2}</td><td>{a=3,b=40,c=2}</td></tr>\n <tr><td>Data (process())</td><td>{a=10,b=5}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{d=55,b=12}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{d=22,a=4}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{d=4,a=3,g=5,h=44}</td><td>{d=4,a=3,g=5,h=44}</td></tr>\n <tr><td>End Window (endWindow())</td><td>N/A</td><td>N/A</td></tr>\n </table>\n <br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "compare",
               "optional" : true,
               "description" : "Output port that emits a hashmap of matching number tuples after comparison.",
               "tupleType" : "java.util.HashMap<K, V>"
            },
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "description" : "The output port which emits filtered key value pairs.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "displayName" : "Compare Map"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port which receives incoming key value pairs.",
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.math.CompareStringMap",
         "tags" : [
            "comparison",
            "key value",
            "string",
            "map"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "emitError",
               "type" : "boolean",
               "canSet" : true,
               "description" : "emitError",
               "canGet" : true
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator compares String tuples based on the property \"key\", \"value\", and \"cmp\" and all matching tuples are emitted",
         "longDesc" : " <p>\n If the tuple passed the test, it is emitted on the output port \"compare\".&nbsp; The comparison is done by parsing double value from the String.\n This module is a pass through<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,String&gt;<br>\n <b>compare</b>: emits HashMap&lt;K,String&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n <b>Specific run time checks</b>:<br>\n Does the incoming HashMap have the key<br>\n Is the value of the key a number<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "compare",
               "optional" : true,
               "description" : "Output port that emits a hashmap of matching string tuples after comparison.",
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            },
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "description" : "The output port which emits filtered key value pairs.",
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "displayName" : "Compare String Map"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port that takes key value pair.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.CountKeyVal",
         "tags" : [
            "count",
            "key value",
            "aggregate"
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This Operator aggregates occurrence of keys in &lt;key,value&gt; pair at input port.&lt;Key,Occurrence count&gt; pair is emitted for each input on output port",
         "longDesc" : " <p>\n <br>\n StateFull : Yes, key occurrence is aggregated over windows. <br>\n Partitions : Yes, count occurrence unifier at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V&gt;<br>\n <b>count</b>: emits KeyValPair&lt;K,Integer&gt;</b><br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "description" : "Key, occurrence value pair output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>"
            }
         ],
         "displayName" : "Count Key Value"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port that takes a map of &lt;key,value&gt;.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.CountMap",
         "tags" : [
            "count",
            "key value",
            "aggregate",
            "map"
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "Operator aggregates &lt;key,occurrence&gt; count in map from &lt;key,value&gt; map input port",
         "longDesc" : " <p>\n Emits the count of occurrences of each key at the end of window. <br>\n <br>\n StateFull : Yes, each key occurrence are counted till end windows is seen. <br>\n Partitions : Yes, hash sum unifier on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>count</b>: emits HashMap&lt;K,Integer&gt;<br>\n <br>\n <b>Properties</b>: <br>\n  counts : Key occurrence aggregate map.\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "description" : "Key, occurrence value hashmap output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            }
         ],
         "displayName" : "Count Map"
      },
      {
         "inputPorts" : [
            {
               "name" : "denominator",
               "optional" : false,
               "description" : "Denominator input port.",
               "tupleType" : "class java.lang.Number"
            },
            {
               "name" : "numerator",
               "optional" : false,
               "description" : "Numerator input port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.Division",
         "tags" : [
            "division",
            "number",
            "idempotent"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator does division metric on consecutive tuples on ports",
         "longDesc" : " <p>\n The operator is idempotent as the division is done in order, i.e. the first number on denominator port would divide the first number on the numerator port.<p>\n This is a pass through operator<br>\n <br>\n StateFull : No, quotient is calculated in current window.\n Partitions : Yes, since each denominator and numerator are treated indiviually.\n <p>\n <b>Ports</b>:<br>\n <b>numerator</b>: expects Number<br>\n <b>denominator</b>: expects Number<br>\n <b>longQuotient</b>: emits Long<br>\n <b>integerQuotient</b>: emits Integer<br>\n <b>doubleQuotient</b>: emits Double<br>\n <b>floatQuotient</b>: emits Float<br>\n <b>longRemainder</b>: emits Long<br>\n <b>integerRemainder</b>: emits Integer<br>\n <b>doubleRemainder</b>: emits Double<br>\n <b>floatRemainder</b>: emits Float<br>\n <b>errordata</b>: emits String<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "doubleQuotient",
               "optional" : true,
               "description" : "Double quotient output port.",
               "tupleType" : "class java.lang.Double"
            },
            {
               "error" : false,
               "name" : "doubleRemainder",
               "optional" : true,
               "description" : "Double remainder output port.",
               "tupleType" : "class java.lang.Double"
            },
            {
               "error" : true,
               "name" : "errorData",
               "optional" : true,
               "description" : "Error data output port that emits a string.",
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "floatQuotient",
               "optional" : true,
               "description" : "Float quotient output port.",
               "tupleType" : "class java.lang.Float"
            },
            {
               "error" : false,
               "name" : "floatRemainder",
               "optional" : true,
               "description" : "Float remainder output port.",
               "tupleType" : "class java.lang.Float"
            },
            {
               "error" : false,
               "name" : "integerQuotient",
               "optional" : true,
               "description" : "Integer quotient output port.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "integerRemainder",
               "optional" : true,
               "description" : "Integer remainder output port.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "longQuotient",
               "optional" : true,
               "description" : "Long quotient output port.",
               "tupleType" : "class java.lang.Long"
            },
            {
               "error" : false,
               "name" : "longRemainder",
               "optional" : true,
               "description" : "Long remainder output port.",
               "tupleType" : "class java.lang.Long"
            }
         ],
         "displayName" : "Division"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port which receives incoming key value pairs.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.ExceptMap",
         "tags" : [
            "comparison",
            "number"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator does comparison on tuple sub-classed from Number based on the property \"key\", \"value\", and \"cmp\", and not matched tuples are emitted",
         "longDesc" : " <p>\n The comparison is done by getting double value from the Number. Both output ports\n are optional, but at least one has to be connected\n <p>\n This module is a pass through<br>\n <br>\n <br>\n StateFull : No, output is emitted in current window. <br>\n Partitions : Yes, No state dependency among input tuples. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>except</b>: emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\",\n \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\",\n \"gte\"<br>\n <br>\n <b>Run time checks</b>:<br>\n Does the incoming HashMap have the key, Is the value of the key a number<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "except",
               "optional" : true,
               "description" : "Output port that emits non matching number tuples.",
               "tupleType" : "java.util.HashMap<K, V>"
            },
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "description" : "The output port which emits filtered key value pairs.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "displayName" : "Except Map"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port which receives incoming key value pairs.",
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.math.ExceptStringMap",
         "tags" : [
            "comparison",
            "string",
            "key value"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "emitError",
               "type" : "boolean",
               "canSet" : true,
               "description" : "emitError",
               "canGet" : true
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator does comparison on tuple sub-classed from String based on the property \"key\", \"value\", and \"cmp\", and not matched tuples are emitted",
         "longDesc" : " <p>\n The comparison is done by parsing double value from the String.\n Both output ports are optional, but at least one has to be connected.\n This module is a pass through<br>\n <br>\n StateFull : No, output is computed during current window. <br>\n Partitions : Yes, no state dependency among input tuples. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,String&gt;<br>\n <b>except</b>: emits HashMap&lt;K,String&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\",\n \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Compile time checks</b>:<br>\n Key must be non empty (has to be set)<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\",\n \"gte\"<br>\n <br>\n <b>Specific run time checks</b>:<br>\n Does the incoming HashMap have the key<br>\n Is the value of the key a number<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "except",
               "optional" : true,
               "description" : "Output port that emits non matching string tuples.",
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            },
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "description" : "The output port which emits filtered key value pairs.",
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "displayName" : "Except String Map"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "Input port that takes a comparable to compare it with a constant.",
               "tupleType" : "java.lang.Comparable<? super T>"
            }
         ],
         "name" : "com.datatorrent.lib.math.LogicalCompareToConstant",
         "tags" : [
            "comparison",
            "logical",
            "key value",
            "constant"
         ],
         "properties" : [
            {
               "name" : "constant",
               "type" : "java.lang.Comparable",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator does a logical comparison of a constant with a tuple",
         "longDesc" : " <p>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "equalTo",
               "optional" : true,
               "description" : "Equal output port.",
               "tupleType" : "java.lang.Comparable<? super T>"
            },
            {
               "error" : false,
               "name" : "greaterThan",
               "optional" : true,
               "description" : "Greater than output port.",
               "tupleType" : "java.lang.Comparable<? super T>"
            },
            {
               "error" : false,
               "name" : "greaterThanOrEqualTo",
               "optional" : true,
               "tupleType" : "java.lang.Comparable<? super T>"
            },
            {
               "error" : false,
               "name" : "lessThan",
               "optional" : true,
               "description" : "Less Than output port.",
               "tupleType" : "java.lang.Comparable<? super T>"
            },
            {
               "error" : false,
               "name" : "lessThanOrEqualTo",
               "optional" : true,
               "tupleType" : "java.lang.Comparable<? super T>"
            },
            {
               "error" : false,
               "name" : "notEqualTo",
               "optional" : true,
               "description" : "Not Equal output port.",
               "tupleType" : "java.lang.Comparable<? super T>"
            }
         ],
         "displayName" : "Logical Compare To Constant"
      },
      {
         "inputPorts" : [
            {
               "name" : "denominator",
               "optional" : false,
               "description" : "Denominator input port.",
               "tupleType" : "class java.lang.Number"
            },
            {
               "name" : "numerator",
               "optional" : false,
               "description" : "Numerator input port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.Margin",
         "tags" : [
            "sum",
            "division",
            "numeric"
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "percent",
               "type" : "boolean",
               "canSet" : true,
               "description" : "percent",
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator sums the division of numerator and denominator value arriving at input ports",
         "longDesc" : "\n <p>\n <br>\n Margin Formula used by this operator: 1 - numerator/denominator.<br>\n If percent flag is set then margin is emitted as percentage.\n <br>\n StateFull : Yes, numerator and denominator are summed for application\n windows. <br>\n Partitions : No, will yield wrong margin result, no unifier on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>numerator</b>: expects V extends Number<br>\n <b>denominator</b>: expects V extends Number<br>\n <b>margin</b>: emits Double<br>\n <br>\n <b>Properties:<b>\n <br>\n <b>percent: </b>  output margin as percentage value.",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "margin",
               "optional" : true,
               "description" : "Output margin port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "displayName" : "Margin"
      },
      {
         "inputPorts" : [
            {
               "name" : "denominator",
               "optional" : false,
               "description" : "Denominator input port that takes a key value pair.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            },
            {
               "name" : "numerator",
               "optional" : false,
               "description" : "Numerator input port that takes a key value pair.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.MarginKeyVal",
         "tags" : [
            "sum",
            "division",
            "numeric",
            "key value"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "percent",
               "type" : "boolean",
               "canSet" : true,
               "description" : "percent",
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "This operator adds all values for each key in \"numerator\" and \"denominator\", and emits the margin for each key at the end of window",
         "longDesc" : " <p>\n <br>\n Margin Formula used by this operator: 1 - numerator/denominator.\n The values are added for each key within the window and for each stream.<br>\n <br>\n <b>Ports</b>:<br>\n <b>numerator</b>: expects KeyValPair&lt;K,V&gt;<br>\n <b>denominator</b>: expects KeyValPair&lt;K,V&gt;<br>\n <b>margin</b>: emits HashMap&lt;K,Double&gt;, one entry per key per window<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "margin",
               "optional" : true,
               "description" : "Output margin port that emits Key Value pairs.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "displayName" : "Margin Key Value"
      },
      {
         "inputPorts" : [
            {
               "name" : "denominator",
               "optional" : false,
               "description" : "Denominator input port that takes a map.",
               "tupleType" : "java.util.Map<K, V>"
            },
            {
               "name" : "numerator",
               "optional" : false,
               "description" : "Numerator input port that takes a map.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.MarginMap",
         "tags" : [
            "sum",
            "division",
            "numeric",
            "map"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "percent",
               "type" : "boolean",
               "canSet" : true,
               "description" : "percent",
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "This operator adds all values for each key in \"numerator\" and \"denominator\", and emits the margin for each key at the end of window",
         "longDesc" : " <p>\n Margin is calculated as  1 - SUM(numerator)/SUM(denominator).\n <br>The values are added for each key within the window and for each stream.<br>\n <br>\n <b>Ports</b>:<br>\n <b>numerator</b>: expects Map&lt;K,V&gt;<br>\n <b>denominator</b>: expects Map&lt;K,V&gt;<br>\n <b>margin</b>: emits HashMap&lt;K,Double&gt;, one entry per key per window<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "margin",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "displayName" : "Margin Map"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port that takes a key value pair and compares to max and stores the new max.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.MaxKeyVal",
         "tags" : [
            "maximum",
            "numeric",
            "key value"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "This operator emits maximum of all values sub-classed from Number at end of window for each key in KeyValPair",
         "longDesc" : "\n <p>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>max</b>: emits KeyValPair&lt;K,V extends Number&gt;, one entry per key<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "max",
               "optional" : true,
               "description" : "Max value output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "displayName" : "Maximum Key Value"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port which takes a key vaue pair and updates the value for each key if there is a new min.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.MinKeyVal",
         "tags" : [
            "minimum",
            "numeric",
            "key value"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "This operator emits minimum of all values sub-classed from Number for each key in KeyValPair at end of window",
         "longDesc" : "<p>\n <br>\n\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>min</b>: emits KeyValPair&lt;K,V extends Number&gt;, one entry per key<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "min",
               "optional" : true,
               "description" : "Min value output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "displayName" : "Minimum Key Value"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "Input number port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.MultiplyByConstant",
         "tags" : [
            "multiplication",
            "constant",
            "numeric"
         ],
         "properties" : [
            {
               "name" : "multiplier",
               "type" : "java.lang.Number",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "Multiplies input tuple (Number) by the value of property \"multiplier\" and emits the result on respective ports",
         "longDesc" : " <p>\n This operator emits the result as Long on port \"longProduct\", as Integer on port \"integerProduct\", as Double on port \"doubleProduct\", and as Float on port \"floatProduct\". \n Output is computed in current window.No state dependency among input tuples\n This is a pass through operator\n <br>\n <b>StateFull : No </b>, output is computed in current window. <br>\n <b>Partitions : Yes </b>, No state dependency among input tuples. <br>\n <br>\n <b>Ports</b>:<br>\n <b>input</b>: expects Number<br>\n <b>longProduct</b>: emits Long<br>\n <b>integerProduct</b>: emits Integer<br>\n <b>doubleProduct</b>: emits Double<br>\n <b>floatProduct</b>: emits Float<br>\n <br>\n <b>Properties</b>:<br>\n <b>multiplier</b>: Number to multiply input tuple with<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "doubleProduct",
               "optional" : true,
               "description" : "Double output port.",
               "tupleType" : "class java.lang.Double"
            },
            {
               "error" : false,
               "name" : "floatProduct",
               "optional" : true,
               "description" : "Float output port.",
               "tupleType" : "class java.lang.Float"
            },
            {
               "error" : false,
               "name" : "integerProduct",
               "optional" : true,
               "description" : "Integer output port.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "longProduct",
               "optional" : true,
               "description" : "Long output port.",
               "tupleType" : "class java.lang.Long"
            }
         ],
         "displayName" : "Multiply By Constant"
      },
      {
         "inputPorts" : [
            {
               "name" : "denominator",
               "optional" : false,
               "description" : "Denominator values input port.",
               "tupleType" : "class java.lang.Number"
            },
            {
               "name" : "numerator",
               "optional" : false,
               "description" : "Numerator values input port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.Quotient",
         "tags" : [
            "division",
            "sum",
            "numeric"
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "mult_by",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator adds all the values on \"numerator\" and \"denominator\" and emits quotient at end of window",
         "longDesc" : "\n <p>\n <br>\n <b>StateFull : Yes </b>, Sum of values is taken over application window. <br>\n <b>Partitions : No </b>, will yield wrong results, since values are\n accumulated over application window. <br>\n <br>\n <b>Ports</b>:<br>\n <b>numerator</b>: expects V extends Number<br>\n <b>denominator</b>: expects V extends Number<br>\n <b>quotient</b>: emits Double<br>\n <br>\n <b>Properties : </b> <br>\n <b>mult_by : </b>Multiply by value(default = 1). <br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "quotient",
               "optional" : true,
               "description" : "Quotient output port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "displayName" : "Quotient"
      },
      {
         "inputPorts" : [
            {
               "name" : "denominator",
               "optional" : false,
               "description" : "Denominator input port.",
               "tupleType" : "java.util.Map<K, V>"
            },
            {
               "name" : "numerator",
               "optional" : false,
               "description" : "Numerator input port.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.QuotientMap",
         "tags" : [
            "division",
            "sum",
            "map"
         ],
         "properties" : [
            {
               "name" : "countkey",
               "type" : "boolean",
               "canSet" : true,
               "description" : "countkey",
               "canGet" : true
            },
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "mult_by",
               "type" : "int",
               "canSet" : true,
               "description" : "mult_by",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "Add all the values for each key on \"numerator\" and \"denominator\" and emits quotient at end of window for all keys in the denominator",
         "longDesc" : "\n <p>\n <br>\n Application can set multiplication value for quotient(default = 1). <br>\n Operator will calculate quotient of occurrence of key in numerator divided by\n occurrence of key in denominator if countKey flag is true. <br>\n Application can allow or block keys by setting filter key and inverse flag. <br>\n <br>\n <b>StateFull : Yes</b>, numerator/denominator values are summed over\n application window. <br>\n <b>Partitions : No, </b>, will yield wrong results, since values are summed\n over app window. <br>\n <br>\n <b>Ports</b>:<br>\n <b>numerator</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>denominator</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>quotient</b>: emits HashMap&lt;K,Double&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse :</b> if set to true the key in the filter will block tuple<br>\n <b>filterBy :</b> List of keys to filter on<br>\n <b>countkey :</b> Get quotient of occurrence of keys in numerator and\n denominator. <br>\n <b>mult_by :</b> Set multiply by constant value. <br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "quotient",
               "optional" : true,
               "description" : "Quotient output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Double>"
            }
         ],
         "displayName" : "Quotient Map"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.Range",
         "tags" : [
            "range",
            "numeric",
            "comparison"
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator emits the range of values at the end of window",
         "longDesc" : " <p>\n <br>\n <b>StateFull : Yes</b>, values are computed over application time window. <br>\n <b>Partitions : Yes </b>, High/Low values are unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects V extends Number<br>\n <b>range</b>: emits HighLow&lt;V&gt;<br>\n <br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "range",
               "optional" : true,
               "description" : "Output range port, which emits high low unifier operator.",
               "tupleType" : "com.datatorrent.lib.util.HighLow<V>"
            }
         ],
         "displayName" : "Range"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port that takes a key value pair.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.RangeKeyVal",
         "tags" : [
            "range",
            "number",
            "comparison",
            "key value"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "This operator emits the range for each key at the end of window",
         "longDesc" : "\n <p>\n <br>\n <b>StateFull : Yes</b>, values are computed over application window. <br>\n <b>Partitions : Yes, </b> high/low values are each key is unified at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>range</b>: emits KeyValPair&lt;K,HighLow&lt;V&gt;&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "range",
               "optional" : true,
               "description" : "Range output port to send out the high low range.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, com.datatorrent.lib.util.HighLow<V>>"
            }
         ],
         "displayName" : "Range Key Value"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port that takes a map and computes new high and low values.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.RangeMap",
         "tags" : [
            "range",
            "number",
            "comparison",
            "map"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "Emits the range for each key at the end of window",
         "longDesc" : "\n <p>\n Application can allow or block keys by setting filter keys and inverse flag.\n <br>\n <b>StateFull : Yes</b>, values are computed over application window. <br>\n <b>Partitions : Yes</b>, values are unified at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>range</b>: emits HashMap&lt;K,HighLow&lt;V&gt;&gt; each key has two entries; .get(0) gives Max, .get(1) gives Min<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "range",
               "optional" : true,
               "description" : "Output range port.",
               "tupleType" : "java.util.HashMap<K, com.datatorrent.lib.util.HighLow<V>>"
            }
         ],
         "displayName" : "Range Map"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "Input number port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.RunningAverage",
         "tags" : [
            "average",
            "numeric"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "Calculate the running average of the input numbers and emit it at the end of the window",
         "longDesc" : "\n <p>\n This is an end of window operator.<br>\n <br>\n <b>StateFull : Yes</b>, average is computed over application window. <br>\n <b>Partitions : No</b>, will yield wrong results. <br>\n <br>\n <b>Ports</b>:<br>\n <b>input</b>: expects Number<br>\n <b>longAverage</b>: emits Long<br>\n <b>integerAverage</b>: emits Integer<br>\n <b>doubleAverage</b>: emits Double<br>\n <b>floatAverage</b>: emits Float<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "doubleAverage",
               "optional" : true,
               "description" : "Double average output port.",
               "tupleType" : "class java.lang.Double"
            },
            {
               "error" : false,
               "name" : "floatAverage",
               "optional" : true,
               "description" : "Float average output port.",
               "tupleType" : "class java.lang.Float"
            },
            {
               "error" : false,
               "name" : "integerAverage",
               "optional" : true,
               "description" : "Integer average output port.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "longAverage",
               "optional" : true,
               "description" : "Long average output port.",
               "tupleType" : "class java.lang.Long"
            }
         ],
         "displayName" : "Running Average"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "Input port, accepts collection of values of type 'T'.",
               "tupleType" : "java.util.Collection<T>"
            }
         ],
         "name" : "com.datatorrent.lib.math.Sigma",
         "tags" : [
            "aggregate",
            "numeric",
            "collection"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "Adds incoming tuple to the state and emits the result of each addition on the respective ports",
         "longDesc" : " <p>\n The addition would go on forever.Result is emitted on four different data type ports:floatResult,integerResult,longResult,doubleResult.\n Input tuple object has to be an implementation of the interface Collection.Tuples are emitted on the output ports only if they are connected. \n This is done to avoid the cost of calling the functions when some ports are not connected.\n This is a stateful pass through operator<br>\n <b>Partitions : </b>, no will yield wrong results, no unifier on output port.\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Collection&lt;T extends Number&lt;<br>\n <b>doubleResult</b>: emits Double<br>\n <b>floatResult</b>: emits Float<br>\n <b>integerResult</b>: emits Integer<br>\n <b>longResult</b>: emits Long<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "doubleResult",
               "optional" : true,
               "description" : "Double type output.",
               "tupleType" : "class java.lang.Double"
            },
            {
               "error" : false,
               "name" : "floatResult",
               "optional" : true,
               "description" : "Float type output.",
               "tupleType" : "class java.lang.Float"
            },
            {
               "error" : false,
               "name" : "integerResult",
               "optional" : true,
               "description" : "Integer type output.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "longResult",
               "optional" : true,
               "description" : "Long type output.",
               "tupleType" : "class java.lang.Long"
            }
         ],
         "displayName" : "Sigma"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "Input number port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.SquareCalculus",
         "tags" : [
            "numeric",
            "square",
            "multiplication"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "Emits the result as square of the input tuple which is a number",
         "longDesc" : " <p>\n Emits the result as Long on port longResult, as Integer on port integerResult,\n as Double on port doubleResult, and as Float on port floatResult.\n This is a pass through operator\n <br>\n <b>Ports</b>:<br>\n <b>input</b>: expects Number<br>\n <b>longResult</b>: emits Long<br>\n <b>integerResult</b>: emits Integer<br>\n <b>doubleResult</b>: emits Double<br>\n <b>floatResult</b>: emits Float<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "doubleResult",
               "optional" : true,
               "description" : "Double type output.",
               "tupleType" : "class java.lang.Double"
            },
            {
               "error" : false,
               "name" : "floatResult",
               "optional" : true,
               "description" : "Float type output.",
               "tupleType" : "class java.lang.Float"
            },
            {
               "error" : false,
               "name" : "integerResult",
               "optional" : true,
               "description" : "Integer type output.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "longResult",
               "optional" : true,
               "description" : "Long type output.",
               "tupleType" : "class java.lang.Long"
            }
         ],
         "displayName" : "Square Calculus"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port that takes a map.&nbsp; It adds the values for each key and counts the number of occurrences for each key.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.SumCountMap",
         "tags" : [
            "number",
            "sum",
            "counting",
            "map"
         ],
         "properties" : [
            {
               "name" : "cumulative",
               "type" : "boolean",
               "canSet" : true,
               "description" : "cumulative flag",
               "canGet" : true
            },
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "Emits the sum and count of values for each key at the end of window",
         "longDesc" : " <p>\n Application accumulate sum across streaming window by setting cumulative flag\n to true. <br>\n This is an end of window operator<br>\n <br>\n <b>StateFull : Yes</b>, Sum is computed over application window and streaming\n window. <br>\n <b>Partitions : Yes</b>, Sum is unified at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>sum</b>: emits HashMap&lt;K,V&gt;<br>\n <b>count</b>: emits HashMap&lt;K,Integer&gt;</b><br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <b>cumulative</b>: boolean flag, if set the sum is not cleared at the end of\n window, <br>\n hence generating cumulative sum across streaming windows. Default is false.<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "description" : "Key,integer sum output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "sum",
               "optional" : true,
               "description" : "Key,sum map output port.",
               "tupleType" : "java.util.HashMap<K, V>"
            },
            {
               "error" : false,
               "name" : "sumDouble",
               "optional" : true,
               "description" : "Key,double sum map output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Double>"
            },
            {
               "error" : false,
               "name" : "sumFloat",
               "optional" : true,
               "description" : "Key,float sum output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Float>"
            },
            {
               "error" : false,
               "name" : "sumInteger",
               "optional" : true,
               "description" : "Key,integer sum output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "sumLong",
               "optional" : true,
               "description" : "Key,long sum output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Long>"
            },
            {
               "error" : false,
               "name" : "sumShort",
               "optional" : true,
               "description" : "Key,short sum output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Short>"
            }
         ],
         "displayName" : "Sum Count Map"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port that takes key value pairs and adds the values for each key.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.SumKeyVal",
         "tags" : [
            "numeric",
            "sum",
            "key value"
         ],
         "properties" : [
            {
               "name" : "cumulative",
               "type" : "boolean",
               "canSet" : true,
               "description" : "cumulative flag.",
               "canGet" : true
            },
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "Emits the sum of values for each key at the end of window",
         "longDesc" : "\n <p> \n This is an end window operator. Default unifier works as this operator follows sticky partition.<br> <br> <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br> <b>sum</b>: emits KeyValPair&lt;K,V extends Number&gt;<br> <br> <b>Properties</b>:<br> <b>inverse</b>: If set to true the key in the\n filter will block tuple<br> <b>filterBy</b>: List of keys to filter on<br>\n <b>cumulative</b>: boolean flag, if set the sum is not cleared at the end of window, <br>\n hence generating cumulative sum\n across streaming windows. Default is false.<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "sum",
               "optional" : true,
               "description" : "Output sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            },
            {
               "error" : false,
               "name" : "sumDouble",
               "optional" : true,
               "description" : "Output double sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Double>"
            },
            {
               "error" : false,
               "name" : "sumFloat",
               "optional" : true,
               "description" : "Output float sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Float>"
            },
            {
               "error" : false,
               "name" : "sumInteger",
               "optional" : true,
               "description" : "Output integer sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "sumLong",
               "optional" : true,
               "description" : "Output long sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Long>"
            },
            {
               "error" : false,
               "name" : "sumShort",
               "optional" : true,
               "description" : "Output short sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Short>"
            }
         ],
         "displayName" : "Sum Key Value"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port that takes a map and adds the values for each key.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.SumMap",
         "tags" : [
            "numeric",
            "sum",
            "map"
         ],
         "properties" : [
            {
               "name" : "cumulative",
               "type" : "boolean",
               "canSet" : true,
               "description" : "cumulative flag",
               "canGet" : true
            },
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "Emits the sum of values for each key at the end of window",
         "longDesc" : " <p>\n This is an end of window operator<br>\n <br>\n <b>StateFull : Yes</b>, sum is computed over application window. <br>\n <b>Partitions : Yes</b>, sum is unified at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>sum</b>: emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <b>cumulative</b>: boolean flag, if set the sum is not cleared at the end of window, <br>\n hence generating cumulative sum across streaming windows. Default is false.<br>\n <br>",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "sum",
               "optional" : true,
               "description" : "Sum output port.",
               "tupleType" : "java.util.HashMap<K, V>"
            },
            {
               "error" : false,
               "name" : "sumDouble",
               "optional" : true,
               "description" : "Double sum output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Double>"
            },
            {
               "error" : false,
               "name" : "sumFloat",
               "optional" : true,
               "description" : "Float sum output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Float>"
            },
            {
               "error" : false,
               "name" : "sumInteger",
               "optional" : true,
               "description" : "Integer sum output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "sumLong",
               "optional" : true,
               "description" : "Long sum output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Long>"
            },
            {
               "error" : false,
               "name" : "sumShort",
               "optional" : true,
               "description" : "Short sum output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Short>"
            }
         ],
         "displayName" : "Sum Map"
      },
      {
         "inputPorts" : [
            {
               "name" : "XMLInput",
               "optional" : false,
               "description" : "This port receives the tuples which will be parsed as xml.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.math.XmlKeyValueStringCartesianProduct",
         "tags" : [
            "cartesian product",
            "string",
            "xml"
         ],
         "properties" : [
            {
               "name" : "config",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "delim",
               "type" : "java.lang.String",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of the AbstractXmlKeyValueCartesianProduct operator that takes in the xml document\n as a String input and outputs the cartesian product as Strings.",
         "category" : "Math",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "description" : "Output port that emits cartesian product as Strings.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "displayName" : "Xml Key Value String Cartesian Product"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port that takes a key value pair.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.multiwindow.MultiWindowRangeKeyVal",
         "tags" : [
            "key value",
            "range",
            "numeric"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "windowSize",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "A range operator of KeyValPair schema which calculates range across multiple streaming windows",
         "longDesc" : " <p>\n This is an end window operator which emits only at Nth window. <br>\n <br>\n <b>StateFull : Yes</b>, computes across multiple windows. <br>\n <b>Partitions : Yes</b>, high/low are unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>range</b>: emits KeyValPair&lt;K,HighLow&lt;V&gt;&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>\n <b>Specific compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None<br>\n <b>windowSize i.e. N</b>: Number of streaming windows that define application window.<br>\n <br>",
         "category" : "Multi-Window",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "range",
               "optional" : true,
               "description" : "Range output port to send out the high low range.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, com.datatorrent.lib.util.HighLow<V>>"
            }
         ],
         "displayName" : "Multi Window Range Key Value"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port that takes key value pairs and adds the values for each key.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.multiwindow.MultiWindowSumKeyVal",
         "tags" : [
            "key value",
            "sum",
            "numeric"
         ],
         "properties" : [
            {
               "name" : "cumulative",
               "type" : "boolean",
               "canSet" : true,
               "description" : "cumulative flag.",
               "canGet" : true
            },
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "windowSize",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "A sum operator of KeyValPair schema which accumulates sum across multiple\n streaming windows",
         "longDesc" : " <p>\n This is an end window operator which emits only at Nth window. <br>\n <br>\n <b>StateFull : Yes, </b> sum is computed across streaming windows.  <br>\n <b>Partitions : No, </b> sum is not unified at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>sum</b>: emits KeyValPair&lt;K,V&gt;<br>\n <b>count</b>: emits KeyValPair&lt;K,Integer&gt;</b><br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: If set to true the key in the filter will block tuple.<br>\n <b>filterBy</b>: List of keys to filter on.<br>\n <b>windowSize i.e. N</b>: Number of streaming windows that define application\n window.<br>\n <br>",
         "category" : "Multi-Window",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "sum",
               "optional" : true,
               "description" : "Output sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            },
            {
               "error" : false,
               "name" : "sumDouble",
               "optional" : true,
               "description" : "Output double sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Double>"
            },
            {
               "error" : false,
               "name" : "sumFloat",
               "optional" : true,
               "description" : "Output float sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Float>"
            },
            {
               "error" : false,
               "name" : "sumInteger",
               "optional" : true,
               "description" : "Output integer sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "sumLong",
               "optional" : true,
               "description" : "Output long sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Long>"
            },
            {
               "error" : false,
               "name" : "sumShort",
               "optional" : true,
               "description" : "Output short sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Short>"
            }
         ],
         "displayName" : "Multi Window Sum Key Value"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port for getting incoming data.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.multiwindow.SimpleMovingAverage",
         "tags" : [
            "key value",
            "numeric",
            "average"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "windowSize",
               "type" : "int",
               "canSet" : true,
               "description" : "windowSize",
               "canGet" : true
            }
         ],
         "shortDesc" : "Calculates simple moving average (SMA) of last N window",
         "longDesc" : "<br>\n <br>\n <b>StateFull : Yes</b>, operator store values  for n-1 th windows. <br>\n <b>Partitions : No</b>, sum is not unified on output ports. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Expects KeyValPair where K is Object and V is Number.<br>\n <b>doubleSMA</b>: Emits simple moving average of N window as Double.<br>\n <b>floatSMA</b>: Emits simple moving average of N window as Float.<br>\n <b>longSMA</b>: Emits simple moving average of N window as Long.<br>\n <b>integerSMA</b>: Emits simple moving average of N window as Integer.<br>\n <br>\n <b>Properties</b>:<br>\n <b>windowSize</b>: Number of windows to keep state on<br>\n <br>",
         "category" : "Multi-Window",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "doubleSMA",
               "optional" : true,
               "description" : "Output port to emit simple moving average (SMA) of last N window as Double.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Double>"
            },
            {
               "error" : false,
               "name" : "floatSMA",
               "optional" : true,
               "description" : "Output port to emit simple moving average (SMA) of last N window as Float.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Float>"
            },
            {
               "error" : false,
               "name" : "integerSMA",
               "optional" : true,
               "description" : "Output port to emit simple moving average (SMA) of last N window as\n Integer.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "longSMA",
               "optional" : true,
               "description" : "Output port to emit simple moving average (SMA) of last N window as Long.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Long>"
            }
         ],
         "displayName" : "Simple Moving Average"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port for getting incoming data.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.multiwindow.SortedMovingWindow",
         "tags" : [
            "sort",
            "list",
            "function",
            "sliding window"
         ],
         "properties" : [
            {
               "name" : "comparator",
               "type" : "java.util.Comparator",
               "canSet" : true,
               "canGet" : false,
               "properties" : []
            },
            {
               "name" : "function",
               "type" : "com.google.common.base.Function",
               "canSet" : true,
               "canGet" : false,
               "properties" : []
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "windowSize",
               "type" : "int",
               "canSet" : false,
               "description" : "n",
               "canGet" : true
            }
         ],
         "shortDesc" : "Provides a sliding window class that sorts all incoming tuples within the window and emit them in the right order",
         "longDesc" : " <p>\n Generally, given tuples T, keys K, windows W. All T within Window W are split into |K| buckets and <br>\n sort the bucket in the order that Tp_Ki < Tq_Ki if (comparator.compare(Tp_Ki, Tq_Ki) < 0 || ((Tp_Ki instance of Comparable) && Tp_Ki.compareTo(Tq_Ki) <0))</p>\n\n <b>Properties</b>:<br>\n <b>T</b> is the tuple object the operator can process <br>\n <b>K</b> is the key object used to categorize the tuples within the sliding window<br>\n <b>function</b>: is used transform the tuple T to group key K. It's used to split all tuples into |K| group and sorted them in the group<br>\n by default: function is SingleKeyMappingFunction which map all t to null (all tuples are grouped into one group)\n <br><b>comparator</b>: is used to determine the order of the tuple<br>\n by default: comparator is null which means the tuple must be comparable\n <p></p>",
         "category" : "Multi-Window",
         "outputPorts" : [
            {
               "error" : true,
               "name" : "errorOutput",
               "optional" : true,
               "description" : "Output port to emit error output.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "error" : false,
               "name" : "sortedOutput",
               "optional" : true,
               "description" : "Output port to emit sorted output.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "displayName" : "Sorted Moving Window"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport1",
               "optional" : false,
               "description" : "Input port 1 that takes map of &lt;String, Object&gt.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            },
            {
               "name" : "inport2",
               "optional" : false,
               "description" : "Input port 2 that takes map of &lt;String, Object&gt.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.pigquery.PigCrossOperator",
         "tags" : [
            "map",
            "string",
            "cross product operator"
         ],
         "properties" : [],
         "shortDesc" : "An implementation of Operator that implements Apache Pig Cross operator semantic",
         "longDesc" : " <p>\n <pre>\n Example\n Suppose we have relations A and B.\n\n A = LOAD 'data1' AS (a1:int,a2:int,a3:int);\n\n DUMP A;\n (1,2,3)\n (4,2,1)\n\n B = LOAD 'data2' AS (b1:int,b2:int);\n\n DUMP B;\n (2,4)\n (8,9)\n (1,3)\n In this example the cross product of relation A and B is computed.\n\n X = CROSS A, B;\n\n DUMP X;\n (1,2,3,2,4)\n (1,2,3,8,9)\n (1,2,3,1,3)\n (4,2,1,2,4)\n (4,2,1,8,9)\n (4,2,1,1,3)\n </pre>\n  <br>\n <b>StateFull : </b> Yes, tuples are collected over application window. <br>\n <b>Partitions : </b> No, will yield wrong result. <br>\n <br>\n This operator is pass thru operator. <br>\n <br>\n <b>Ports : </b> <br>\n <b> inport1 : </b> expects tuple of form Map&lt;String, Object&gt; <br>\n <b> inport2 : </b> expects tuple of form Map&lt;String, Object&gt; <br>\n <b> outport : </b> emits tuple of form Map&lt;String, Object&gt; <br>",
         "category" : "Pig Query",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port that emits a map of &lt;String, Object&gt.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "displayName" : "Pig Cross"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port that takes map of &lt;String, Object&gt.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.pigquery.PigFilterOperator",
         "tags" : [
            "map",
            "string",
            "filter operator"
         ],
         "properties" : [
            {
               "name" : "condition",
               "type" : "com.datatorrent.lib.streamquery.condition.Condition",
               "canSet" : true,
               "description" : "Condition",
               "canGet" : true,
               "properties" : []
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseOperator that implements Apache Pig filter statement semantic",
         "longDesc" : "<br>\n <p>\n Stream rows passing condition are emitted on output port stream. <br>\n <br>\n <b>StateFull : NO,</b> all row data is processed in current time window. <br>\n <b>Partitions : Yes, </b> No Input dependency among input rows. <br>\n <br>\n <b>Ports</b>:<br>\n <b> inport : </b> Input hash map(row) port, expects\n HashMap&lt;String,Object&gt;<<br>\n <b> outport : </b> Output hash map(row) port, emits\n HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <b> <br>\n <b> condition : </b> Select condition for selecting rows. <br>",
         "category" : "Pig Query",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port that emits a map of &lt;String, Object&gt.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "displayName" : "Pig Filter"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port that takes map of &lt;String, Object&gt.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.pigquery.PigForeachOperator",
         "tags" : [
            "map",
            "string",
            "foreach operator"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "<p>An implementation of BaseOperator that implements Apache Pig ForEach Operator.</p>",
         "category" : "Pig Query",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port that emits a map of &lt;String, Object&gt.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "displayName" : "Pig ForEach"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port that takes map of &lt;String, Object&gt.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.pigquery.PigGroupOperator",
         "tags" : [
            "map",
            "string",
            "group operator",
            "condition"
         ],
         "properties" : [
            {
               "name" : "groupByCondition",
               "type" : "com.datatorrent.lib.pigquery.condition.PigGroupCondition",
               "canSet" : true,
               "description" : "GroupByCondition",
               "canGet" : true,
               "properties" : []
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseOperator that implements Apache Pig Group operator semantic",
         "longDesc" : "<br>\n <p>\n This operator does not support Group All semantic. <br>\n <pre>\n B = GROUP A BY age;\n\n DESCRIBE B;\n B: {group: int, A: {name: chararray,age: int,gpa: float}}\n\n ILLUSTRATE B;\n etc ...\n ----------------------------------------------------------------------\n | B     | group: int | A: bag({name: chararray,age: int,gpa: float}) |\n ----------------------------------------------------------------------\n |       | 18         | {(John, 18, 4.0), (Joe, 18, 3.8)}             |\n |       | 20         | {(Bill, 20, 3.9)}                             |\n ----------------------------------------------------------------------\n\n DUMP B;\n (18,{(John,18,4.0F),(Joe,18,3.8F)})\n (19,{(Mary,19,3.8F)})\n (20,{(Bill,20,3.9F)})\n </pre>\n <b>Ports : </b> <br>\n <b> inport : </b> expects tuple Map<String, Object> <br>\n <b>outport : </b> emits Map<Object, List<Map<String, Object>>> <br>\n\n <b>StateFull : </b> Yes, tuples are aggregated over application window. <br>\n <b>Partitions : </b> Yes, map unifier on output port. <br>\n\n <b>Properties : </b> <br>\n <b>groupByCondition : </b> Group condition. <br>\n <br>",
         "category" : "Pig Query",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port that emits a map of &lt;Object, List&lt;Map&lt;String, Object&gt;&gt;&gt;.",
               "tupleType" : "java.util.Map<java.lang.Object, java.util.List<java.util.Map<java.lang.String, java.lang.Object>>>"
            }
         ],
         "displayName" : "Pig Group"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport1",
               "optional" : false,
               "description" : "Input port 1 that takes a map of &lt;String, Object&gt data on which join is to be performed.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            },
            {
               "name" : "inport2",
               "optional" : false,
               "description" : "Input port 2 that takes a map of &lt;String, Object&gt data on which join is to be performed.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.pigquery.PigJoinOperator",
         "tags" : [
            "map",
            "string",
            "inner join operator"
         ],
         "properties" : [
            {
               "name" : "joinCondition",
               "type" : "com.datatorrent.lib.streamquery.condition.Condition",
               "canSet" : true,
               "description" : "Condition",
               "canGet" : true,
               "properties" : []
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseOperator that implements Pig Join(Inner) semantic on live stream",
         "longDesc" : " <p>\n <pre>\n Example\n Suppose we have relations A and B.\n\n A = LOAD 'data1' AS (a1:int,a2:int,a3:int);\n\n DUMP A;\n (1,2,3)\n (4,2,1)\n (8,3,4)\n (4,3,3)\n (7,2,5)\n (8,4,3)\n\n B = LOAD 'data2' AS (b1:int,b2:int);\n\n DUMP B;\n (2,4)\n (8,9)\n (1,3)\n (2,7)\n (2,9)\n (4,6)\n (4,9)\n In this example relations A and B are joined by their first fields.\n\n X = JOIN A BY a1, B BY b1;\n\n DUMP X;\n (1,2,3,1,3)\n (4,2,1,4,6)\n (4,3,3,4,6)\n (4,2,1,4,9)\n (4,3,3,4,9)\n (8,3,4,8,9)\n (8,4,3,8,9)\n </pre>\n <br>\n <b>Ports : </b> <br>\n <b>inport1 : </b> expects tuple Map<String, Object>. <br>\n <b>inport2 : </b> expects tuple Map<String, Object>. <br>\n <b>outport : </b> emits joined tuple Map<String, Object>. <br>\n <br>\n <b> StateFull : </b> Yes, values are aggregated over application window.  <br>\n <b> Partitions : </b> No, will yield worng results. <br>\n Operator is pass thru, output tuples are emitted in current time window.  <br>\n <br>\n <b>Properties : </b> <br>\n <b> joinCondition : </b> Tuple join condition.",
         "category" : "Pig Query",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port that emits map of &lt;String, Object&gt which is formed by inner join of input data.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "displayName" : "Pig Inner Join"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport1",
               "optional" : false,
               "description" : "Input port 1 that takes a map of &lt;String, Object&gt data on which join is to be performed.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            },
            {
               "name" : "inport2",
               "optional" : false,
               "description" : "Input port 2 that takes a map of &lt;String, Object&gt data on which join is to be performed.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.pigquery.PigJoinOuterOperator",
         "tags" : [
            "map",
            "string",
            "outer join operator"
         ],
         "properties" : [
            {
               "name" : "joinCondition",
               "type" : "com.datatorrent.lib.streamquery.condition.Condition",
               "canSet" : true,
               "description" : "Condition",
               "canGet" : true,
               "properties" : []
            },
            {
               "name" : "joinType",
               "type" : "int",
               "canSet" : true,
               "description" : "int",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseOperator that implements Pig Join(Outer) semantic on live stream",
         "longDesc" : "\n <br>\n <b>Ports : </b> <br>\n <b>inport1 : </b> expects tuple Map<String, Object>. <br>\n <b>inport2 : </b> expects tuple Map<String, Object>. <br>\n <b>outport : </b> emits joined tuple Map<String, Object>. <br>\n <br>\n <b> StateFull : </b> Yes, values are aggregated over application window.  <br>\n <b> Partitions : </b> No, will yield worng results. <br>\n Operator is end window operator, left/right/full values are emitted at end window.  <br>\n <br>\n <b>Properties : </b> <br>\n <b> joinCondition : </b> Tuple join condition.",
         "category" : "Pig Query",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port that emits map of &lt;String, Object&gt which is formed by outer join of input data.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "displayName" : "Pig Outer Join"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port that checks if port is valid for emitting tuple.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.pigquery.ThreeWayPigSplit",
         "tags" : [
            "split operator",
            "map",
            "string"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "<p>\n An implementation of BaseOperator that implements Pig split operator semantic",
         "longDesc" : "\n <p>\n A split into node creates multiple streams from a single stream. <br>\n This operator implements following semantic.  <br>\n <pre>\n instream is f1:int, f2:int, f3:int\n\n The expression for split into is \"X IF f1<7, Y IF f2==5, Z IF (f3<6)\"\n\n For instream tuples (1,2,3) would produce (1,2,3) on X, (1,2,3) on Z (4,5,6)\n would produce (4,5,6) on X, (4,5,6) on Y (7,8,9) would produce (7,8,9) on Z\n\n This would match to split into metric for Pig\n </pre>",
         "category" : "Pig Query",
         "outputPorts" : [],
         "displayName" : "Three Way Pig Split"
      },
      {
         "inputPorts" : [
            {
               "name" : "inBindings",
               "optional" : true,
               "description" : "Input inBindings port that takes in a map of &lt;String, Object&gt.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.script.JavaScriptOperator",
         "tags" : [
            "script operator",
            "map",
            "string"
         ],
         "properties" : [
            {
               "name" : "bindings",
               "type" : "java.util.Map",
               "canSet" : false,
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "empty",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "engineByName",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "eval",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "invoke",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "passThru",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "script",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "An implementation of ScriptOperator that executes JavaScript on tuples input for Map &lt;String, Object&gt;",
         "longDesc" : "\n \n <p>\n Key is name of variable used in script code. Proper map values must be provided\n by up stream operators.\n\n <b> Sample Usage Code : </b>\n\n <pre>\n // Add random integer generator operator\n SingleKeyValMap rand = dag.addOperator(&quot;rand&quot;, SingleKeyValMap.class);\n\n Script script = dag.addOperator(&quot;script&quot;, Script.class);\n // script.setEval(&quot;val = val*val;&quot;);\n script.addSetupScript(&quot;function square() { return val*val;}&quot;);\n script.setInvoke(&quot;square&quot;);\n dag.addStream(&quot;evalstream&quot;, rand.outport, script.inBindings);\n\n // Connect to output console operator\n ConsoleOutputOperator console = dag.addOperator(&quot;console&quot;,\n \t\tnew ConsoleOutputOperator());\n dag.addStream(&quot;rand_console&quot;, script.result, console.input);\n\n </pre>\n\n <b> Sample Input Operator(emit)</b>\n\n <pre>\n  \t.\n \t\t.\n \t\tpublic void emitTuples() {\n \t\t\tHashMap<String, Object> map = new HashMap<String, Object>();\n \t\t\tmap.put(\"val\", random.nextInt());\n \t\t\toutport.emit(map);\n \t\t\t.\n \t\t\t.\n \t\t}\n \t\t.\n \t\t.\n </pre>\n\n This operator does not checkpoint interpreted functions in the variable bindings because they are not serializable\n Use setupScript() to define functions, and do NOT define or assign functions to variables at run time",
         "category" : "Scripting",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outBindings",
               "optional" : true,
               "description" : "Output outBindings port that emits a map of &lt;String, Object&gt.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            },
            {
               "error" : false,
               "name" : "result",
               "optional" : true,
               "description" : "Output result port that emits an object as the result.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "displayName" : "Java Script"
      },
      {
         "inputPorts" : [
            {
               "name" : "inBindings",
               "optional" : true,
               "description" : "Input inBindings port that takes in a map of &lt;String, Object&gt.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.script.RubyOperator",
         "tags" : [
            "script operator",
            "map",
            "string"
         ],
         "properties" : [
            {
               "name" : "bindings",
               "type" : "java.util.Map",
               "canSet" : false,
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "empty",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "eval",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "invoke",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "passThru",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "script",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "An implementation of ScriptOperator that executes ruby script on tuples\n <p>",
         "category" : "Scripting",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outBindings",
               "optional" : true,
               "description" : "Output outBindings port that emits a map of &lt;String, Object&gt.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            },
            {
               "error" : false,
               "name" : "result",
               "optional" : true,
               "description" : "Output result port that emits an object as the result.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "displayName" : "Ruby Operator"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port that takes an event.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.statistics.DimensionsComputation",
         "tags" : [
            "event",
            "dimension",
            "aggregation",
            "computation"
         ],
         "properties" : [
            {
               "name" : "aggregators",
               "type" : "[Lcom.datatorrent.lib.statistics.DimensionsComputation$Aggregator;",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "unifier",
               "type" : "com.datatorrent.api.Operator$Unifier",
               "canSet" : true,
               "canGet" : false,
               "properties" : []
            }
         ],
         "shortDesc" : "<p>An implementation of an operator that computes dimensions of events",
         "longDesc" : "</p>\n <p>",
         "category" : "Statistics",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "description" : "Output port that emits an aggregate of events.",
               "tupleType" : "interface com.datatorrent.lib.statistics.DimensionsComputation$AggregateEvent"
            }
         ],
         "displayName" : "Dimension Computation"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port that takes a number.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.statistics.MedianOperator",
         "tags" : [
            "median operator",
            "number"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseOperator that computes median of incoming data",
         "longDesc" : "<br>\n <br>\n <b>Input Port(s) : </b><br>\n <b>data : </b> Data values input port. <br>\n <br>\n <b>Output Port(s) : </b> <br>\n <b>median : </b>Median output port. <br>\n <br>\n <b>StateFull : Yes</b>, value are aggregated over application window. <br>\n <b>Partitions : No</b>, no will yield wrong results. <br>\n <br>+",
         "category" : "Statistics",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "median",
               "optional" : true,
               "description" : "Output port that emits median of incoming data.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "displayName" : "Median"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port that takes comparable values.",
               "tupleType" : "java.lang.Comparable<?>"
            }
         ],
         "name" : "com.datatorrent.lib.statistics.ModeOperator",
         "tags" : [
            "numeric",
            "integer",
            "count"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseOperator that calculates most frequent value occurring in incoming data",
         "longDesc" : "<br>\n <br>\n <b>Input Port(s) : </b><br>\n <b>data : </b> Data values input port. <br>\n <br>\n <b>Output Port(s) : </b> <br>\n <b>mode : </b>Mode value output port. <br>\n <br>\n <b>StateFull : Yes</b>, value are aggregated over application window. <br>\n <b>Partitions : No</b>, no will yeild wrong results. <br>\n <br>",
         "category" : "Statistics",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mean",
               "optional" : true,
               "description" : "Output port that emits most frequent value in incoming data.",
               "tupleType" : "java.lang.Comparable<?>"
            }
         ],
         "displayName" : "Mode"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port that takes in a number.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.statistics.StandardDeviation",
         "tags" : [
            "numeric",
            "math",
            "calculation",
            "sum",
            "count"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseOperator that computes variance and standard deviation over incoming data",
         "longDesc" : "<br>\n <br>\n <b>Input Port(s) : </b><br>\n <b>data : </b> Data values input port. <br>\n <br>\n <b>Output Port(s) : </b> <br>\n <b>variance : </b>Variance value output port. <br>\n <b>standardDeviatin : </b>Variance value output port. <br>\n <br>\n <b>StateFull : Yes</b>, value are aggregated over application window. <br>\n <b>Partitions : No</b>, no will yield wrong results. <br>\n <br>",
         "category" : "Statistics",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "standardDeviation",
               "optional" : true,
               "description" : "Standard deviation output port.",
               "tupleType" : "class java.lang.Number"
            },
            {
               "error" : false,
               "name" : "variance",
               "optional" : true,
               "description" : "Variance output port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "displayName" : "Standard Deviation"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port that takes a number.",
               "tupleType" : "class java.lang.Number"
            },
            {
               "name" : "weight",
               "optional" : false,
               "description" : "Input weight port that takes a number.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.statistics.WeightedMeanOperator",
         "tags" : [
            "numeric",
            "math",
            "calculation",
            "sum",
            "count",
            "mean operator",
            "average"
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "average",
               "type" : "java.lang.Number",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseOperator that computes weighted mean of incoming data",
         "longDesc" : "<br>\n <br>\n <b>Input Port(s) : </b><br>\n <b>data : </b> Data values input port. <br>\n <b>weight : </b> Current input data weight. <br>\n <br>\n <b>Output Port(s) : </b> <br>\n <b>mean : </b>Weighted mean output port. <br>\n <br>\n <b>StateFull : Yes</b>, value are aggregated over application window. <br>\n <b>Partitions : No</b>, no will yeild wrong results. <br>\n <br>",
         "category" : "Statistics",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mean",
               "optional" : true,
               "description" : "Output port that emits weighted mean.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "displayName" : "Weighted Mean"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "Input port that takes data to be added to a collection.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.stream.ArrayListAggregator",
         "tags" : [
            "list",
            "aggregate",
            "collection"
         ],
         "properties" : [
            {
               "name" : "size",
               "type" : "int",
               "canSet" : true,
               "description" : "size of collection",
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of AbstractAggregator that creates an ArrayList tuple from incoming tuples",
         "longDesc" : "\n <p>\n The size of the ArrayList before it is emitted is determined by property \\\"size\\\". If size == 0\n then the ArrayList (if not empty) is emitted in the endWindow call. Is size is specified then the ArrayList is emitted as soon as the size is\n reached as part of process(tuple), and no emit happens in endWindow. For size != 0, the operator is statefull.<p>\n <br>\n <b>Port</b>:<br>\n <b>input</b>: expects T<br>\n <b>output</b>: emits ArrayList&lt;T&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>size</b>: The size of ArrayList. If specified the ArrayList is emitted the moment it reaches this size.\n               If 0, the ArrayList is emitted in endWindow call. Default value is 0, </br>\n <br>",
         "category" : "Stream",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "description" : "Output port that emits a collection.",
               "tupleType" : "java.util.Collection<T>"
            }
         ],
         "displayName" : "Abstract List Aggregator"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port that takes an arraylist.",
               "tupleType" : "java.util.ArrayList<K>"
            }
         ],
         "name" : "com.datatorrent.lib.stream.ArrayListToItem",
         "tags" : [
            "arraylist",
            "clone"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseKeyOperator that breaks up an ArrayList tuple into Objects",
         "longDesc" : "\n <p>\n Takes in an ArrayList and emits each item in the array; mainly used for\n breaking up an ArrayList tuple into Objects. <br>\n It is a pass through operator<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects ArrayList&lt;K&gt;br> <b>item</b>: emits K<br>",
         "category" : "Stream",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "item",
               "optional" : true,
               "description" : "Output port that emits an array item.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "displayName" : "Array List To Item"
      },
      {
         "inputPorts" : [
            {
               "name" : "in1",
               "optional" : false,
               "description" : "V1 type value input port.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "name" : "in2",
               "optional" : false,
               "description" : "V2 type value input port.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "name" : "in3",
               "optional" : true,
               "description" : "V3 type value input port.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "name" : "in4",
               "optional" : true,
               "description" : "V4 type value input port.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "name" : "in5",
               "optional" : true,
               "description" : "V5 type value input port.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.stream.ConsolidatorKeyVal",
         "tags" : [
            "arraylist",
            "key value"
         ],
         "properties" : [],
         "shortDesc" : "<p>\n An implementation of operator that Aggregates &lt;key,value&gt; input from five ports of different types into\n &lt;key,array list map&gt; for each key",
         "longDesc" : "<br>\n <p>\n Operator emits key/array list map at end window, this end window operator. <br>\n <br>\n <b>StateFull : Yes</b>, values are collected over application window. <br>\n <b>Partitions : No</b>, will collect wrong results. <br>\n <br>\n <b>Ports : </b><br>\n <b>Input(s) : </b> 5 max input ports, 3 are optional. <br>\n <br>",
         "category" : "Stream",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "out",
               "optional" : true,
               "description" : "Output port that emits a hashmap of &lt;key,arraylist&gt;.",
               "tupleType" : "java.util.HashMap<K, java.util.ArrayList<java.lang.Object>>"
            }
         ],
         "displayName" : "Consolidator Key Value"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input any data type port.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.stream.DevNull",
         "tags" : [
            "debug",
            "terminate"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseOperator that terminates a stream and does not affect the tuple",
         "longDesc" : "\n <p>\n Useful if you want to have a stream for monitoring purpose etc. In future STRAM may simply support a\n virtual stream and make this operator redundant<br>\n <br>\n <b>Port</b>:<br>\n <b>data</b>: expects K<br>\n <br>",
         "category" : "Stream",
         "outputPorts" : [],
         "displayName" : "Dev Null"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port that takes objects to be counted in each window.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.stream.DevNullCounter",
         "tags" : [
            "count"
         ],
         "properties" : [
            {
               "name" : "debug",
               "type" : "boolean",
               "canSet" : true,
               "description" : "debug state",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "rollingwindowcount",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "An implementation of BaseOperator that is used for logging by counting the tuple and then drops it",
         "longDesc" : "\n <p>\n Increments a count and writes the net number (rate) to console. Useful to benchmark other\n modules.<br>\n This operator is neither pass through nor windowed as far as data tuples are\n concerned. The logging is done during end of window call.<br>\n <br>\n <b>Port</b>:<br>\n <b>data</b>: expects K<br>\n <br>\n <b>Properties</b>: rollingwindowcount: Number of windows to average over.\n Results are written to the log<br>\n <br>",
         "category" : "Stream",
         "outputPorts" : [],
         "displayName" : "Dev Null Counter"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port that takes a hashmap of &lt;key,value&rt;.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.stream.HashMapToKeyValPair",
         "tags" : [
            "hashmap",
            "key value"
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseKeyValueOperator that breaks a HashMap tuple into objects",
         "longDesc" : "\n <p>\n Takes a HashMap and emits its keys, keyvals, vals; used for breaking up a\n HashMap tuple into objects (keys, vals, or &lt;key,val&gt; pairs)\n <p>\n This is a pass through operator<br>\n <br>\n <b>StateFull : No</b> <br>\n <b>Partitions : Yes </b><br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects HashMap&lt;K,V&gt;<br>\n <b>key</b>: emits K<br>\n <b>keyval</b>: emits Entry&lt;K,V&gt;<br>\n <b>val</b>: emits V<br>\n <br>",
         "category" : "Stream",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "key",
               "optional" : true,
               "description" : "Key output port.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "error" : false,
               "name" : "keyval",
               "optional" : true,
               "description" : "key/value pair output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            },
            {
               "error" : false,
               "name" : "val",
               "optional" : true,
               "description" : "Value output port.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "displayName" : "Hash Map To Key Value Pair"
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "Input byte array port.",
               "tupleType" : "byte[]"
            }
         ],
         "name" : "com.datatorrent.lib.stream.JsonByteArrayOperator",
         "tags" : [
            "json",
            "byte array"
         ],
         "properties" : [
            {
               "name" : "concatenationCharacter",
               "type" : "char",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseOperator that takes a json byte stream and emits a HashMap of key values",
         "longDesc" : "\n <p>\n This is a pass through operator<br>\n <br>\n <b>Ports</b>:<br>\n <b>input</b>: expects json byte array &lt;K,V&gt;<br>\n <b>outputMap</b>: emits HashMap&lt;String,Object&gt;<br>\n <b>outputJsonObject</b>: emits JSONObject<br>\n <b>outputFlatMap</b>: emits HashMap&lt;String,Object&gt;<br>\n &nbsp&nbsp The key will be dot concatenated nested key names <br>\n &nbsp&nbsp eg: key: \"agentinfo.os.name\", value: \"Ubuntu\" <br>\n <br>",
         "category" : "Stream",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "flatmap",
               "optional" : true,
               "description" : "Output hash map port.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Object>"
            },
            {
               "error" : false,
               "name" : "jsonobject",
               "optional" : true,
               "description" : "Output JSONObject port.",
               "tupleType" : "class org.codehaus.jettison.json.JSONObject"
            },
            {
               "error" : false,
               "name" : "map",
               "optional" : true,
               "description" : "Output hash map port.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Object>"
            }
         ],
         "displayName" : "Json Byte Array"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port that takes a key value pair.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.stream.KeyValPairToHashMap",
         "tags" : [
            "key value"
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseKeyValueOperator that converts Key Value Pair to a HashMap tuple",
         "longDesc" : "\n <p>\n Takes a KeyValPair and emits a HashMap(1), Used for for converting KeyValPair\n to a HashMap(1) tuple\n <p>\n This is a pass through operator<br>\n <br>\n <b>Ports</b>:<br>\n <b>keyval</b>: expects KeyValPair&lt;K,V&gt;<br>\n <b>map</b>: emits HashMap&lt;K,V&gt;<br>\n <br>",
         "category" : "Stream",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "map",
               "optional" : true,
               "description" : "key/value map output port.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "displayName" : "Key Value Pair To HashMap"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Value input port.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.stream.RoundRobinHashMap",
         "tags" : [
            "key value",
            "hashmap"
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "keys",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "<p>\n An implementation of BaseKeyValueOperator that creates a HashMap tuple from incoming tuples",
         "longDesc" : "\n <p>\n If keys[] are set, then each incoming tuple is the value of the key (in-order) till all keys get a value.\n Once all keys are assigned values, the tuple (HashMap) is emitted, the\n process of assigning values starts again<br>\n This is a stateful operator as it waits across window boundary to complete\n the HashTable<br>\n <br>\n <b> StateFull : Yes, </b>Operator maintains index of key across windows. <br>\n <b> Partitions : Yes </b> <br>\n <br>\n <b>Port</b>:<br>\n <b>data</b>: expects V<br>\n <b>map</b>: emits HashMap&lt;K,v&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>keys[]</b>: Set of keys to insert in the output tuple</b>",
         "category" : "Stream",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "map",
               "optional" : true,
               "description" : "key/value map output port.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "displayName" : "Round Robin HashMap"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.stream.StreamDuplicater",
         "tags" : [
            "duplicate"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseKeyValueOperator that duplicates an input stream as is into two output streams",
         "longDesc" : "\n <p>\n Duplication is needed to allow separation of listeners into two streams with different properties (for example\n inline vs in-rack)<p>\n This is a pass through operator<br>\n <br>\n <b>Port Interface</b><br>\n <b>data</b>: expects &lt;K&gt;<br>\n <b>out1</b>: emits &lt;K&gt;<br>\n <b>out2</b>: emits &lt;K&gt;<br>\n <br>",
         "category" : "Stream",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "out1",
               "optional" : true,
               "description" : "Output port 1 that emits duplicate of input stream.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "error" : false,
               "name" : "out2",
               "optional" : true,
               "description" : "Output port 2 that emits duplicate of input stream.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "displayName" : "Stream duplicator"
      },
      {
         "inputPorts" : [
            {
               "name" : "data1",
               "optional" : false,
               "description" : "Data input port 1.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "name" : "data2",
               "optional" : false,
               "description" : "Data input port 2.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.stream.StreamMerger",
         "tags" : [
            "merge"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseOperator that merges two streams with identical schema and emits the tuples to the output port in order",
         "longDesc" : "\n \n <p>\n This is a pass through operator<br>\n <b>Ports</b>:<br>\n <b>data1</b>: expects K<br>\n <b>data2</b>: expects K<br>\n <b>out</b>: emits K<br>\n <br>",
         "category" : "Stream",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "out",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "displayName" : "Stream Merger"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port that takes a map of &lt;string,object&gt;.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.DeleteOperator",
         "tags" : [
            "sql delete operator"
         ],
         "properties" : [
            {
               "name" : "condition",
               "type" : "com.datatorrent.lib.streamquery.condition.Condition",
               "canSet" : true,
               "canGet" : false,
               "properties" : []
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseOperator that provides sql delete query semantic on live data stream",
         "longDesc" : "<br>\n <p>\n Stream rows passing condition are emitted on output port stream. <br>\n <br>\n <b>StateFull : NO,</b> all row data is processed in current time window. <br>\n <b>Partitions : Yes, </b> No Input dependency among input rows. <br>\n <br>\n <b>Ports</b>:<br>\n <b> inport : </b> Input hash map(row) port, expects\n HashMap&lt;String,Object&gt;<<br>\n <b> outport : </b> Output hash map(row) port, emits\n HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <b> <br>\n <b> condition : </b> Select condition for selecting rows. <br>\n <b> columns : </b> Column names/aggregate functions for select. <br>\n <br>",
         "category" : "Streamquery",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port emits a map of &lt;string,object&gt;.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "displayName" : "Delete"
      },
      {
         "inputPorts" : [
            {
               "name" : "bindings",
               "optional" : true,
               "description" : "Input bindings port that takes an arraylist of objects.",
               "tupleType" : "java.util.ArrayList<java.lang.Object>"
            },
            {
               "name" : "in1",
               "optional" : false,
               "description" : "Input port in1 that takes a hashmap of &lt;string,object&gt;.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Object>"
            },
            {
               "name" : "in2",
               "optional" : true,
               "description" : "Input port in2 that takes a hashmap of &lt;string,object&gt;.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Object>"
            },
            {
               "name" : "in3",
               "optional" : true,
               "description" : "Input port in3 that takes a hashmap of &lt;string,object&gt;.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Object>"
            },
            {
               "name" : "in4",
               "optional" : true,
               "description" : "Input port in4 that takes a hashmap of &lt;string,object&gt;.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Object>"
            },
            {
               "name" : "in5",
               "optional" : true,
               "description" : "Input port in5 that takes a hashmap of &lt;string,object&gt;.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.DerbySqlStreamOperator",
         "tags" : [
            "sql",
            "in-memory",
            "input operator"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "statement",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of AbstractSqlStreamOperator that provides embedded derby sql input operator",
         "longDesc" : "\n <p>",
         "category" : "Streamquery",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "result",
               "optional" : true,
               "description" : "Output result port that emits a hashmap of &lt;string,object&gt;.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Object>"
            }
         ],
         "displayName" : "Derby Sql Stream"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port that takes a map of &lt;string,object&gt;.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.GroupByHavingOperator",
         "tags" : [
            "sql",
            "groupby operator",
            "condition",
            "index"
         ],
         "properties" : [
            {
               "name" : "condition",
               "type" : "com.datatorrent.lib.streamquery.condition.Condition",
               "canSet" : true,
               "canGet" : false,
               "properties" : []
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseOperator that provides sql group by querying semantics on live data stream",
         "longDesc" : "<br>\n <p>\n Stream rows satisfying given select condition are processed by group by\n column names and aggregate column function. <br>\n If having condition is specified for aggregate index(s), it must also be\n satisfied by row. HashMap of column name(s) and aggregate alias is emitted on\n output port. <br>\n <br>\n <b>StateFull : Yes,</b> Operator aggregates input over application window. <br>\n <b>Partitions : No, </b> will yield wrong result(s). <br>\n <br>\n <b>Ports</b>:<br>\n <b> inport : </b> Input hash map(row) port, expects\n HashMap&lt;String,Object&gt;<<br>\n <b> outport : </b> Output hash map(row) port, emits\n HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <b> <br>\n <b> condition : </b> Select condition for deleting rows. <br>\n <b> columnGroupIndexes : </b> Group by names list. <br>\n <b> indexes : </b> Select column indexes. <br>\n <b> havingConditions : </b> Having filter conditions for aggregate(s). <br>\n <br>",
         "category" : "Streamquery",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port that emits a map of &lt;string,object&gt;.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "displayName" : "GroupBy Having Operator"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport1",
               "optional" : false,
               "description" : "Input port 1 that takes a map of &lt;string,object&gt;.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            },
            {
               "name" : "inport2",
               "optional" : false,
               "description" : "Input port 2 that takes a map of &lt;string,object&gt;.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.InnerJoinOperator",
         "tags" : [
            "sql",
            "inner join operator"
         ],
         "properties" : [
            {
               "name" : "joinCondition",
               "type" : "com.datatorrent.lib.streamquery.condition.Condition",
               "canSet" : true,
               "description" : "the joinCondition",
               "canGet" : true,
               "properties" : []
            }
         ],
         "shortDesc" : "An implementation of Operator that reads table row data from two table data input ports",
         "longDesc" : "<br>\n <p>\n Operator joins row on given condition and selected names, emits\n joined result at output port.\n  <br>\n  <b>StateFull : Yes,</b> Operator aggregates input over application window. <br>\n  <b>Partitions : No, </b> will yield wrong result(s). <br>\n  <br>\n  <b>Ports : </b> <br>\n  <b> inport1 : </b> Input port for table 1, expects HashMap&lt;String, Object&gt; <br>\n  <b> inport1 : </b> Input port for table 2, expects HashMap&lt;String, Object&gt; <br>\n  <b> outport : </b> Output joined row port, emits HashMap&lt;String, ArrayList&lt;Object&gt;&gt; <br>\n  <br>\n  <b> Properties : </b>\n  <b> joinCondition : </b> Join condition for table rows. <br>\n  <b> table1Columns : </b> Columns to be selected from table1. <br>\n  <b> table2Columns : </b> Columns to be selected from table2. <br>\n  <br>",
         "category" : "Streamquery",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port that emits a map of &lt;string,object&gt;.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "displayName" : "Inner join"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport1",
               "optional" : false,
               "description" : "Input port 1 that takes a map of &lt;string,object&gt;.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            },
            {
               "name" : "inport2",
               "optional" : false,
               "description" : "Input port 2 that takes a map of &lt;string,object&gt;.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.OuterJoinOperator",
         "tags" : [
            "sql",
            "outer join operator"
         ],
         "properties" : [
            {
               "name" : "fullJoin",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "joinCondition",
               "type" : "com.datatorrent.lib.streamquery.condition.Condition",
               "canSet" : true,
               "description" : "the joinCondition",
               "canGet" : true,
               "properties" : []
            }
         ],
         "shortDesc" : "An operator that provides sql left,right and full outer join metric semantics on live stream",
         "longDesc" : "<br>\n <p>\n Please refer to {@link com.datatorrent.lib.streamquery.InnerJoinOperator} for\n details.\n\n <b> Properties : </b> <br>\n <b> isLeftJoin : </b> Left join flag. <br>\n <b> isFullJoin : </b> Full join flag. <br>",
         "category" : "Streamquery",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port that emits a map of &lt;string,object&gt;.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "displayName" : "Outer Join"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port that takes a map of &lt;string,object&gt;.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.SelectFunctionOperator",
         "tags" : [
            "sql top",
            "sql limit",
            "sql select operator"
         ],
         "properties" : [],
         "shortDesc" : "An implementation of Operator that applies sql top or limit semantics on incoming tuple(s)",
         "longDesc" : "<br>\n <p>\n <b>StateFull : Yes,</b> Operator aggregates input over application window. <br>\n <b>Partitions : No, </b> will yield wrong result(s). <br>\n <br>\n <b>Ports : </b> <br>\n <b>inport : </b> expect tuple for type T. <br>\n <b>outport : </b> emits tuple for type T. <br>\n <br>\n <b> Properties : </b> <br>\n <b> functions : </b> Sql function for rows. <br>",
         "category" : "Streamquery",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port that emits a map of &lt;string,object&gt;.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "displayName" : "Select Function"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port that takes a map of &lt;string,object&gt;.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.SelectOperator",
         "tags" : [
            "sql select operator",
            "index",
            "sql condition"
         ],
         "properties" : [
            {
               "name" : "condition",
               "type" : "com.datatorrent.lib.streamquery.condition.Condition",
               "canSet" : true,
               "canGet" : false,
               "properties" : []
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of that provides sql select query semantics on live data stream",
         "longDesc" : "<br>\n <p>\n Stream rows passing condition are emitted on output port stream. <br>\n <br>\n <b>StateFull : NO,</b> all row data is processed in current time window. <br>\n <b>Partitions : Yes, </b> No Input dependency among input rows. <br>\n <br>\n <b>Ports</b>:<br>\n <b> inport : </b> Input hash map(row) port, expects\n HashMap&lt;String,Object&gt;<<br>\n <b> outport : </b> Output hash map(row) port, emits\n HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <b> <br>\n <b> condition : </b> Select condition for selecting rows. <br>\n <b> columns : </b> Column names/aggregate functions for select. <br>\n <br>",
         "category" : "Streamquery",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port that emits a map of &lt;string,object&gt;.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "displayName" : "Select"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port that takes a map of &lt;string,object&gt;.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.SelectTopOperator",
         "tags" : [
            "sql select",
            "sql top operator"
         ],
         "properties" : [
            {
               "name" : "percentage",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "topValue",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of Operator that provides sql top select query semantic on live data stream",
         "longDesc" : "<br>\n <p>\n Stream rows passing condition are emitted on output port stream. <br>\n <br>\n <b>StateFull : NO,</b> all row data is processed in current time window. <br>\n <b>Partitions : Yes, </b> No Input dependency among input rows. <br>\n <br>\n <b>Ports</b>:<br>\n <b> inport : </b> Input hash map(row) port, expects\n HashMap&lt;String,Object&gt;<<br>\n <b> outport : </b> Output hash map(row) port, emits\n HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <b> <br>\n <b> topValue : </b> top values count. <br>\n <b> isPercentage : </b> top values count is percentage flag.\n <br>",
         "category" : "Streamquery",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port that emits a map of &lt;string,object&gt;.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "displayName" : "Select Top"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port that takes a map of &lt;string,object&gt;.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.UpdateOperator",
         "tags" : [
            "sql update operator",
            "sql condition"
         ],
         "properties" : [
            {
               "name" : "condition",
               "type" : "com.datatorrent.lib.streamquery.condition.Condition",
               "canSet" : true,
               "canGet" : false,
               "properties" : []
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseOperator that provides sql update query semantic on live data stream",
         "longDesc" : "<br>\n  <p>\n  Stream rows passing condition are emitted on output port stream. <br>\n  <br>\n  <b>StateFull : NO,</b> all row data is processed in current time window. <br>\n  <b>Partitions : Yes, </b> No Input dependency among input rows. <br>\n  <br>\n <b>Ports</b>:<br>\n <b> inport : </b> Input hash map(row) port, expects HashMap&lt;String,Object&gt;<<br>\n <b> outport : </b> Output hash map(row) port, emits  HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <b> <br>\n <b> condition : </b> Select condition for selecting rows. <br>\n <b> columns : </b> Column names/aggregate functions for select. <br>\n <br>",
         "category" : "Streamquery",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port that emits a map of &lt;string,object&gt;.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "displayName" : "Update"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port that takes a map of integer values.",
               "tupleType" : "java.util.Map<k, java.lang.Integer>"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.CompareFilterTuples",
         "tags" : [
            "map",
            "compare"
         ],
         "properties" : [
            {
               "name" : "compareType",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "<p>Implements Compare Filter Tuples class.</p>\n <p>",
         "category" : "Testbench",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port that emits a map of integer values.",
               "tupleType" : "java.util.Map<k, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "redisport",
               "optional" : true,
               "description" : "Output redis port that emits a map of &lt;integer,string&gt; values.",
               "tupleType" : "java.util.Map<java.lang.Integer, java.lang.String>"
            }
         ],
         "displayName" : "Compare Filter Tuples"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.CountOccurance",
         "tags" : [
            "count"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "<p>A base implementation of an operator which does count occurrence.</p>\n <p>",
         "category" : "Testbench",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "dimensionOut",
               "optional" : true,
               "description" : "Output dimensions port that emits a map of &lt;string,object&gt; values.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            },
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port that emits a map of integer values.",
               "tupleType" : "java.util.Map<k, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "total",
               "optional" : true,
               "description" : "Output total port that emits a map of &lt;string,integer&gt; count values.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Integer>"
            }
         ],
         "displayName" : "Count Occurrence"
      },
      {
         "inputPorts" : [
            {
               "name" : "event",
               "optional" : false,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Double>"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.EventClassifier",
         "tags" : [
            "hashmap",
            "classification"
         ],
         "properties" : [
            {
               "name" : "keyMap",
               "type" : "java.util.HashMap",
               "canSet" : true,
               "canGet" : false,
               "properties" : [
                  {
                     "name" : "empty",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseOperator that creates a load with pair of keys by taking in an input stream event and adding to incoming keys\n to create a new tuple that is emitted on output port data",
         "longDesc" : " <p>\n Takes a input stream event and adds to incoming keys to create a new tuple that is emitted on output port data.\n <br>\n Examples of pairs include<br>\n publisher,advertizer<br>\n automobile,model<br>\n <br>\n The keys to be inserted are given by the property <b>keys</b>. Users can choose to insert their\n own values via property <b>values</b>. Insertion can be done as replacement, addition, multiply,\n or append (append is not yet supported)<br>. For each incoming key users can provide an insertion\n probability for the insert keys. This allows for randomization of the insert key choice<br><br>\n <br>\n <b>Tuple Schema</b>: Each tuple is HashMap<String, Double> on both the ports. Currently other schemas are not supported<br>\n <b>Port Interface</b><br>\n <b>data</b>: emits HashMap<String,Double><br>\n <b>event</b>: expects HashMap<String,Double><br>\n <br>\n <b>Properties</b>:\n None<br>\n <br>\n Compile time checks are:<br>\n <b>keys</b> cannot be empty<br>\n <b>values</b> if specified has to be comma separated doubles and their number must match the number of keys<br>\n <b>weights</b> if specified the format has to be \"key1:val1,val2,...,valn;key2:val1,val2,...,valn;...\", where n has to be\n number of keys in parameter <b>keys</b>. If not specified all weights are equal<br>\n <br>\n <br>\n <b>Benchmarks</b>: This node has been benchmarked at over 5 million tuples/second in local/inline mode<br>\n <p>",
         "category" : "Testbench",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "data",
               "optional" : true,
               "description" : "Output data port that emits a hashmap of &lt;string,double&gt;.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Double>"
            }
         ],
         "displayName" : "Event Classifier"
      },
      {
         "inputPorts" : [
            {
               "name" : "event",
               "optional" : false,
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.EventClassifierNumberToHashDouble",
         "tags" : [
            "number",
            "classifier"
         ],
         "properties" : [
            {
               "name" : "key",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "seedend",
               "type" : "int",
               "canSet" : true,
               "description" : "seed end",
               "canGet" : true
            },
            {
               "name" : "seedstart",
               "type" : "int",
               "canSet" : true,
               "description" : "seed start",
               "canGet" : true
            }
         ],
         "shortDesc" : "An implementation of BaseOperator that creates a load with pair of keys by taking in an input stream event and adding to incoming keys\n to create a new tuple of Hashmap &lt;String,Double&gt; that is emitted on output port data",
         "longDesc" : " <p>\n Takes a in stream event and adds to incoming keys to create a new tuple that is emitted on output port data. The aim is to create a load with pair of keys<p>\n <br>\n Examples of pairs include<br>\n publisher,advertizer<br>\n automobile,model<br>\n <br>\n The keys to be inserted are given by the property <b>keys</b>. Users can choose to insert their\n own values via property <b>values</b>. Insertion can be done as replacement, addition, multiply,\n or append (append is not yet supported)<br>. For each incoming key users can provide an insertion\n probability for the insert keys. This allows for randomization of the insert key choice<br><br>\n <br>\n <b>Tuple Schema</b>: Each tuple is HashMap<String, Double> on both the ports. Currently other schemas are not supported<br>\n <b>Port Interface</b><br>\n <b>data</b>: emits HashMap<String,Double><br>\n <b>event</b>: expects HashMap<String,Double><br>\n <br>\n <b>Properties</b>:\n None<br>\n <br>\n Compile time checks are:<br>\n <b>keys</b> cannot be empty<br>\n <b>values</b> if specified has to be comma separated doubles and their number must match the number of keys<br>\n <b>weights</b> if specified the format has to be \"key1:val1,val2,...,valn;key2:val1,val2,...,valn;...\", where n has to be\n number of keys in parameter <b>keys</b>. If not specified all weights are equal<br>\n <br>\n <br>\n <b>Benchmarks</b>: This node has been benchmarked at over 5 million tuples/second in local/inline mode<br>",
         "category" : "Testbench",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "data",
               "optional" : true,
               "description" : "Output data port that emits a hashmap of &lt;string,double&gt;.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Double>"
            }
         ],
         "displayName" : "Event Classifier Number To HashDouble"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.testbench.EventGenerator",
         "tags" : [
            "input operator",
            "generator"
         ],
         "properties" : [
            {
               "name" : "keys",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "maxCountOfWindows",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "rollingWindowCount",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "tuplesBlast",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "values",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "weights",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "Generates synthetic load.&nbsp; Creates tuples and keeps emitting them on the output port \"data\"",
         "longDesc" : "\n <p>\n <br>\n The load is generated as per config parameters. This class is mainly meant for testing\n nodes.<br>\n It does not need to be windowed. It would just create tuple stream upto the limit set\n by the config parameters.<br>\n <b>Ports</b>:\n <b>string_data</b>: emits String<br>\n <b>hash_data</b>: emits HashMap<String,Double><br>\n <b>count<b>: emits HashMap<String, Number>, contains per window count of throughput<br>\n <br>\n <b>Tuple Schema</b>: Has two choices HashMap<String, Double>, or String<br><br>\n <b>Port Interface</b>:It has only one output port \"data\" and has no input ports<br><br>\n <b>Properties</b>:\n <b>keys</b> is a comma separated list of keys. This key are the <key> field in the tuple<br>\n <b>values</b> are comma separated list of values. This value is the <value> field in the tuple. If not specified the values for all keys are 0.0<br>\n <b>weights</b> are comma separated list of probability weights for each key. If not specified the weights are even for all keys<br>\n <b>tuples_blast</b> is the total number of tuples sent out before the thread returns control. The default value is 10000<br>\n <b>max_windows_count</b>The number of windows after which the node would shut down. If not set, the node runs forever<br>\n <br>\n Compile time checks are:<br>\n <b>keys</b> cannot be empty<br>\n <b>values</b> if specified has to be comma separated doubles and their number must match the number of keys<br>\n <b>weights</b> if specified has to be comma separated integers and number of their number must match the number of keys<br>\n <b>tuples_blast</b>If specified must be an integer<br>\n <br>\n\n Compile time error checking includes<br>\n <b>Benchmarks></b>: Send as many tuples in in-line mode, the receiver just counts the tuples and drops the object<br>\n String schema does about 26 Million tuples/sec in throughput<br>\n HashMap schema does about 10 Million tuples/sec in throughput<br>",
         "category" : "Testbench",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "description" : "Output count port that emits a hashmap of &lt;string,number&gt; which contains per window count of throughput.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Number>"
            },
            {
               "error" : false,
               "name" : "hash_data",
               "optional" : true,
               "description" : "Output hash data port that emits a hashmap of &lt;string,double&gt;.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Double>"
            },
            {
               "error" : false,
               "name" : "string_data",
               "optional" : true,
               "description" : "Output string port that emits string data.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "displayName" : "Event Generator"
      },
      {
         "inputPorts" : [
            {
               "name" : "increment",
               "optional" : false,
               "description" : "Input increment port that takes a hashmap of &lt;string,hashmap of &lt;string,number&gt;&gt; which provides small random increments to the seed data.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.util.HashMap<java.lang.String, java.lang.Integer>>"
            },
            {
               "name" : "seed",
               "optional" : false,
               "description" : "Input seed port that takes a hashmap of &lt;string,arraylist of integers&gt; which provides seed data for setting up the incrementer data to work on.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.Integer>>"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.EventIncrementer",
         "tags" : [
            "increment",
            "hashmap"
         ],
         "properties" : [
            {
               "name" : "delta",
               "type" : "double",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "Creates a random movement by taking in a seed stream and incrementing this data",
         "longDesc" : "\n <p>\n Takes in a seed stream on port seed and then increments this data on port increment. Data is immediately emitted on output port data.\n Emits number of tuples on port count<p>\n The aim is to create a random movement.\n <br>\n Examples of application includes<br>\n random motion<br>\n <br>\n <br>\n <br>\n <b>Tuple Schema</b>: Each tuple is HashMap<String, ArrayList> on both the ports. Currently other schemas are not supported<br>\n <b>Port Interface</b><br>\n <b>seed</b>: The seed data for setting up the incrementer data to work on<br>\n <b>increment</b>: Small random increments to the seed data. This now creates a randomized change in the seed<br>\n <b>data</b>: Output of seed + increment<br>\n <b>count</b>: Emits number of processed tuples per window<br>\n <br>\n <b>Properties</b>:\n <br>keys: In case the value has multiple dimensions. They can be accessed via keys<br>\n <br>delta: The max value from an increment. The value on increment port is treated as a \"percent\" of this delta<br>\n Compile time checks are:<br>\n <br>\n <b>Benchmarks</b>: The benchmark was done in local/inline mode<br>\n Processing tuples on seed port are at 3.5 Million tuples/sec<br>\n Processing tuples on increment port are at 10 Million tuples/sec<br>\n <br>",
         "category" : "Testbench",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "description" : "Output count port that emits a hashmap of &lt;string,integer&gt; which contains number of processed tuples per window.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "data",
               "optional" : true,
               "description" : "Output data port that emits a hashmap of &lt;string,string&gt; which is the addition of seed and increment.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.String>"
            }
         ],
         "displayName" : "Event Generator"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port on which tuples are received.",
               "tupleType" : "java.util.HashMap<java.lang.String, T>"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.FilterClassifier",
         "tags" : [
            "filter"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "Filters the tuples as per the filter (pass through percent) and emits them",
         "longDesc" : " <p>\n The aim is to create another stream representing a subsection of incoming load<p>\n <br>\n Examples of pairs include<br>\n publisher,advertizer<br>\n automobile,model<br>\n <br>\n <b>Ports</b>:\n <b>data</b>: expects HashMap<String,T>\n <b>filter</b>:\n The keys to be inserted are given by the property <b>keys</b>. Users can choose to insert their\n own values via property <b>values</b>.<br>\n For each incoming key users can provide an insertion\n probability for the insert keys. This allows for randomization of the insert key choice<br><br>\n <br>\n Benchmarks: This node has been benchmarked at over 22 million tuples/second in local/inline mode<br>\n\n <b>Tuple Schema</b>: Each tuple is HashMap<String, Double> on both the ports. Currently other schemas are not supported<br>\n <br>\n <b>Properties</b>:\n <br>\n Compile time checks are:<br>\n <br>\n </p>",
         "category" : "Testbench",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "filter",
               "optional" : true,
               "description" : "The output port which emits filtered tuples.",
               "tupleType" : "java.util.HashMap<java.lang.String, T>"
            }
         ],
         "displayName" : "Filter Classifier"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port on which tuples are received.",
               "tupleType" : "java.util.HashMap<java.lang.String, T>"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.FilteredEventClassifier",
         "tags" : [
            "filter"
         ],
         "properties" : [
            {
               "name" : "keyMap",
               "type" : "java.util.HashMap",
               "canSet" : true,
               "canGet" : false,
               "properties" : [
                  {
                     "name" : "empty",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "keyWeights",
               "type" : "java.util.HashMap",
               "canSet" : true,
               "canGet" : false,
               "properties" : [
                  {
                     "name" : "empty",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "passFilter",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "totalFilter",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "This operator takes in a stream of tuples\n and randomly emits them based on the specified total_filter and pass_filter values.&nbsp;\n Emitted tuples are modified based on the specified key map and key weights",
         "longDesc" : " <p>\n The aim is to create another stream representing a subsection of incoming load<p>\n <br>\n Examples of pairs include<br>\n publisher,advertizer<br>\n automobile,model<br>\n <br>\n The keys to be inserted are given by the property <b>keys</b>. Users can choose to insert their\n own values via property <b>values</b>.<br>\n For each incoming key users can provide an insertion\n probability for the insert keys. This allows for randomization of the insert key choice<br><br>\n <br>\n <b>Tuple Schema</b>: Each tuple is HashMap<String, Double> on both the ports. Currently other schemas are not supported<br>\n <b>Port Interface</b><br>\n <b>out_data</b>: Output port for emitting the new tuple<br>\n <b>in_data</b>: Input port for receiving the incoming tuple<br>\n <br>\n <b>Properties</b>:\n <b>keys</b> is a comma separated list of keys. This key are the insert keys in the tuple<br>\n <b>values</b> are comma separated list of values. This value is for insertion into the <value> field in the tuple. also called \"insert value\". If not specified the incoming values are not changed<br>\n <b>weights</b> are comma separated list of probability weights for each incoming key. For each incoming key the weights have to be provided. If this parameter is empty all the weights are even for all keys<br>\n <b>percent<b>A number between 0 and 100. This is the percent of the time a new tuple is created. If say the number is 1, then a randomly selected 1 tuple out of 100 would create an output typle<br>\n <br>\n Compile time checks are:<br>\n <b>keys</b> cannot be empty<br>\n <b>values</b> if not provided the incoming value is passed through<br>\n <b>weights</b> if specified the format has to be \"key1:val1,val2,...,valn;key2:val1,val2,...,valn;...\", where n has to be\n number of keys in parameter <b>keys</b>. If not specified all weights are equal<br>\n <b>filter</b> The first number has to be less than the second and both have to be positive<br>\n <br>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n This node has been benchmarked at over 20 million tuples/second in local/inline mode<br>\n </p>",
         "category" : "Testbench",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "filter",
               "optional" : true,
               "description" : "The output port which emits filtered and modified tuples.",
               "tupleType" : "java.util.HashMap<java.lang.String, T>"
            }
         ],
         "displayName" : "Filtered Event Classifier"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.HttpStatusFilter",
         "tags" : [
            "filter",
            "count"
         ],
         "properties" : [
            {
               "name" : "filterStatus",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator consumes tuples which are key value pairs of strings.&nbsp;\n The tuples are filtered based on their values, and then the number of times each key occurs is counted.&nbsp;\n At the end of the application window each key and the number of times it occurred is emitted",
         "longDesc" : " <p></p>",
         "category" : "Testbench",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Integer>"
            }
         ],
         "displayName" : "Http Status Filter"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "This input port on which tuples are received.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Integer>"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.KeyValSum",
         "tags" : [
            "count"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator consumes maps whose keys are strings and values are integers.&nbsp;\n In each application window the values for each key are summed and each string/sum pair is emitted at the end of each window",
         "longDesc" : " <p></p>",
         "category" : "Testbench",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "The output port on which sums are emitted.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Integer>"
            }
         ],
         "displayName" : "Key Val Sum"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.testbench.RandomEventGenerator",
         "tags" : [
            "generate"
         ],
         "properties" : [
            {
               "name" : "maxcountofwindows",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "maxvalue",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "minvalue",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "tuplesBlast",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "tuplesBlastIntervalMillis",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "Generates synthetic load.&nbsp;Creates tuples using random numbers and keeps emitting them on the output port string_data and integer_data",
         "longDesc" : " <p>\n <br>\n The load is generated as per config parameters. This class is mainly meant for testing nodes by creating a random number within\n a range at a very high throughput. This node does not need to be windowed. It would just create tuple stream upto the limit set\n by the config parameters.<br>\n <br>\n <b>Tuple Schema</b>: Has two choices Integer, or String<br><br>\n <b>Port Interface</b>\n <b>string_data</b>: Emits String tuples<br>\n <b>integer_data</b>: Emits Integer tuples<br>\n <b>Properties</b>:\n <b>key</b> is an optional parameter, the generator sends an HashMap if key is specified<br>\n <b>min_value</b> is the minimum value of the range of numbers. Default is 0<br>\n <b>max_value</b> is the maximum value of the range of numbers. Default is 100<br>\n <b>tuples_burst</b> is the total amount of tuples sent by the node before handing over control. The default\n value is 10000. A high value does not help as if window has space the control is immediately returned for mode processing<br>\n <b>string_schema</b> controls the tuple schema. For string set it to \"true\". By default it is \"false\" (i.e. Integer schema)<br>\n <br>\n Compile time checks are:<br>\n <b>min_value</b> has to be an integer<br>\n <b>max_value</b> has to be an integer and has to be >= min_value<br>\n <b>tuples_burst</b>If specified must be an integer<br>\n <br>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n This node has been benchmarked at over 10 million tuples/second in local/inline mode<br>\n <br>\n Compile time error checking includes<br>\n </p>",
         "category" : "Testbench",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "integer_data",
               "optional" : true,
               "description" : "The output port on which randomly generated integers are emitted.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "string_data",
               "optional" : true,
               "description" : "The output port on which randomly generated integers are emitted as strings.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "displayName" : "Random Event Generator"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "This is the input port which receives integer tuples to be summed.",
               "tupleType" : "class java.lang.Integer"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.RedisSumOper",
         "tags" : [
            "count"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator collects integer tuples, then emits their sum at the end of the window.",
         "category" : "Testbench",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "This is the output port which emits the summed tuples.",
               "tupleType" : "java.util.Map<java.lang.Integer, java.lang.Integer>"
            }
         ],
         "displayName" : "Redis Sum Oper"
      },
      {
         "inputPorts" : [
            {
               "name" : "data1",
               "optional" : false,
               "description" : "An input port which receives incoming tuples.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "name" : "data2",
               "optional" : false,
               "description" : "An output port which receives incoming tuples.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.SeedEventClassifier",
         "tags" : [
            "generate"
         ],
         "properties" : [
            {
               "name" : "key1",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "key2",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "seedend",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "seedstart",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "This operator receives data on two input ports (data1, and data2).&nbsp;\n Each incoming tuple is given a seed value\n and a key depending on which input port the tuple came from.&nbsp;\n Modified tuples are then emitted as strings on the string_data output port\n and as maps on the hash_data output port",
         "longDesc" : " <p>\n <br>\n Examples of getting seed distributions include<br>\n Changes in mobile co-ordinates of a phone<br>\n Random changes on motion of an object<br>\n <br>\n The seed is created from the values of properties <b>seed_start</b>, and <b>seed_end</b>\n <br>\n <b>Default schema</b>:<br>\n Schema for port <b>data</b>: The default schema is HashMap<String, ArrayList<valueData>>, where valueData is class{String, Integer}<br>\n <b>String schema</b>: The string is \"key;valkey1:value1;valkey2:value2;...\"<br>\n <b>HashMap schema</b>: Key is String, and Value is a ArrrayList<String, Number><br>\n The value in both the schemas is an integer (for choice of strings, these are enum values)\n <br>\n <b>Port Interface</b><br>\n <b>data1</b>: Expects tuples of type <T><br>\n <b>data2</b>: Expects tuples of type <T><br>\n <b>string_data</b>: Emits new classified seed of schema String<br>\n <b>hash_data</b>: Emits new classified seed of schema HashMap<String, HashMap<String, T>><br>\n <br>\n <b>Properties</b>:\n <b>seed_start</b>: An integer for the seed to start from<br>\n <b>seed_end</b>: An integer for the seed to end with<br>\n <br>string_schema</b>: If set to true, operates in string schema mode<br>\n <br>key</b>: Classifier keys to be inserted in order for each incoming tuple. Format is \"key1,key1start, key1end; key2, key2start, key2end;...\"\n <br>\n Compile time checks are:<br>\n <b>seed_start</b>Has to be an integer<br>\n <b>sedd_end</b>Has to be an integer<br>\n <b>key</b>If provided has to be in format \"key1,key1start,key1end;key2, key2start, key2end; ...\"\n <br>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n String: Benchmarked at over 13 million tuples/second in local/in-line mode<br>\n Integer: Benchmarked at over 7 million tuples/second in local/in-line mode<br>\n </p>",
         "category" : "Testbench",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "hash_data",
               "optional" : true,
               "description" : "An output port which emits modified tuples as a hashmap.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.util.HashMap<java.lang.String, T>>"
            },
            {
               "error" : false,
               "name" : "string_data",
               "optional" : true,
               "description" : "An output port which emits modified tuples as a string.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "displayName" : "Seed Event Classifier"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.testbench.SeedEventGenerator",
         "tags" : [
            "generate"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "seedend",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "seedstart",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "Generates a one time seed load based on the range provided by the keys,\n and adds new classification to incoming keys.&nbsp;\n Generated tuples are emitted on the keyvalpair_list, val_list, string_data, and val_data output ports",
         "longDesc" : " <p>\n Examples of getting seed distributions include<br>\n Clients data of a company for every clientId (key is clienId)<br>\n Persons age, gender, for every phone number (key is phone number)<br>\n Year, color, mileage for every car make (key is car make model)<br>\n <br>\n The classification to be done is based on the value of the property <b>key</b>. This property provides all the classification\n information and their ranges<br>The range of values for the key is given in the format described below<br>\n <br>\n <b>Benchmarks</b>: Generate as many tuples as possible in inline mode<br>\n HashMap<String, String>: 8 million/sec with no classification; 1.8 million tuples/sec with classification<br>\n HashMap<Sring, ArrayList<Integer>>: 8 million/sec with no classification; 3.5 million tuples/sec with classification<br>\n <br>\n <b>Default schema</b>:<br>\n Schema for port <b>data</b>: The default schema is HashMap<String, ArrayList<valueData>>, where valueData is class{String, Integer}<br>\n <b>String schema</b>: The string is \"key;valkey1:value1;valkey2:value2;...\"<br>\n <b>HashMap schema</b>: Key is String, and Value is a ArrrayList<String, Number><br>\n The value in both the schemas is an integer (for choice of strings, these are enum values)\n <br>\n <b>Port Interface</b><br>\n <b>data</b>: Output port for emitting the new classified seed<br>\n <br>\n <b>Properties</b>:\n <b>seed_start</b>: An integer for the seed to start from<br>\n <b>seed_end</b>: An integer for the seed to end with<br>\n <br>string_schema</b>: If set to true, operates in string schema mode<br>\n <br>key</b>: Classifier keys to be inserted randomly. Format is \"key1,key1start, key1end; key2, key2start, key2end;...\"\n <br>\n Compile time checks are:<br>\n <b>seed_start</b>Has to be an integer<br>\n <b>seed_end</b>Has to be an integer<br>\n <b>key</b>If provided has to be in format \"key1,key1start,key1end;key2, key2start, key2end; ...\"\n <br>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n With key: Benchmarked at over 1 million tuples/second in local/in-line mode<br>\n Without key: Benchmarked at over 4 million tuples/second in local/in-line mode<br>\n </p>",
         "category" : "Testbench",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "keyvalpair_list",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.util.ArrayList<com.datatorrent.lib.util.KeyValPair>>"
            },
            {
               "error" : false,
               "name" : "string_data",
               "optional" : true,
               "description" : "This output port emits generator tuples as a HashMap&lt;String, String&gt;&gt;.\n The key in the map is a seed integer in the form of a string.\n The value in the map is a list of integers and their corresponding keys (in string form) that are randomly generated and lies within a specified range.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.String>"
            },
            {
               "error" : false,
               "name" : "val_data",
               "optional" : true,
               "description" : "This output port emits generator tuples as a HashMap&lt;String, String&gt;&gt;.\n The key in the map is a seed integer in the form of a string.\n The value in the map is a list of integers (in string form) that are randomly generated and lies within a specified range.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.String>"
            },
            {
               "error" : false,
               "name" : "val_list",
               "optional" : true,
               "description" : "This output port emits generator tuples as a HashMap&lt;String, ArrayList&lt;Integer&gt;&gt;&gt;.\n The key in the map is a seed integer in the form of a string.\n The value in the map is a list of integers.\n Each integer is randomly generated and lies within a specified range.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.Integer>>"
            }
         ],
         "displayName" : "Seed Event Generator"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "The input port which receives throughput information from upstream operators.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.ThroughputCounter",
         "tags" : [
            "count"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "rollingWindowCount",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator expects incoming tuples to be of type HashMap&lt;String, Integer&gt;.&nbsp;\n These values are throughput per window from upstream operators.&nbsp;\n At the end of the application window, the total and average throughput are emitted",
         "longDesc" : " <p>\n Benchmarks: This node has been benchmarked at over 5 million tuples/second in local/inline mode<br>\n <b>Tuple Schema</b>\n Each input tuple is HashMap<String, Integer><br>\n Output tuple is a HashMap<String, Integer>, where strings are throughputs, averages etc<br>\n <b>Port Interface</b><br>\n <b>count</b>: Output port for emitting the results<br>\n <b>data</b>: Input port for receiving the incoming tuple<br>\n <br>\n <b>Properties</b>:\n rolling_window_count: Number of windows to average over\n <br>\n Compile time checks are:<br>\n none\n <br>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n Benchmarked at over 17 million tuples/second in local/in-line mode<br>\n </p>",
         "category" : "Testbench",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "description" : "The output port which emits throughput statistics.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Number>"
            }
         ],
         "displayName" : "Throughput Counter"
      },
      {
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Integer>"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.TopOccurance",
         "tags" : [
            "numeric",
            "compare"
         ],
         "properties" : [
            {
               "name" : "n",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "threshHold",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator consumes key value pairs of strings and integers.&nbsp;\n If the value of a pair is greater than the specified threshold then the tuple is emitted",
         "longDesc" : " <p></p>",
         "category" : "Testbench",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "gtThreshHold",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.Integer, java.lang.String>"
            },
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.Integer, java.lang.String>"
            }
         ],
         "displayName" : "Top Occurance"
      },
      {
         "inputPorts" : [
            {
               "name" : "in",
               "optional" : false,
               "description" : "This is the input port which receives tuples.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.util.AlertEscalationOperator",
         "tags" : [
            "time",
            "filter"
         ],
         "properties" : [
            {
               "name" : "activated",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "alertInterval",
               "type" : "long",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "timeout",
               "type" : "long",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator consumes tuples.&nbsp;\n The operator only emits a tuple if,\n at the time the operator receives the tuple,\n the amount of time since the last alert interval is greater than the specified alert interval",
         "longDesc" : " <p></p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "alert",
               "optional" : false,
               "description" : "This is the output port which emits a tuple when the alert criteria is met.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "displayName" : "Alert Escalation"
      },
      {
         "inputPorts" : [
            {
               "name" : "in",
               "optional" : false,
               "description" : "This is the input port which receives tuples.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.util.AlertThreeLevelTimedEscalationOperator",
         "tags" : [
            "time",
            "filter"
         ],
         "properties" : [
            {
               "name" : "activated",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "alertInterval",
               "type" : "long",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "levelOneAlertTime",
               "type" : "long",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "levelThreeAlertTime",
               "type" : "long",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "levelTwoAlertTime",
               "type" : "long",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "timeout",
               "type" : "long",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator allows the user to specify 3 different alert levels, each of which has its own output port.&nbsp;\n If the amount of time between consecutive tuples exceeds the interval specified for an alert level,\n then the tuple is emitted on the output port corresponding to that alert level",
         "longDesc" : " <p></p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "alert",
               "optional" : false,
               "description" : "This is the output port which emits a tuple when the alert criteria is met.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "error" : false,
               "name" : "alert2",
               "optional" : true,
               "description" : "This is the output port that emits tuples when the alert level 2 criteria is met.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "error" : false,
               "name" : "alert3",
               "optional" : true,
               "description" : "This is the output port that emits tuples when the alert level 3 criteria is met.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "displayName" : "Alert Three Level Timed Escalation"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.BaseFilteredKeyValueOperator",
         "tags" : [
            "filter",
            "key value"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator filters incoming tuples based on whether or not the tuple is contained in its filter set",
         "longDesc" : " <p>\n By default no filtering would be done as inverse is set to true and filterBy would be empty unless set<br>\n <br>\n <b>Ports</b>: None<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple. Default is true<br>\n <b>filterBy</b>: List of keys to filter on. Default is an empty filter<br>\n <br>\n <b>Specific compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None<br>\n <br>\n <b>Benchmarks</b>: Not done as there are no ports on this operator<br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [],
         "displayName" : "Base Filtered Key Value"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.BaseKeyOperator",
         "tags" : [
            "abstract",
            "clonekey"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This is an abstract operator that allows cloneKey to allow users to use mutable objects",
         "longDesc" : " <p></p>",
         "category" : "Algorithmic",
         "outputPorts" : [],
         "displayName" : "Base Key"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.BaseKeyValueOperator",
         "tags" : [
            "key value"
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This is an abstract operator that allows cloneKey and cloneValue to allow users to use mutable objects",
         "longDesc" : " <p></p>",
         "category" : "Algorithmic",
         "outputPorts" : [],
         "displayName" : "Base Key Value"
      },
      {
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "This is the input port, which receives strings.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.util.BaseLineTokenizer",
         "tags" : [
            "string"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "splitBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitBy",
               "canGet" : true
            },
            {
               "name" : "splitTokenBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitTokenBy",
               "canGet" : true
            }
         ],
         "shortDesc" : "This is an operator which consumes strings and splits them into tokens and sub-tokens",
         "longDesc" : " <p>\n processToken, and processSubToken are called for each token. Users should override calls backs to intercept at any level.\n This operator is a base class for pass through operators\n </p>\n <p>\n Ideal for applications like word count\n Ports:<br>\n <b>data</b>: expects String<br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [],
         "displayName" : "Base Line Tokenizer"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.BaseMatchOperator",
         "tags" : [
            "compare",
            "filter",
            "key value"
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ],
         "shortDesc" : "This is an abstract operator, which provides a base implementation for operators doing comparisons",
         "longDesc" : " <p>\n <br>\n Ports:<br>\n none <br>\n Properties:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>comp<b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\",\n \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n Compile time checks<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\",\n \"gte\"<br>\n <br>\n Run time checks<br>\n none<br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [],
         "displayName" : "Base Match"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.BaseNumberKeyValueOperator",
         "tags" : [
            "numeric",
            "key value"
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ],
         "shortDesc" : "This is an abstract operator,\n which provides a base implementation for operators which work with key value pairs,\n where the values are numbers",
         "longDesc" : " <p>\n Provides basic methods for value conversion<p>\n <br>\n <b>Benchmarks</b>: Not done as emit is done by sub-classes<br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [],
         "displayName" : "Base Number Key Value"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.BaseNumberValueOperator",
         "tags" : [
            "numeric"
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ],
         "shortDesc" : "This is an abstract operator, which provides a base implementation for operators which work with numbers",
         "longDesc" : " <p>\n Provides basic methods for value conversion.\n <br>\n <b>Benchmarks</b>: Not done as there is emit tuple is done by sub-classes<br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [],
         "displayName" : "Base Number Value"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.BaseUniqueKeyCounter",
         "tags" : [
            "count"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator counts the number of unique occurrences of tuples within each application window",
         "longDesc" : " <p></p>",
         "category" : "Algorithmic",
         "outputPorts" : [],
         "displayName" : "Base Unique Key Counter"
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.BaseUniqueKeyValueCounter",
         "tags" : [
            "count",
            "key value"
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator counts the number of unique occurrences of key value pairs within each application window",
         "longDesc" : " <p>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n Operator processes > 110 million tuples/sec. Only one tuple per unique key is emitted on end of window, so this operator is not bound by outbound throughput<br>\n </p>",
         "category" : "Algorithmic",
         "outputPorts" : [],
         "displayName" : "Base Unique Key Value Counter"
      },
      {
         "inputPorts" : [
            {
               "name" : "in",
               "optional" : false,
               "description" : "This is the input port which receives tuples that are maps from strings to objects.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.util.DimensionTimeBucketSumOperator",
         "tags" : [
            "count",
            "key value",
            "numeric"
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "timeBucketFlags",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "timeKeyName",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "timeZone",
               "type" : "java.util.TimeZone",
               "canSet" : true,
               "canGet" : false,
               "properties" : [
                  {
                     "name" : "DSTSavings",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "ID",
                     "type" : "java.lang.String",
                     "canSet" : true,
                     "canGet" : true
                  },
                  {
                     "name" : "displayName",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawOffset",
                     "type" : "int",
                     "canSet" : true,
                     "canGet" : true
                  }
               ]
            }
         ],
         "shortDesc" : "This operator accumulates the values of \"value\" fields for different time and dimensions and emits the accumulated values as a map.&nbsp;\n The emitted map's keys are a combination of the time and dimension fields,\n and the emitted map's values are another map from value fields to and accumulated value",
         "longDesc" : " <p></p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "out",
               "optional" : false,
               "description" : "This is the output port which emits the processed data.",
               "tupleType" : "java.util.Map<java.lang.String, java.util.Map<java.lang.String, java.lang.Number>>"
            }
         ],
         "displayName" : "Dimension Time Bucket Sum"
      },
      {
         "inputPorts" : [
            {
               "name" : "in",
               "optional" : false,
               "description" : "This is the input port on which tuples are received.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.util.JavaScriptFilterOperator",
         "tags" : [
            "filter"
         ],
         "properties" : [
            {
               "name" : "functionName",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "setupScript",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ],
         "shortDesc" : "This operator consumes tuples.&nbsp;If the tuples satisfy a specified Java Script filtering function, then they are emitted",
         "longDesc" : " <p></p>",
         "category" : "Algorithmic",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "out",
               "optional" : false,
               "description" : "This is the output port, which emits tuples that satisfy the filter.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "displayName" : "Java Script Filter"
      }
   ]
}
