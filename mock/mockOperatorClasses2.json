{
   "operatorClasses" : [
      {
         "longDesc" : "All tuples are emitted (inclusive) once a match is made.\n The comparison is done by getting double value from the Number.\n This module is a pass through<br>\n <br>\n <b> StateFull : Yes, </b> Count is aggregated over application window(s). <br>\n <b> Partitions : No, </b> will yield wrong result. <br>\n <br>\n <br>\n <b> StateFull : Yes, </b> Count is aggregated over application window(s). <br>\n <b> Partitions : No, </b> will yield wrong result. <br>\n <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>allafter</b>: emits Map&lt;K,V extends Number&gt; if compare function\n returns true<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\",\n \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\",\n \"gte\"<br>\n <b>Specific run time checks</b>: None<br>\n <br>",
         "shortDesc" : "<p>\n A compare metric is done on input tuple based on the property \"key\",\n \"value\", and \"cmp\" type",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.AllAfterMatchMap","category" : "algo",
         "displayName" : "All after match map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "allafter",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "All tuples are emitted (inclusive) once a match is made.\n The comparison is done by getting double value from the Number.\n <p>\n This module is a pass through<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map<K, String><br>\n <b>allafter</b>: emits HashMap<K, String> if compare function returns true<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp<b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\",\n \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\",\n \"gte\"<br>\n <br>\n <b>Specific run time checks</b>:<br>\n The key exists in the HashMap<br>\n Value converts to Double successfully<br>",
         "shortDesc" : "A compare metric is done on input tuple based on the property \"key\",\n \"value\", and \"cmp\"",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.AllAfterMatchStringValueMap","category" : "algo","category" : "algo",
         "displayName" : "All after match string value map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "allafter",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "At the end of window all data is flushed.\n Thus the data set is windowed and no history is kept of previous windows<br>\n The operator assumes that the key, val pairs in the incoming tuple is\n immutable. If the tuple is mutable users should override cloneKey(), and\n cloneValue()<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V&gt;<br>\n <b>bottom</b>: emits HashMap&lt;K, ArrayList&lt;V&gt;&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>N</b>: The number of top values to be emitted per key<br>\n <br>\n <b>Specific compile time checks are</b>:<br>\n N: Has to be >= 1<br>\n <br>",
         "shortDesc" : "Input stream of key value pairs is ordered by key, and bottom N of the\n ordered tuples per key are emitted on port \"bottom\" at the end of window\n <p>\n This is an end of window operator",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Expects a HashMap<K,V> tuple",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.BottomNMap","category" : "algo",
         "displayName" : "Bottom n map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "bottom",
               "optional" : true,
               "description" : "Bottom tuples output port.",
               "tupleType" : "java.util.HashMap<K, java.util.ArrayList<V>>"
            }
         ],
         "properties" : [
            {
               "name" : "ascending",
               "type" : "boolean",
               "canSet" : false,
               "description" : "false",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "n",
               "type" : "int",
               "canSet" : true,
               "description" : "n",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "<p>BottomNUnifier class.</p>",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.algo.BottomNUnifier","category" : "algo",
         "displayName" : "Bottom n unifier",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mergedport",
               "optional" : true,
               "description" : "Default output port.",
               "tupleType" : "java.util.HashMap<K, java.util.ArrayList<V>>"
            }
         ],
         "properties" : [
            {
               "name" : "n",
               "type" : "int",
               "canSet" : true,
               "description" : "n",
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "Input stream of key value pairs are ordered by key, and bottom N of the ordered unique tuples per key are emitted on\n port \"top\" at the end of window<p>\n This is an end of window module<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V&gt;<br>\n <b>bottom</b>: emits HashMap&lt;K, ArrayList&lt;HashMap&lt;V,Integer&gt;&gt;&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>N</b>: The number of top values to be emitted per key<br>\n <br>\n <b>Specific compile time checks are</b>:<br>\n N: Has to be >= 1<br>",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Expects a HashMap<K,V> tuple",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.BottomNUniqueMap","category" : "algo",
         "displayName" : "Bottom n unique map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "bottom",
               "optional" : true,
               "description" : "Bottom tuples output port.",
               "tupleType" : "java.util.HashMap<K, java.util.ArrayList<java.util.HashMap<V, java.lang.Integer>>>"
            }
         ],
         "properties" : [
            {
               "name" : "ascending",
               "type" : "boolean",
               "canSet" : false,
               "description" : "false",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "n",
               "type" : "int",
               "canSet" : true,
               "description" : "n",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The function is given by\n \"key\", \"value\", and \"cmp\". If a tuple passed the test count is incremented. On end of window count is emitted on the output port \"count\".\n The comparison is done by getting double value from the Number.<p>\n This module is an end of window module. If no tuple comes in during a window 0 is emitted on both ports, thus no matter what one Integer\n tuple is emitted on each port<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s). <br>\n <b>Partitions : Yes, </b> count is unified at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>count</b>: emits Integer<br>\n <b>except</b>: emits Integer<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>",
         "shortDesc" : "A count is done on how many tuples of value type Number satisfy the compare function",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.CompareExceptCountMap","category" : "algo",
         "displayName" : "Compare except count map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "description" : "Match count output port.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "except",
               "optional" : true,
               "description" : "Not match count output port.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The function is given by\n \"key\", \"value\", and \"compare\". If a tuple passed the test count is incremented. On end of window count is emitted on the output port \"count\".\n The comparison is done by getting double value from the Number.<p>\n This module is an end of window module. If no tuple comes in during a window 0 is emitted on both ports, thus no matter what one Integer\n tuple is emitted on each port<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s). <br>\n <b>Partitions : Yes, </b> count is unified at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,String&gt;<br>\n <b>count</b>: emits Integer<br>\n <b>except</b>: emits Integer<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>",
         "shortDesc" : "A count is done on how many tuples of value type String satisfy the compare function",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.CompareExceptCountStringMap","category" : "algo",
         "displayName" : "Compare except count string map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "except",
               "optional" : true,
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "emitError",
               "type" : "boolean",
               "canSet" : true,
               "description" : "emitError",
               "canGet" : true
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Thus the data set is windowed\n and no history is kept of previous windows<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s). <br>\n <b>Partitions : Yes, </b> distinct output is unified by same operator. <br>\n <br>\n <b>Ports</b><br>\n <b>data</b>: Input data port expects K<br>\n <b>distinct</b>: Output data port, emits K<br>\n <br>\n <b>Properties</b>: None<br>\n <br>",
         "shortDesc" : "Computes and emits distinct tuples of type K (i.e drops duplicates) at end of window<p>\n <br>\n This module is same as a \"FirstOf\" metric on any key, val pair\n Even though this module produces continuous tuples, at end of window all data is flushed",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.algo.Distinct","category" : "algo",
         "displayName" : "Distinct",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "distinct",
               "optional" : true,
               "description" : "Output for distinct values. </b>",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "At end of window all data is flushed.<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s). <br>\n <b>Partitions : Yes, </b> distinct output is unified by unifier hash map operator. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Input data port expects Map&lt;K,V&gt;<br>\n <b>distinct</b>: Output data port, emits HashMap&lt;K,V&gt;(1)<br>\n <br>",
         "shortDesc" : "Computes and emits distinct key,val pairs (i.e drops duplicates)<p>\n This is a pass through operator<br>\n <br>\n This module is same as a \"FirstOf\" metric on any key,val pair",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.DistinctMap","category" : "algo",
         "displayName" : "Distinct map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "distinct",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "If\n property \"inverse\" is set to \"true\", then all key,val pairs except those specified by in keyvals parameter are emitted<p>\n Operator assumes that the key, val pairs are immutable objects. If this operator has to be used for mutable objects,\n override \"cloneKey()\" to make copy of K, and \"cloneValue()\" to make copy of V.<br>\n This is a pass through node<br>\n <br>\n <b>StateFull : No, </b> tuple are processed in current window. <br>\n <b>Partitions : Yes, </b> no dependency among input tuples. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects HashMap&lt;K,V&gt;<br>\n <b>filter</b>: emits HashMap&lt;K,V&gt;(1)<br>\n <br>\n <b>Properties</b>:<br>\n <b>keyvals</b>: The keyvals is key,val pairs to pass through, rest are filtered/dropped.<br>\n <br>",
         "shortDesc" : "Filters the incoming stream based of specified key,val pairs, and emits those that match the filter",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.FilterKeyVals","category" : "algo",
         "displayName" : "Filter key vals",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "filter",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "inverse",
               "canGet" : true
            },
            {
               "name" : "keyVals",
               "type" : "java.util.HashMap",
               "canSet" : true,
               "description" : "keyvals hash",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "empty",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "If\n property \"inverse\" is set to \"true\", then all keys except those specified by \"keys\" are emitted<p>\n Operator assumes that the key, val pairs are immutable objects. If this operator has to be used for mutable objects,\n override \"cloneKey()\" to make copy of K, and \"cloneValue()\" to make copy of V.<br>\n This is a pass through node.<br>\n <br>\n <b>StateFull : No, </b> tuple are processed in current window. <br>\n <b>Partitions : Yes, </b> no dependency among input tuples. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Expects Map&lt;K, HashMap&lt;K,V&gt;&gt. Filters are applied only on keys of second hash map.<br>\n <b>filter</b>: Emits HashMap&lt;K, HashMap&lt;K,V&gt;&gt.<br>\n <br>\n <b>Properties</b>:<br>\n <b>keys</b>: The keys to pass through, rest are filtered/dropped. A comma separated list of keys.<br>\n <br>",
         "shortDesc" : "Filters the incoming stream based of keys specified by property \"keys\"",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.Map<K, java.util.HashMap<K, V>>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.FilterKeysHashMap","category" : "algo",
         "displayName" : "Filter keys hash map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "filter",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.HashMap<K, java.util.HashMap<K, V>>"
            }
         ],
         "properties" : [
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "inverse",
               "canGet" : true
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "keys",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "If\n property \"inverse\" is set to \"true\", then all keys except those specified by \"keys\" are emitted<p>\n Operator assumes that the key, val pairs are immutable objects. If this operator has to be used for mutable objects,\n override \"cloneKey()\" to make copy of K, and \"cloneValue()\" to make copy of V.<br>\n This is a pass through node<br>\n <br>\n <b>StateFull : No, </b> tuple are processed in current window. <br>\n <b>Partitions : Yes, </b> no dependency among input tuples. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Expects Map&lt;K,V&gt;<br>\n <b>filter</b>: Emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>keys</b>: The keys to pass through, rest are filtered/dropped. A comma separated list of keys<br>\n <br>",
         "shortDesc" : "Filters the incoming stream based of keys specified by property \"keys\"",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.FilterKeysMap","category" : "algo",
         "displayName" : "Filter keys map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "filter",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "inverse",
               "canGet" : true
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "keys",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "If\n property \"inverse\" is set to \"true\", then all keys except those specified by \"keys\" are emitted. The values are expected to be immutable<p>\n This operator should not be used with mutable objects. If this operator has immutable Objects, override \"cloneCopy\" to ensure a new copy is sent out.\n This is a pass through node<br>\n <br>\n <b>StateFull : No, </b> tuple are processed in current window. <br>\n <b>Partitions : Yes, </b> no dependency among input tuples. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expect T (a POJO)<br>\n <b>filter</b>: emits T (a POJO)<br>\n <br>\n <b>Properties</b>:<br>\n <b>keys</b>: The keys to pass through. Those not in the list are dropped. A comma separated list of keys<br>\n <br>",
         "shortDesc" : "Filters incoming stream and emits values as specified by the set of values to filter",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.algo.FilterValues","category" : "algo",
         "displayName" : "Filter values",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "filter",
               "optional" : true,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "properties" : [
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "inverse",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "java.lang.Object",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "values",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "  The comparison is done by getting double value from the Number.<p>\n This module is a pass through<br>\n The operators by default assumes immutable keys. If the key is mutable, use cloneKey to make a copy<br>\n <br>\n <b>StateFull : Yes, </b> tuple are processed in current window. <br>\n <b>Partitions : No, </b>will yield wrong results. <br>\n <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>first</b>: emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>",
         "shortDesc" : "A compare metric on a Number tuple based on the property \"key\", \"value\", and \"cmp\"; the first match is emitted",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.FirstMatchMap","category" : "algo",
         "displayName" : "First match map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "first",
               "optional" : true,
               "description" : "Output port, unifier operator.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The comparison is done by getting double\n value from the Number.<p>\n This module is a pass through<br>\n <br>\n <b>StateFull : Yes, </b> tuple are processed in current window. <br>\n <b>Partitions : No, </b>will yield wrong results. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,String&gt;><br>\n <b>first</b>: emits HashMap&lt;K,String&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>",
         "shortDesc" : "A compare metric on a tuple with value type String, based on the property \"key\", \"value\", and \"cmp\"; the first match is emitted",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.FirstMatchStringMap","category" : "algo",
         "displayName" : "First match string map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "first",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n <b>Partitions : No, </b> will yield wrong results. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Input data port expects HashMap&lt;K,V&gt;<br>\n <b>bottom</b>: Output data port, emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>N</b>: The number of top values to be emitted per key<br>\n <br>\n <b>Specific compile time checks are</b>:<br>\n N: Has to be >= 1<br>\n <br>\n <br>",
         "shortDesc" : "Emits first N tuples of a particular key.<p>\n This module is a pass through module<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s)",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Expects a HashMap<K,V> tuple",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.FirstN","category" : "algo",
         "displayName" : "First n",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "first",
               "optional" : true,
               "description" : "Output port, unifier operator.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "n",
               "type" : "int",
               "canSet" : true,
               "description" : "n",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Then on no tuple is emitted in that window. The comparison is done by getting double value of the Number.<p>\n This module is a pass through<br>\n <br>\n <b>StateFull : Yes, </b> tuple are processed in current window. <br>\n <b>Partitions : No, </b>will yield wrong results. <br>\n <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Input port, expects HashMap&lt;K,V&gt;<br>\n <b>first</b>: Output port, emits HashMap&lt;K,V&gt; if compare function returns true<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>",
         "shortDesc" : "All key.val pairs with val sub-classed from Number are emitted till the first match;  A compare metric is done based on the property \"key\",\n \"value\", and \"cmp\"",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.FirstTillMatch","category" : "algo",
         "displayName" : "First till match",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "first",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Then on no tuple is emitted in that window. The comparison is done by getting double value of the Number.<p>\n This module is a pass through<br>\n <br>\n <b>StateFull : Yes, </b> tuple are processed in current window. <br>\n <b>Partitions : No, </b>will yield wrong results. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Input port, expects HashMap&lt;K,String&gt;<br>\n <b>first</b>: Output port, emits HashMap&lt;K,String&gt; if compare function returns true<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n Compile time checks<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n <br>",
         "shortDesc" : "All key,val pairs with val of type String are emitted till the first match;  A compare metric is done based on the property \"key\", \"value\",\n and \"cmp\"",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.FirstTillMatchString","category" : "algo",
         "displayName" : "First till match string",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "first",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The incoming tuple\n is merged into already existing sorted list. At the end of the window the\n entire sorted list is emitted on output port \"sort\"\n <p/>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s). <br>\n <b>Partitions : Yes, </b> the operator itself serves as the unifier.\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects K<br>\n <b>datalist</b>: expects ArrayList&lt;K&gt;<br>\n <b>sortlist</b>: emits ArrayList&lt;K&gt;, must be connected<br>\n <br>",
         "shortDesc" : "Takes a stream of key value pairs via input port \"data\"",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : true,
               "description" : "Input port that takes in one tuple at a time",
               "tupleType" : "class java.lang.Object"
            },
            {
               "name" : "datalist",
               "optional" : true,
               "description" : "Input port that takes in an array of Objects to insert",
               "tupleType" : "java.util.ArrayList<K>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.InsertSort","category" : "algo",
         "displayName" : "Insert sort",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "sort",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.ArrayList<K>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "size",
               "type" : "int",
               "canSet" : true,
               "description" : "size",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "At the end of the window the resultant sorted list is emitted on the output ports<p>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s). <br>\n <b>Partitions : No, </b> will yield wrong results. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects K<br>\n <b>datalist</b>: expects ArrayList&lt;K&gt;<br>\n <b>sortlist</b>: emits ArrayList&lt;K&gt;<br>\n <b>sorthash</b>: emits HashMap&lt;K,Integer&gt;<br>\n <br>\n <br>",
         "shortDesc" : "Incoming tuple is inserted into already existing sorted list in a descending order",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : true,
               "description" : "Input port that takes in one tuple at a time",
               "tupleType" : "class java.lang.Object"
            },
            {
               "name" : "datalist",
               "optional" : true,
               "description" : "Input port that takes in an array of Objects to insert",
               "tupleType" : "java.util.ArrayList<K>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.InsertSortDesc","category" : "algo",
         "displayName" : "Insert sort desc",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "sort",
               "optional" : true,
               "tupleType" : "java.util.ArrayList<K>"
            },
            {
               "error" : false,
               "name" : "sorthash",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "size",
               "type" : "int",
               "canSet" : true,
               "description" : "size",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n <b>Partitions : Yes, </b> inverted indexes are unified by instance of same operator. <br>\n <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects &lt;K,V&gt;<br>\n <b>index</b>: emits &lt;V,ArrayList&lt;K&gt;&gt;(1); one HashMap per V<br>\n <br>",
         "shortDesc" : "Inverts the index and sends out the tuple on output port \"index\" at the end of the window<p>\n This is an end of window operator<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s)",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.InvertIndex","category" : "algo",
         "displayName" : "Invert index",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "index",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.HashMap<V, java.util.ArrayList<K>>"
            }
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n <b>Partitions : Yes, </b> inverted indexes are unified by instance of same operator. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects HashMap&lt;K,ArrayList&lt;V&gt;&gt;<br>\n <b>index</b>: emits HashMap&lt;V,ArrayList&lt;K&gt;&gt;(1), one HashMap per V<br>\n <br>",
         "shortDesc" : "Inverts the index and sends out the tuple on output port \"index\" at the end of the window<p>\n This is an end of window operator<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s)",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.HashMap<K, java.util.ArrayList<V>>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.InvertIndexArray","category" : "algo",
         "displayName" : "Invert index array",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "index",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.HashMap<V, java.util.ArrayList<K>>"
            }
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Every tuple\n is checked and the last one that passes the condition is send during end of window on port \"last\". The comparison is done by getting double\n value from the Number<p>\n This module is an end of window module<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s). <br>\n <b>Partitions : No, </b> will yield wrong result. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>last</b>: emits Map&lt;K,V&gt; in end of window for the last tuple on which the compare function is true<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>",
         "shortDesc" : "A compare function is  operated on a tuple value sub-classed from Number based on the property \"key\", \"value\", and \"cmp\"",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.LastMatchMap","category" : "algo",
         "displayName" : "Last match map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "last",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Every tuple\n is checked and the last one that passes the condition is send during end of window on port \"last\". The comparison is done by getting double\n value from the Number<p>\n This module is an end of window module<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compare across application window(s). <br>\n <b>Partitions : No, </b> will yield wrong result. <br>\n <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,String&gt;<br>\n <b>last</b>: emits HashMap&lt;K,String&gt; in end of window for the last tuple on which the compare function is true<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>",
         "shortDesc" : "A compare function is operated on a tuple value of type String based on the property \"key\", \"value\", and \"cmp\"",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.LastMatchStringMap","category" : "algo",
         "displayName" : "Last match string map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "last",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The list port would however have all the tied keys\n <br>\n <b>StateFull : Yes, </b> tuple are compared across application window(s). <br>\n <b>Partitions : Yes, </b> least keys are unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects K<br>\n <b>least</b>: emits HashMap&lt;K,Integer&gt;(1), Where K is the least occurring key in the window.\n               In case of tie any of the least key would be emitted<br>\n <b>list</b>: emits ArrayList&lt;HashMap&lt;K,Integer&gt;(1)&gt, Where the list includes all the keys that are least frequent<br>\n <br>",
         "shortDesc" : "<p>\n Occurrences of each tuple is counted and at the end of window any of the least frequent tuple is emitted on output port 'least'\n All keys with same least frequency value least are emitted on output port 'list'.<br>\n This module is an end of window module<br>\n In case of a tie any of the least key would be emitted",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.algo.LeastFrequentKey","category" : "algo",
         "displayName" : "Least frequent key",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "least",
               "optional" : true,
               "description" : "Output port, optional.",
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "list",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.ArrayList<java.util.HashMap<K, java.lang.Integer>>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "<p>LeastFrequentKeyArrayUnifier class.</p>",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.algo.LeastFrequentKeyArrayUnifier","category" : "algo",
         "displayName" : "Least frequent key array unifier",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mergedport",
               "optional" : true,
               "description" : "Default output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : "In case of a tie any of the least key would be emitted. The list port would however have all the tied keys<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compared across application window(s). <br>\n <b>Partitions : Yes, </b> least keys are unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V&gt;, V is ignored/not used<br>\n <b>least</b>: emits HashMap&lt;K,Integer&gt;(1); where String is the least frequent key, and Integer is the number of its occurrences in the window<br>\n <b>list</b>: emits ArrayList&lt;HashMap&lt;K,Integer&gt;(1)&gt;; Where the list includes all the keys are least frequent<br>\n <br>",
         "shortDesc" : "Occurrences of each key is counted and at the end of window any of the least frequent key is emitted on output port least and all least frequent\n keys on output port list<p>\n This module is an end of window module",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.LeastFrequentKeyMap","category" : "algo",
         "displayName" : "Least frequent key map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "least",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "list",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.ArrayList<java.util.HashMap<K, java.lang.Integer>>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "<p>LeastFrequentKeyUnifier class.</p>",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.algo.LeastFrequentKeyUnifier","category" : "algo",
         "displayName" : "Least frequent key unifier",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mergedport",
               "optional" : true,
               "description" : "Default output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : " The benchmark was done with immutable objects. If K or V are mutable the benchmark may be lower</td></tr>\n </table><br>\n <p>\n <b>Function Table (K=String,V=Integer);</b>:\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Function table for LeastFrequentKeyValueMap&lt;K,V&gt; operator template\">\n <tr><th rowspan=2>Tuple Type (api)</th><th>In-bound (process)</th><th>Out-bound (emit)</th></tr>\n <tr><th><i>data</i>(Map&lt;K,V&gt;)</th><th><i>least</i>(HashMap&lt;K,HashMap&lt;Integer&gt;&gt;)</th></tr>\n <tr><td>Begin Window (beginWindow())</td><td>N/A</td><td>N/A</td></tr>\n <tr><td>Data (process())</td><td>{a=1,b=5,c=110}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=55,c=2000,b=45}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{d=2}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=55,b=5,c=22}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{h=20,a=2,z=5}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=4,c=110}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=4,z=5}</td><td></td></tr>\n <tr><td>End Window (endWindow())</td><td>N/A</td><td>{a={1=1,2=1},b={45=1},c={2000=1,22=1},d={2=1},h={20=1},z={5=2}</td></tr>\n </table>\n <br>\n <br>",
         "shortDesc" : "Occurrences of all values for each key is counted and at the end of window the least frequent values are emitted on output port least per key<p>\n This module is an end of window module<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V&gt;<br>\n <b>least</b>: Output port, emits HashMap&lt;K,HashMap&lt;V,Integer&gt;&gt;(1)<br>\n <br>\n <b>Properties</b>: None<br>\n <br>\n <b>Compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None <br>\n <br>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Benchmark table for LeastFrequentKeyValueMap&lt;K,V&gt; operator template\">\n <tr><th>In-Bound</th><th>Out-bound</th><th>Comments</th></tr>\n <tr><td><b>&gt; 30 Million K,V pairs/s</b></td><td>Emits only 1 tuple per window per key</td><td>In-bound throughput is the main determinant of performance",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.LeastFrequentKeyValueMap","category" : "algo",
         "displayName" : "Least frequent key value map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "least",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.util.HashMap<V, java.lang.Integer>>"
            }
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The function is given by\n \"key\", \"value\", and \"cmp\". If all tuples passes a Boolean(true) is emitted, else a Boolean(false) is emitted on end of window on the output port \"all\".\n The comparison is done by getting double value from the Number.<p>\n This module is an end of window module<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compared across application window(s). <br>\n <b>Partitions : Yes, </b> match status is unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>all</b>: emits Boolean<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>",
         "shortDesc" : "Each tuple is tested for the compare function",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MatchAllMap","category" : "algo",
         "displayName" : "Match all map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "all",
               "optional" : true,
               "tupleType" : "class java.lang.Boolean"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The function is given by\n \"key\", \"value\", and \"cmp\". If all tuples passes a Boolean(true) is emitted, else a Boolean(false) is emitted on end of window on the output port \"all\".\n The comparison is done by getting double value from the Number.<p>\n This module is an end of window module<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compared across application window(s). <br>\n <b>Partitions : Yes, </b> match status is unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,String&gt;<br>\n <b>all</b>: emits Boolean<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <b>Specific run time checks</b>: None<br>\n <br>",
         "shortDesc" : "Each tuple is tested for the compare function",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MatchAllStringMap","category" : "algo",
         "displayName" : "Match all string map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "all",
               "optional" : true,
               "tupleType" : "class java.lang.Boolean"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The function is given by\n \"key\", \"value\", and \"compare\". If any tuple passes a Boolean(true) is emitted, else a Boolean(false) is emitted on the output port \"any\".\n The comparison is done by getting double value from the Number.<p>\n This module is a pass through as it emits the moment the condition is met<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compared across application window(s). <br>\n <b>Partitions : Yes, </b> match status is unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>any</b>: emits Boolean<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <b>Specific run time checks</b>: None<br>\n <br>",
         "shortDesc" : "Each tuple is tested for the compare function",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MatchAnyMap","category" : "algo",
         "displayName" : "Match any map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "any",
               "optional" : true,
               "tupleType" : "class java.lang.Boolean"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The function is given by\n \"key\", \"value\", and \"compare\". If any tuple passes a Boolean(true) is emitted, else a Boolean(false) is emitted on the output port \"any\".\n The comparison is done by getting double value from the Number.<p>\n This module is a pass through as it emits the moment the condition is met<br>\n <br>\n <b>StateFull : Yes, </b> tuple are compared across application window(s). <br>\n <b>Partitions : Yes, </b> match status is unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map<K,String><br>\n <b>any</b>: emits Boolean<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>",
         "shortDesc" : "Each tuple is tested for the compare function",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MatchAnyStringMap","category" : "algo",
         "displayName" : "Match any string map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "any",
               "optional" : true,
               "tupleType" : "class java.lang.Boolean"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "If the tuple\n passed the test, it is emitted on the output port match. The comparison is done by getting double\n value from the Number. Both output ports are optional, but at least one has to be connected<p>\n This module is a pass through<br>\n <br>\n <b>StateFull : No, </b> tuple is processed in current application window. <br>\n <b>Partitions : Yes, </b> match status is unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>match</b>: emits HashMap&lt;K,V&gt<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>",
         "shortDesc" : "A compare function is imposed based on the property \"key\", \"value\", and \"cmp\"",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MatchMap","category" : "algo",
         "displayName" : "Match map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "If the tuple\n passed the test, it is emitted on the output port \"match\". The comparison is done by getting double\n value from the Number. Both output ports are optional, but at least one has to be connected<p>\n This module is a pass through<br>\n <br>\n <b>StateFull : No, </b> tuple is processed in current application window. <br>\n <b>Partitions : Yes, </b> match status is unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,String&gt;<br>\n <b>match</b>: emits HashMap&lt;K,String&gt; if compare function returns true<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Specific compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>",
         "shortDesc" : "A compare function is imposed based on the property \"key\", \"value\", and \"cmp\"",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MatchStringMap","category" : "algo",
         "displayName" : "Match string map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "emitError",
               "type" : "boolean",
               "canSet" : true,
               "description" : "emitError",
               "canGet" : true
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The input list is expected to be sorted. <b>\n At the end of the window, merged sorted list is emitted on sort output port. <br>\n <br>\n <b>Notes : </b> <br>\n Get unifier instance must return instance of sub class itself, since merge operator\n id unifier on output port. <br>\n <br>\n  <b>StateFull : Yes</b>, Sorted listed are merged over application window can be > 1. <br>\n  <b>Partitions : Yes</b>, Operator itself is used as unfier on output port.\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects ArrayList&lt;K&gt;<br>\n <b>sort</b>: emits ArrayList&lt;K&gt;<br>\n <br>\n <b>Abstract Methods: </b><br>\n 1. compare : K type value compare criteria for sort.\n 2. getUnifierInstance : Get unifier operator instance for output port, (must return self instance).",
         "shortDesc" : "<p>\n Incoming sorted list is merged into already existing sorted list",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.ArrayList<K>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MergeSortNumber","category" : "algo",
         "displayName" : "Merge sort number",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "sort",
               "optional" : true,
               "description" : "Sorted list output port.",
               "tupleType" : "java.util.ArrayList<K>"
            }
         ],
         "properties" : [
            {
               "name" : "ascending",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "unifierInstance",
               "type" : "com.datatorrent.api.Operator$Unifier",
               "canSet" : false,
               "canGet" : true,
               "properties" : []
            }
         ]
      },
      {
         "longDesc" : "The list port would however have all the tied keys\n <br>\n  <b>StateFull : Yes</b>, Values are compared all over  application window can be > 1. <br>\n  <b>Partitions : Yes</b>, Result is unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects K<br>\n <b>most</b>: emits HashMap&lt;K,Integer&gt;(1), Where K is the least occurring key in the window. In case of tie any of the least key would be emitted<br>\n <b>list</b>: emits ArrayList&lt;HashMap&lt;K,Integer&gt;(1)&gt, Where the list includes all the keys that are least frequent<br>\n <br>\n <b>Properties</b>: None<br>\n <br>\n <b>Compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None<br>\n <br>",
         "shortDesc" : "Occurrences of each tuple is counted and at the end of window any of the most frequent tuple is emitted on output port least and all least frequent\n tuples on output port list<p>\n This module is an end of window module<br>\n In case of a tie any of the least key would be emitted",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MostFrequentKey","category" : "algo",
         "displayName" : "Most frequent key",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "list",
               "optional" : true,
               "tupleType" : "java.util.ArrayList<java.util.HashMap<K, java.lang.Integer>>"
            },
            {
               "error" : false,
               "name" : "most",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "In case of a tie any of the least key would be emitted. The list port would however have all the tied keys<br>\n <br>\n  <b>StateFull : Yes</b>, Values are compared all over  application window can be > 1. <br>\n  <b>Partitions : Yes</b>, Result is unified on output port. <br>\n  <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V&gt;, V is ignored/not used<br>\n <b>most</b>: emits HashMap&lt;K,Integer&gt;(1); where String is the least frequent key, and Integer is the number of its occurrences in the window<br>\n <b>list</b>: emits ArrayList&lt;HashMap&lt;K,Integer&gt;(1)&gt;; Where the list includes all the keys are least frequent<br>\n <br>",
         "shortDesc" : "Occurrences of each key is counted and at the end of window any of the most frequent key is emitted on output port least and all least frequent\n keys on output port list<p>\n This module is an end of window module",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MostFrequentKeyMap","category" : "algo",
         "displayName" : "Most frequent key map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "list",
               "optional" : true,
               "tupleType" : "java.util.ArrayList<java.util.HashMap<K, java.lang.Integer>>"
            },
            {
               "error" : false,
               "name" : "most",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : " The benchmark was done with immutable objects. If K or V are mutable the benchmark may be lower</td></tr>\n </table><br>\n <p>\n <b>Function Table (K=String,V=Integer);</b>:\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Function table for MostFrequentKeyValueMap&lt;K,V&gt; operator template\">\n <tr><th rowspan=2>Tuple Type (api)</th><th>In-bound (process)</th><th>Out-bound (emit)</th></tr>\n <tr><th><i>data</i>(HashMap&lt;K,V&gt;)</th><th><i>most</i>(HashMap&lt;K,HashMap&lt;Integer&gt;&gt;)</th></tr>\n <tr><td>Begin Window (beginWindow())</td><td>N/A</td><td>N/A</td></tr>\n <tr><td>Data (process())</td><td>{a=1,b=5,c=110}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=55,c=2000,b=45}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{d=2}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=55,b=5,c=22}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{h=20,a=2,z=5}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=4,c=110}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=4,z=5}</td><td></td></tr>\n <tr><td>End Window (endWindow())</td><td>N/A</td><td>{a={4=2,55=2},b={5=2},c={110=2},d={2=1},h={20=1},z={5=2}</td></tr>\n </table>\n <br>\n <br>",
         "shortDesc" : "Occurrences of all values for each key is counted and at the end of window the most frequent values are emitted on output port least per key<p>\n This module is an end of window module<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects HashMap&lt;K,V&gt;<br>\n <b>most</b>: emits HashMap&lt;String, HashMap&lt;String, Integer&gt;&gt;(1)<br>\n <br>\n <br>\n <b>Properties</b>: None<br>\n <br>\n <b>Compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None <br>\n <br>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Benchmark table for MostFrequentKeyValueMap&lt;K,V&gt; operator template\">\n <tr><th>In-Bound</th><th>Out-bound</th><th>Comments</th></tr>\n <tr><td><b>&gt; 30 Million K,V pairs/s</b></td><td>Emits only 1 tuple per window per key</td><td>In-bound throughput is the main determinant of performance",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.MostFrequentKeyValueMap","category" : "algo",
         "displayName" : "Most frequent key value map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "most",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.util.HashMap<V, java.lang.Integer>>"
            }
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "<p>PartitionableUniqueCount class.</p>",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            },
            {
               "name" : "data1",
               "optional" : true,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.algo.PartitionableUniqueCount","category" : "algo",
         "displayName" : "Partitionable unique count",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "tupleType" : "com.datatorrent.lib.util.KeyHashValPair<K, java.lang.Integer>"
            }
         ],
         "properties" : [
            {
               "name" : "cumulative",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.algo.PartitionableUniqueCount$UniqueCountUnifier",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mergedport",
               "optional" : true,
               "tupleType" : "com.datatorrent.lib.util.KeyHashValPair<K, java.lang.Integer>"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : "<br>\n Emits the tuple as per probability of pass rate out of total rate. <br>\n <br>\n An efficient filter to allow sample analysis of a stream. Very useful is the incoming stream has high throughput<p>\n <br>\n <b> StateFull : No, </b> tuple is processed in current window. <br>\n <b> Partitions : Yes. </b> No state dependency among input tuples. <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects K<br>\n <b>sample</b>: emits K<br>\n <br>\n <b>Properties</b>:<br>\n <b>passrate</b>: Sample rate out of a total of totalrate. Default is 1<br>\n <b>totalrate</b>: Total rate (divisor). Default is 100<br>\n <br>\n <b>Specific compile time checks are</b>: None<br>\n passrate is positive integer<br>\n totalrate is positive integer<br>\n passrate and totalrate are not compared (i.e. passrate &lt; totalrate) check is not done to allow users to make this operator a passthrough (all) during testing<br>\n <br>\n <b>Specific run time checks are</b>: None<br>\n <br>",
         "shortDesc" : "Emits sample percentage tuples",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.algo.Sampler","category" : "algo",
         "displayName" : "Sampler",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "sample",
               "optional" : true,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "passrate",
               "type" : "int",
               "canSet" : true,
               "description" : "passrate",
               "canGet" : true
            },
            {
               "name" : "totalrate",
               "type" : "int",
               "canSet" : true,
               "description" : "totalrate",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n <b>Partitions : Yes, </b> Top values are unified on output port. <br>\n <b>Ports</b>:<br>\n <b>data</b>: Input data port expects HashMap&lt;K,V&gt;<br>\n <b>top</b>: Output data port, emits HashMap&lt;K, ArrayList&lt;V&gt;&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>N</b>: The number of top values to be emitted per key<br>\n <br>\n <b>Specific compile time checks are</b>:<br>\n N: Has to be >= 1<br>\n <br>",
         "shortDesc" : "Orders tuples per key and emits top N tuples per key on end of window<p>\n This is an end of window module.<br>\n <br>\n <b>StateFull : Yes, </b> Tuple are aggregated across application window(s)",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Expects a HashMap<K,V> tuple",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.TopN","category" : "algo",
         "displayName" : "Top n",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "top",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.HashMap<K, java.util.ArrayList<V>>"
            }
         ],
         "properties" : [
            {
               "name" : "ascending",
               "type" : "boolean",
               "canSet" : false,
               "description" : "true",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "n",
               "type" : "int",
               "canSet" : true,
               "description" : "n",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Thus the data set is windowed and no history is kept of previous windows<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Input data port expects HashMap&lt;K,V&gt;<br>\n <b>top</b>: Output data port, emits HashMap&lt;K, ArrayList&lt;V&gt;&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>N</b>: The number of top values to be emitted per key<br>\n <br>\n <b>Specific compile time checks are</b>:<br>\n N: Has to be >= 1<br>\n <br>\n <b>Specific run time checks are</b>: None<br>\n <br>",
         "shortDesc" : "Orders tuples per key and emits top N unique tuples per key on end of window<p>\n This is an end of window module<br>\n At the end of window all data is flushed",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Expects a HashMap<K,V> tuple",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.TopNUnique","category" : "algo",
         "displayName" : "Top n unique",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "top",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.util.ArrayList<java.util.HashMap<V, java.lang.Integer>>>"
            }
         ],
         "properties" : [
            {
               "name" : "ascending",
               "type" : "boolean",
               "canSet" : false,
               "description" : "true",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "n",
               "type" : "int",
               "canSet" : true,
               "description" : "n",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n <b>Partitions : Yes, </b> Unique count is unified at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects K<br>\n <b>count</b>: emits HashMap&lt;K,Integer&gt;<br>\n <b>Properties</b>: None<br>\n <br>",
         "shortDesc" : "Counts the number of times a key exists in a window; Count is emitted at end of window in a single HashMap<p>\n This is an end of window operator<br>\n <br>\n <b>StateFull : yes, </b> Tuples are aggregated over application window(s)",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.algo.UniqueCounter","category" : "algo",
         "displayName" : "Unique counter",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<p>\n This is an end of window operator<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects K<br>\n <b>count</b>: emits Integer<br>\n <b>Properties</b>: None<br>\n <br>\n <b>Specific compile time checks</b>: None<br>\n <b>Specific run time checks</b>:<br>\n <br>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Benchmark table for UniqueCounter&lt;K&gt; operator template\">\n <tr><th>In-Bound</th><th>Out-bound</th><th>Comments</th></tr>\n <tr><td><b>&gt; processes 110 Million K,V pairs/s</b></td><td>Emits one tuple per window</td><td>In-bound throughput\n and number of unique k are the main determinant of performance. Tuples are assumed to be immutable. If you use mutable tuples and have lots of keys,\n the benchmarks may be lower</td></tr>\n </table><br>\n <p>\n <b>Function Table (K=String)</b>:\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Function table for UniqueCounter&lt;K&gt; operator template\">\n <tr><th rowspan=2>Tuple Type (api)</th><th>In-bound (process)</th><th>Out-bound (emit)</th></tr>\n <tr><th><i>data</i>(K)</th><th><i>count</i>(Integer)</th></tr>\n <tr><td>Begin Window (beginWindow())</td><td>N/A</td></tr>\n <tr><td>Data (process())</td><td>a</td></tr>\n <tr><td>Data (process())</td><td>b</td></tr>\n <tr><td>Data (process())</td><td>c</td></tr>\n <tr><td>Data (process())</td><td>4</td></tr>\n <tr><td>Data (process())</td><td>5ah</td></tr>\n <tr><td>Data (process())</td><td>h</td></tr>\n <tr><td>Data (process())</td><td>a</td></tr>\n <tr><td>Data (process())</td><td>a</td></tr>\n <tr><td>Data (process())</td><td>a</td></tr>\n <tr><td>Data (process())</td><td>a</td></tr>\n <tr><td>Data (process())</td><td>5ah</td></tr>\n <tr><td>Data (process())</td><td>a</td></tr>\n <tr><td>Data (process())</td><td>c</td></tr>\n <tr><td>Data (process())</td><td>c</td></tr>\n <tr><td>Data (process())</td><td>b</td></tr>\n <tr><td>End Window (endWindow())</td><td>N/A</td><td>15</td></tr>\n </table>\n <br>",
         "shortDesc" : "Counts the number of tuples emitted in a window",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.algo.UniqueCounterValue","category" : "algo",
         "displayName" : "Unique counter value",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "tupleType" : "class java.lang.Integer"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<p>\n This is an end of window operator<br>\n <br>\n <b>StateFull : yes, </b> Tuples are aggregated over application window(s). <br>\n <b>Partitions : Yes, </b> Unique count is unified at output port. <br>\n <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects HashMap&lt;K,V&gt;<br>\n <b>count</b>: emits HashMap&lt;HashMap&lt;K,V&gt;(1),Integer&gt;(1)<br>\n <br>",
         "shortDesc" : "Count unique occurrences of key,val pairs within a window, and emits one HashMap tuple",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.UniqueKeyValCounter","category" : "algo",
         "displayName" : "Unique key val counter",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.util.HashMap<K, V>, java.lang.Integer>"
            }
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "of unique values of a key within a window.<br>\n Emits {@link InternalCountOutput} which contains the key, count of its unique values\n and also the set of values.<br>\n When the operator is partitioned, the unifier uses the internal set of values to\n compute the count of unique values again.<br>\n <br>\n Partitions: yes, uses {@link UniqueCountUnifier} to merge partitioned output.<br>\n Stateful: no<br>\n <br></br>",
         "shortDesc" : "Counts no",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.UniqueValueCount","category" : "algo",
         "displayName" : "Unique value count",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.algo.UniqueValueCount$UniqueCountUnifier",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "tupleType" : "com.datatorrent.lib.algo.UniqueValueCount.com.datatorrent.lib.algo.UniqueValueCount$InternalCountOutput<K>"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : "It uses sticky key partition and default unifier<br>\n <br>\n <b>StateFull : Yes, </b> Tuple are aggregated across application window(s). <br>\n <b>Partitions : Yes, </b> Unique key/value are unified at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V&gt;<br>\n <b>count</b>: emits KeyValPair&lt;K,Integer&gt;<br>\n <br>",
         "shortDesc" : "Count unique occurrences of vals for every key within a window, and emits Key,Integer pairs tuple.<p>\n This is an end of window operator",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, ?>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.UniqueValueKeyVal","category" : "algo",
         "displayName" : "Unique value key val",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "It uses sticky key partition and default unifier<br>\n <br>\n <b>StateFull : Yes, </b> Tuple are aggregated across application window(s). <br>\n <b>Partitions : Yes, </b> Top values are unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V&gt;<br>\n <b>count</b>: emits HashMap&lt;K,Integer&gt;<br>\n <br>",
         "shortDesc" : "Count unique occurrences of vals for every key within a window, and emits Key,Integer pairs tuple.<p>\n This is an end of window operator",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, ?>"
            }
         ],
         "name" : "com.datatorrent.lib.algo.UniqueValueMap","category" : "algo",
         "displayName" : "Unique value map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : " X will be based on the timestamp derived from the window id",
         "shortDesc" : "This is the chart operator that plots the average (mean) value of Y for each window",
         "inputPorts" : [
            {
               "name" : "in1",
               "optional" : false,
               "description" : "The input port of the chart operator.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.chart.TimeSeriesAverageChartOperator","category" : "chart",
         "displayName" : "Time series average chart operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "chart",
               "optional" : true,
               "description" : "The output port of the chart operator.  The data of this will be shipped to the module that draws the chart.",
               "tupleType" : "java.util.Map<K, java.util.Map<X, Y>>"
            }
         ],
         "properties" : [
            {
               "name" : "chartType",
               "type" : "com.datatorrent.lib.chart.ChartOperator$Type",
               "canSet" : false,
               "description" : "The chart type",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "xAxisLabel",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "yAxisLabel",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "yNumberType",
               "type" : "com.datatorrent.lib.chart.XYChartOperator$NumberType",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : " X will be based on the timestamp derived from the window id",
         "shortDesc" : "This is the chart operator that plots the candle stick of Y for each window",
         "inputPorts" : [
            {
               "name" : "in1",
               "optional" : false,
               "description" : "The input port of the chart operator.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.chart.TimeSeriesCandleStickChartOperator","category" : "chart",
         "displayName" : "Time series candle stick chart operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "chart",
               "optional" : true,
               "description" : "The output port of the chart operator.  The data of this will be shipped to the module that draws the chart.",
               "tupleType" : "java.util.Map<K, java.util.Map<X, Y>>"
            }
         ],
         "properties" : [
            {
               "name" : "chartType",
               "type" : "com.datatorrent.lib.chart.ChartOperator$Type",
               "canSet" : false,
               "description" : "The chart type",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "xAxisLabel",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "yAxisLabel",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "yNumberType",
               "type" : "com.datatorrent.lib.chart.XYChartOperator$NumberType",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The apache access log has the following\n format\n\n %s %h %l %u %t \"%r\" %s %b \"%{Referer}\" \"%{User-agent}\"\n\n %s - server name - server0.mydomain.com:80 .......................  server9.mydomain.com:80\n %h - The ip address of the client\n %l - The identity of the client typically \"-\"\n %u - The username of the user if HTTP authentication was used otherwise \"-\"\n %t - The time the request was received e.g., [31/May/2013:08:03:46 -0700]\n %r - The HTTP request string e.g., \"GET /favicon.ico HTTP/1.1\"\n %s - The status code of the response e.g., 404\n %b - The number of bytes in the response\n %{Referer} - The referer web site reported by the client, \"-\" if there is none\n %{User-agent} - Unique string identifying the client browser e.g.,\n \t\t\t\t\t\t\t\"Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.1468.0 Safari/537.36\"\n\n Putting it all together a sample log string looks like :\n --------------------------------------------------------\n 127.0.0.1 - [31/May/2013:09:05:49 -0700] \"GET /favicon.ico HTTP/1.1\" 304 210 \"-\"\n \"Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.22 (KHTML, like Gecko) Ubuntu Chromium/25.0.1364.160 Chrome/25.0.1364.160 Safari/537.22\"",
         "shortDesc" : "Generates apache server log entries",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.ApacheGenRandomLogs","category" : "io",
         "displayName" : "Apache gen random logs",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Users should be careful to not have this\n node listen to a high throughput stream<br>\n <br>",
         "shortDesc" : "Writes tuples to standard out of the container\n <p>\n This is for specific use case for collection where I want to print each key\n value pair in different line <br>\n Mainly to be used for debugging",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "tupleType" : "java.util.Collection<E>"
            }
         ],
         "name" : "com.datatorrent.lib.io.CollectionMultiConsoleOutputOperator","category" : "io",
         "displayName" : "Collection multi console output operator",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "debug",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "silent",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Users should be careful to not have this node listen to a high throughput stream<br>\n <br>",
         "shortDesc" : "Writes tuples to stdout of the container<p>\n <br>\n Mainly to be used for debugging",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.io.ConsoleOutputOperator","category" : "io",
         "displayName" : "Console output operator",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "debug",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "silent",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the silent",
               "canGet" : true
            },
            {
               "name" : "stringFormat",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n <b>delay</b>: Thread sleep interval after emitting line.<br>\n <b>numberOfTuples</b>: Number of tuples to be emitted in a single emit Tuple call.<br>\n <b>ftpServer</b>: The ftp server where the file is hosted.<br>\n <b>port</b>: Port of the ftp server.<br>\n <b>userName</b>: The user name used to login to ftp server. Default is anonymous.<br>\n <b>password</b>: The password used to login to ftp server.<br>\n <b>isGzip</b>: If the format of the file is gzip.<br>",
         "shortDesc" : "This operator emits each line as different tuple for a give file hosted on a ftp server <br>\n\n <b>Ports</b>:<br>\n <b>outport</b>: emits &lt;String&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>filePath</b> : Path for file to be read",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.FtpInputOperator","category" : "io",
         "displayName" : "Ftp input operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            }
         ],
         "properties" : [
            {
               "name" : "delay",
               "type" : "long",
               "canSet" : true,
               "description" : "the delay",
               "canGet" : true
            },
            {
               "name" : "filePath",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the filePath",
               "canGet" : true
            },
            {
               "name" : "ftpServer",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the ftpServer",
               "canGet" : true
            },
            {
               "name" : "gzip",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the isGzip",
               "canGet" : true
            },
            {
               "name" : "localPassiveMode",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the localPassiveMode",
               "canGet" : true
            },
            {
               "name" : "numberOfTuples",
               "type" : "int",
               "canSet" : true,
               "description" : "the numberOfTuples",
               "canGet" : true
            },
            {
               "name" : "password",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the password",
               "canGet" : true
            },
            {
               "name" : "port",
               "type" : "int",
               "canSet" : true,
               "description" : "the port",
               "canGet" : true
            },
            {
               "name" : "userName",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the userName",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "\n If output port is connected, the response is emitted as {@link String} through the output port.",
         "shortDesc" : "Operator to take in map of key value pairs and make a HTTP GET request with the key value pairs from the map\n as query parameters in the request",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.io.HttpGetMapOperator","category" : "io",
         "displayName" : "Http get map operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "url",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : " <br>",
         "shortDesc" : "(entities on stream delimited by leading length)\n Incoming data is interpreted as JSONObject and converted to {@link java.util.Map}.<br>\n If second rawOutput is connected then content is streamed to this port as it is",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.HttpJsonChunksInputOperator","category" : "io",
         "displayName" : "Http json chunks input operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outputPort",
               "optional" : true,
               "description" : "The single output port of this input operator.\n Collects asynchronously emitted tuples and flushes in container thread.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "error" : false,
               "name" : "rawOutput",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            }
         ],
         "properties" : [
            {
               "name" : "active",
               "type" : "boolean",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "url",
               "type" : "java.net.URI",
               "canSet" : true,
               "canGet" : false,
               "properties" : [
                  {
                     "name" : "absolute",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "authority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "fragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "host",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "opaque",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "path",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "port",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "query",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawAuthority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawFragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawPath",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawQuery",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawSchemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawUserInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "scheme",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "schemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "userInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            }
         ]
      },
      {
         "shortDesc" : "Incoming data is interpreted as lines of plain text and each tuple output is a line in the content\n <br>",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.HttpLinesInputOperator","category" : "io",
         "displayName" : "Http lines input operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outputPort",
               "optional" : true,
               "description" : "The single output port of this input operator.\n Collects asynchronously emitted tuples and flushes in container thread.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "error" : false,
               "name" : "rawOutput",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            }
         ],
         "properties" : [
            {
               "name" : "active",
               "type" : "boolean",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "url",
               "type" : "java.net.URI",
               "canSet" : true,
               "canGet" : false,
               "properties" : [
                  {
                     "name" : "absolute",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "authority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "fragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "host",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "opaque",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "path",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "port",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "query",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawAuthority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawFragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawPath",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawQuery",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawSchemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawUserInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "scheme",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "schemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "userInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            }
         ]
      },
      {
         "longDesc" : "All other types are sent in their {@link Object#toString()} representation.<br>\n <br>",
         "shortDesc" : "Sends tuple as POST with JSON content to the given URL<p>\n <br>\n Data of type {@link java.util.Map} is converted to JSON",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.io.HttpOutputOperator","category" : "io",
         "displayName" : "Http output operator",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "resourceURL",
               "type" : "java.net.URI",
               "canSet" : true,
               "canGet" : false,
               "properties" : [
                  {
                     "name" : "absolute",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "authority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "fragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "host",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "opaque",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "path",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "port",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "query",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawAuthority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawFragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawPath",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawQuery",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawSchemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawUserInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "scheme",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "schemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "userInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "url",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "All other types are sent in their {@link Object#toString()} representation.<br>\n <br>",
         "shortDesc" : "Sends tuple as POST with JSON content to the given URL<p>\n <br>\n Data of type {@link java.util.Map} is converted to JSON",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.io.HttpPostOutputOperator","category" : "io",
         "displayName" : "Http post output operator",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "url",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Users should be careful to not have this\n node listen to a high throughput stream<br>\n <br>",
         "shortDesc" : "Writes tuples to standard out of the container\n <p>\n This is for specific use case for map where I want to print each key value\n pair in different line <br>\n Mainly to be used for debugging",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.io.MapMultiConsoleOutputOperator","category" : "io",
         "displayName" : "Map multi console output operator",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "debug",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "silent",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "<p>PubSubWebSocketInputOperator class.</p>",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.PubSubWebSocketInputOperator","category" : "io",
         "displayName" : "Pub sub web socket input operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outputPort",
               "optional" : true,
               "description" : "The single output port of this input operator.\n Collects asynchronously emitted tuples and flushes in container thread.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "properties" : [
            {
               "name" : "active",
               "type" : "boolean",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "ioThreadMultiplier",
               "type" : "int",
               "canSet" : true,
               "description" : "the IO thread multiplier",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "uri",
               "type" : "java.net.URI",
               "canSet" : true,
               "description" : "the URI",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "absolute",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "authority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "fragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "host",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "opaque",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "path",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "port",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "query",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawAuthority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawFragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawPath",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawQuery",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawSchemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawUserInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "scheme",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "schemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "userInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            }
         ]
      },
      {
         "shortDesc" : "<p>PubSubWebSocketOutputOperator class.</p>",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "The input port",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.io.PubSubWebSocketOutputOperator","category" : "io",
         "displayName" : "Pub sub web socket output operator",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "ioThreadMultiplier",
               "type" : "int",
               "canSet" : true,
               "description" : "the IO thread multiplier",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "numRetries",
               "type" : "int",
               "canSet" : true,
               "description" : "the number of retries",
               "canGet" : true
            },
            {
               "name" : "topic",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "uri",
               "type" : "java.net.URI",
               "canSet" : true,
               "description" : "the URI",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "absolute",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "authority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "fragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "host",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "opaque",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "path",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "port",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "query",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawAuthority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawFragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawPath",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawQuery",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawSchemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawUserInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "scheme",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "schemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "userInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "waitMillisRetry",
               "type" : "int",
               "canSet" : true,
               "description" : "wait in milliseconds",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : " <p>\n Handles hand over from asynchronous input to port processing thread (tuples\n must be emitted by container thread). If derived class implements\n {@link Runnable} to perform synchronous IO, this class will manage the thread\n according to the operator lifecycle.",
         "shortDesc" : "A simple Base class for input operator with a single output port without recovery",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.SimpleSinglePortInputOperator","category" : "io",
         "displayName" : "Simple single port input operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outputPort",
               "optional" : true,
               "description" : "The single output port of this input operator.\n Collects asynchronously emitted tuples and flushes in container thread.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "properties" : [
            {
               "name" : "active",
               "type" : "boolean",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "<p>SmtpOutputOperator class.</p>",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.io.SmtpOutputOperator","category" : "io",
         "displayName" : "Smtp output operator",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "content",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "contentType",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "from",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "smtpHost",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "smtpPassword",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "smtpPort",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "smtpUserName",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "subject",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "useSsl",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "Reads via WebSocket from given URL as input stream<p>\n <br>\n Incoming data is interpreted as JSONObject and converted to {@link java.util.Map}.<br>\n <br>",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.WebSocketInputOperator","category" : "io",
         "displayName" : "Web socket input operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outputPort",
               "optional" : true,
               "description" : "The single output port of this input operator.\n Collects asynchronously emitted tuples and flushes in container thread.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "properties" : [
            {
               "name" : "active",
               "type" : "boolean",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "ioThreadMultiplier",
               "type" : "int",
               "canSet" : true,
               "description" : "the IO thread multiplier",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "uri",
               "type" : "java.net.URI",
               "canSet" : true,
               "description" : "the URI",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "absolute",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "authority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "fragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "host",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "opaque",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "path",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "port",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "query",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawAuthority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawFragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawPath",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawQuery",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawSchemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawUserInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "scheme",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "schemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "userInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            }
         ]
      },
      {
         "shortDesc" : "Reads via WebSocket from given URL as input stream<p>\n <br>\n Incoming data is interpreted as JSONObject and converted to {@link java.util.Map}.<br>\n <br>",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "The input port",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.io.WebSocketOutputOperator","category" : "io",
         "displayName" : "Web socket output operator",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "ioThreadMultiplier",
               "type" : "int",
               "canSet" : true,
               "description" : "the IO thread multiplier",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "numRetries",
               "type" : "int",
               "canSet" : true,
               "description" : "the number of retries",
               "canGet" : true
            },
            {
               "name" : "uri",
               "type" : "java.net.URI",
               "canSet" : true,
               "description" : "the URI",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "absolute",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "authority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "fragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "host",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "opaque",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "path",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "port",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "query",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawAuthority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawFragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawPath",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawQuery",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawSchemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawUserInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "scheme",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "schemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "userInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "waitMillisRetry",
               "type" : "int",
               "canSet" : true,
               "description" : "wait in milliseconds",
               "canGet" : true
            }
         ]
      },
      {
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "The input port",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.io.WidgetOutputOperator$1",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "ioThreadMultiplier",
               "type" : "int",
               "canSet" : true,
               "description" : "the IO thread multiplier",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "numRetries",
               "type" : "int",
               "canSet" : true,
               "description" : "the number of retries",
               "canGet" : true
            },
            {
               "name" : "uri",
               "type" : "java.net.URI",
               "canSet" : true,
               "description" : "the URI",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "absolute",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "authority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "fragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "host",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "opaque",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "path",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "port",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "query",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawAuthority",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawFragment",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawPath",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawQuery",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawSchemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawUserInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "scheme",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "schemeSpecificPart",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "userInfo",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "waitMillisRetry",
               "type" : "int",
               "canSet" : true,
               "description" : "wait in milliseconds",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : " Since the operator can be deployed anywhere in the cluster the directory\n to be scanned should be available on all nodes of the cluster.\n Not to be used for HDFS.\n <p>",
         "shortDesc" : "/**\n Input Adapter that scans for files in the specified local directory",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.fs.DirectoryScanInputOperator","category" : "fs",
         "displayName" : "Directory scan input operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "tupleType" : "class com.datatorrent.lib.io.fs.FileInfoRecord"
            }
         ],
         "properties" : [
            {
               "name" : "directoryPath",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "directoryPath the path of directory being scanned.",
               "canGet" : true
            },
            {
               "name" : "fileCountPerEmit",
               "type" : "int",
               "canSet" : true,
               "description" : "fileCountPerEmit the number of file records that are output per emit",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "scanIntervalInMilliSeconds",
               "type" : "int",
               "canSet" : true,
               "description" : "scanIntervalInMilliSeconds the interval at which the directory is being scanned",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : " The Operator creates file <window_id>.tmp during beginwindow and writes the tuples to it.\n It moves the file to <window_id> in the end window.\n If the operator fails and recovers, checks if the file <window_id> exists during begin window. If it does,\n then the operator doesn't process anything during that window. If it doesn't, then the operator deletes\n the <window_id>.tmp file if it exists, creates new and starts writing to it.",
         "shortDesc" : "HDFSOutput Operator that writes the data exactly once",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.io.fs.HdfsExactlyOnceOutputOperator","category" : "fs",
         "displayName" : "Hdfs exactly once output operator",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "append",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "bufferSize",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "filePath",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "replication",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "totalBytesWritten",
               "type" : "long",
               "canSet" : false,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "An adaptor to read from hdfs text file input operator\n Read tuple from the text file in HDFS distributed filesystem\n Read #linesEachWindow lines for each dag window",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.fs.HdfsTextFileInputOperator","category" : "fs",
         "displayName" : "Hdfs text file input operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "HDFSOutput",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            }
         ],
         "properties" : [
            {
               "name" : "filePath",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "linesEachWindow",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "Input operator to read words of specified size from HDFS file\n Reads words of specified size from the file in HDFS\n Reads as many words as possible in each dag window.",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.fs.HdfsWordInputOperator","category" : "fs",
         "displayName" : "Hdfs word input operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "HDFSOutput",
               "optional" : true,
               "tupleType" : "byte[]"
            }
         ],
         "properties" : [
            {
               "name" : "filePath",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "tupleSize",
               "type" : "int",
               "canSet" : true,
               "description" : "the tupleSize",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Each line is emitted on\n output port, Thread waits for sleep interval after emitting line.\n\n <br>\n <b>Ports</b>:<br>\n <b>outport</b>: emits &lt;String&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>filePath</b> : Path for file to be read. <br>\n <b>sleepInterval</b>: Thread sleep interval after emitting line.<br>\n <br>",
         "shortDesc" : "<p>\n This operator opens given file from local file system",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.fs.LocalFsInputOperator","category" : "fs",
         "displayName" : "Local fs input operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            }
         ],
         "properties" : [
            {
               "name" : "filePath",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "sleepInterval",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "If the operator has reached the end of the file, it will wait till more\n data comes\n\n <br>\n <b>Ports</b>:<br>\n <b>outport</b>: emits &lt;String&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>filePath</b> : Path for file to be read. <br>\n <b>delay</b>: Thread sleep interval after emitting line.<br>\n <b>position</b>: The position from where to start reading the file.<br>\n <b>numberOfTuples</b>: number of tuples to be emitted in a single emit Tuple call.<br>\n <b>end</b>: if the user wants to start tailing from end.<br>\n <br>",
         "shortDesc" : "<p>\n This operator implements \"tail -f\" command",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.fs.TailFsInputOperator","category" : "fs",
         "displayName" : "Tail fs input operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            }
         ],
         "properties" : [
            {
               "name" : "delay",
               "type" : "long",
               "canSet" : true,
               "description" : "the delay",
               "canGet" : true
            },
            {
               "name" : "delimiter",
               "type" : "char",
               "canSet" : true,
               "description" : "the delimiter",
               "canGet" : true
            },
            {
               "name" : "end",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the end",
               "canGet" : true
            },
            {
               "name" : "filePath",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the filePath",
               "canGet" : true
            },
            {
               "name" : "numberOfTuples",
               "type" : "int",
               "canSet" : true,
               "description" : "the numberOfTuples",
               "canGet" : true
            },
            {
               "name" : "position",
               "type" : "long",
               "canSet" : true,
               "description" : "the position",
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "<p>ActiveMQStringInputOperator class.</p>",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.io.jms.ActiveMQSinglePortStringInputOperator","category" : "jms",
         "displayName" : "Active m q single port string input operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outputPort",
               "optional" : true,
               "description" : "The single output port.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "properties" : [
            {
               "name" : "ackMode",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the message acknowledgment mode",
               "canGet" : true
            },
            {
               "name" : "batch",
               "type" : "int",
               "canSet" : true,
               "description" : "the batch",
               "canGet" : true
            },
            {
               "name" : "bufferSize",
               "type" : "int",
               "canSet" : true,
               "description" : "the buffer size",
               "canGet" : true
            },
            {
               "name" : "clientId",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the clientId",
               "canGet" : true
            },
            {
               "name" : "connection",
               "type" : "javax.jms.Connection",
               "canSet" : false,
               "description" : "the connection",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "clientID",
                     "type" : "java.lang.String",
                     "canSet" : true,
                     "canGet" : true
                  },
                  {
                     "name" : "exceptionListener",
                     "type" : "javax.jms.ExceptionListener",
                     "canSet" : true,
                     "canGet" : true,
                     "properties" : []
                  },
                  {
                     "name" : "metaData",
                     "type" : "javax.jms.ConnectionMetaData",
                     "canSet" : false,
                     "canGet" : true,
                     "properties" : [
                        {
                           "name" : "JMSMajorVersion",
                           "type" : "int",
                           "canSet" : false,
                           "canGet" : true
                        },
                        {
                           "name" : "JMSMinorVersion",
                           "type" : "int",
                           "canSet" : false,
                           "canGet" : true
                        },
                        {
                           "name" : "JMSProviderName",
                           "type" : "java.lang.String",
                           "canSet" : false,
                           "canGet" : true
                        },
                        {
                           "name" : "JMSVersion",
                           "type" : "java.lang.String",
                           "canSet" : false,
                           "canGet" : true
                        },
                        {
                           "name" : "JMSXPropertyNames",
                           "type" : "java.util.Enumeration",
                           "canSet" : false,
                           "canGet" : true,
                           "properties" : []
                        },
                        {
                           "name" : "providerMajorVersion",
                           "type" : "int",
                           "canSet" : false,
                           "canGet" : true
                        },
                        {
                           "name" : "providerMinorVersion",
                           "type" : "int",
                           "canSet" : false,
                           "canGet" : true
                        },
                        {
                           "name" : "providerVersion",
                           "type" : "java.lang.String",
                           "canSet" : false,
                           "canGet" : true
                        }
                     ]
                  }
               ]
            },
            {
               "name" : "connectionFactoryClass",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "connectionFactoryProperties",
               "type" : "java.util.Map",
               "canSet" : true,
               "description" : "reference to mutable properties",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "empty",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "consumer",
               "type" : "javax.jms.MessageConsumer",
               "canSet" : false,
               "description" : "the message consumer",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "messageListener",
                     "type" : "javax.jms.MessageListener",
                     "canSet" : true,
                     "canGet" : true,
                     "properties" : []
                  },
                  {
                     "name" : "messageSelector",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "consumerName",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the consumer name",
               "canGet" : true
            },
            {
               "name" : "destination",
               "type" : "javax.jms.Destination",
               "canSet" : false,
               "description" : "the destination",
               "canGet" : true,
               "properties" : []
            },
            {
               "name" : "durable",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the durability of the consumer",
               "canGet" : true
            },
            {
               "name" : "maximumReceiveMessages",
               "type" : "long",
               "canSet" : true,
               "description" : "the maximum of received messages",
               "canGet" : true
            },
            {
               "name" : "messageSize",
               "type" : "int",
               "canSet" : true,
               "description" : "the message size",
               "canGet" : true
            },
            {
               "name" : "messagesReceived",
               "type" : "long",
               "canSet" : true,
               "description" : "the count of messages received",
               "canGet" : true
            },
            {
               "name" : "password",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "replyProducer",
               "type" : "javax.jms.MessageProducer",
               "canSet" : false,
               "description" : "the message producer",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "deliveryMode",
                     "type" : "int",
                     "canSet" : true,
                     "canGet" : true
                  },
                  {
                     "name" : "destination",
                     "type" : "javax.jms.Destination",
                     "canSet" : false,
                     "canGet" : true,
                     "properties" : []
                  },
                  {
                     "name" : "disableMessageID",
                     "type" : "boolean",
                     "canSet" : true,
                     "canGet" : true
                  },
                  {
                     "name" : "disableMessageTimestamp",
                     "type" : "boolean",
                     "canSet" : true,
                     "canGet" : true
                  },
                  {
                     "name" : "priority",
                     "type" : "int",
                     "canSet" : true,
                     "canGet" : true
                  },
                  {
                     "name" : "timeToLive",
                     "type" : "long",
                     "canSet" : true,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "session",
               "type" : "javax.jms.Session",
               "canSet" : false,
               "description" : "the session",
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "acknowledgeMode",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "messageListener",
                     "type" : "javax.jms.MessageListener",
                     "canSet" : true,
                     "canGet" : true,
                     "properties" : []
                  },
                  {
                     "name" : "transacted",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "subject",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the name of the destination",
               "canGet" : true
            },
            {
               "name" : "topic",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the topic",
               "canGet" : true
            },
            {
               "name" : "transacted",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the transacted",
               "canGet" : true
            },
            {
               "name" : "tuplesBlast",
               "type" : "int",
               "canSet" : true,
               "description" : "the tuplesBlast",
               "canGet" : true
            },
            {
               "name" : "url",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "user",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "verbose",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "logRegex is used as a parser. The fields extracted are defined as a\n property\n <p>\n This is a pass through operator<br>\n <br>\n <b>StateFull : No </b><br>\n <b>Partitions : Yes</b>, No dependency among input values. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects String<br>\n <b>output</b>: emits Map<br>\n <br>\n <b>Properties</b>:<br>\n <b>logRegex</b>: defines the regex <br>\n <b>groupMap</b>: defines the mapping from the group ids to the names <br>",
         "shortDesc" : "Parse Apache log lines one line at a time",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input log line port.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.ApacheLogParseMapOutputOperator","category" : "logs",
         "displayName" : "Apache log parse map output operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "description" : "Client IP address, output port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : [
            {
               "name" : "logRegex",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the logRegex",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "regexGroups",
               "type" : "[Ljava.lang.String;",
               "canSet" : true,
               "description" : "the groups",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Regex (getAccessLogRegex) is used\n as a parser. The fields extracted include i/p (outputIPAddress), url\n (outputUrl), status code (outputStatusCode), bytes (outputBytes), referer\n (outputReferer), and agent (outputAgent)\n <p>\n This is a pass through operator<br>\n <br>\n <b>StateFull : No </b><br>\n <b>Partitions : Yes</b>, No dependency among input values. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects String<br>\n <b>outputIPAddress</b>: emits String<br>\n <b>outputUrl</b>: emits String<br>\n <b>outputStatusCode</b>: emits String<br>\n <b>outputBytes</b>: emits String<br>\n <b>outputReferer</b>: emits String<br>\n <b>outputAgent</b>: emits String<br>\n <br>\n <b>Properties</b>: none<br>",
         "shortDesc" : "Parse Apache log lines one line at a time",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input log line port.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.ApacheLogParseOperator","category" : "logs",
         "displayName" : "Apache log parse operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outputAgent",
               "optional" : true,
               "description" : "IP Agent, output port.",
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputBytes",
               "optional" : true,
               "description" : "Number of bytes served, output port.",
               "tupleType" : "class java.lang.Long"
            },
            {
               "error" : false,
               "name" : "outputIPAddress",
               "optional" : true,
               "description" : "Client IP address, output port.",
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputReferer",
               "optional" : true,
               "description" : "Referer name, output port.",
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputStatusCode",
               "optional" : true,
               "description" : "Apache status log, output port.",
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputUrl",
               "optional" : true,
               "description" : "Access url port, output port.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : " More output ports in this operator.",
         "shortDesc" : "Please refer to docs for {@link com.datatorrent.lib.logs.ApacheLogParseOperator} documentation",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.ApacheVirtualLogParseOperator","category" : "logs",
         "displayName" : "Apache virtual log parse operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "clientDataUsage",
               "optional" : true,
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "outServerStatus",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.String>"
            },
            {
               "error" : false,
               "name" : "outUrlStatus",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.String>"
            },
            {
               "error" : false,
               "name" : "outputAgent",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputBytes",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "outputIPAddress",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputReferer",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputServerName",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputServerName1",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputStatusCode",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "outputUrl",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "viewCount",
               "optional" : true,
               "tupleType" : "class java.lang.Integer"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "<p>DimensionAggregationUnifier class.</p>",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "tupleType" : "java.util.Map<java.lang.String, com.datatorrent.lib.logs.DimensionObject<java.lang.String>>"
            }
         ],
         "name" : "com.datatorrent.lib.logs.DimensionAggregationUnifier","category" : "logs",
         "displayName" : "Dimension aggregation unifier",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.String, com.datatorrent.lib.logs.DimensionObject<java.lang.String>>"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : "An ArrayList of all tokens that pass the filter are emitted<p>\n This module is a pass through<br>\n <br>\n <b>StateFull : No, </b> tokens are processed in current window. <br>\n <b>Partitions : Yes, </b> No state dependency in output tokens. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Input port, expects String<br>\n <b>tokens</b>: Output port, emits ArrayList<Object><br>\n <br>\n <b>Properties</b>:<br>\n <b>splitby</b>: The characters used to split the line. Default is \";\\t \"<br>\n <b>splittokenby</b>: The characters used to split a token into key,val pair. If not specified the value is set to null. Default is \",\", i.e. tokens are split<br>\n <b>filterby</b>: Only emit the keys (comma separated_that are in filterby<br>\n <br>\n <br>\n <br>",
         "shortDesc" : "Splits String objects into tokens, and emits filtered keys as ArrayList",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.FilteredLineToTokenArrayList","category" : "logs",
         "displayName" : "Filtered line to token array list",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "splittokens",
               "optional" : true,
               "description" : "Output sub tokens port.",
               "tupleType" : "java.util.ArrayList<java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.String>>>"
            },
            {
               "error" : false,
               "name" : "tokens",
               "optional" : true,
               "description" : "Output token port.",
               "tupleType" : "java.util.ArrayList<java.lang.String>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.String;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "splitBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitBy",
               "canGet" : true
            },
            {
               "name" : "splitTokenBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitTokenBy",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "A\n HashMap of all filtered tokens are emitted on output port \"tokens\" . <br>\n <p>\n First token in line is treated as key and rest are put into values array list. <br>\n HashMap of token and array values are emitted on output port.\n This module is a pass through<br>\n <br>\n <b>StateFull : No, </b> tokens are processed in current window. <br>\n <b>Partitions : Yes, </b> No state dependency in output tokens. <br>\n <br>\n Ports:<br>\n <b>data</b>: Input port, expects String<br>\n <b>tokens</b>: Output port, emits HashMap<String, Object><br>\n <br>\n <b>Properties</b>:<br>\n <b>splitby</b>: The characters used to split the line. Default is \";\\t \"<br>\n <b>splittokenby</b>: The characters used to split a token into key,val pair.\n Default is \"\", i.e. tokens are not split, and key is set to token, and val is\n null<br>\n <b>filterby</b>: Only emit the keys (comma separated) that are in filterby<br>\n <br>",
         "shortDesc" : "<p>\n Splits the String tuples into tokens and emits filtered keys as HashMap",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.FilteredLineToTokenHashMap","category" : "logs",
         "displayName" : "Filtered line to token hash map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "tokens",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.String>>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.String;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "splitBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitBy",
               "canGet" : true
            },
            {
               "name" : "splitTokenBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitTokenBy",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Each token is emitted on output port \"tokens\" as key,val pair if the key exists in\n the filterby. This module is a pass through. Ideal for applications like log\n processing where only a few keys are to be processed<br>\n <br>\n <b>StateFull : No, </b> tokens are processed in current window. <br>\n <b>Partitions : Yes, </b> No state dependency in output tokens. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects String<br>\n <b>tokens</b>: emits HashMap&lt;String,String&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>splitby</b>: The characters used to split the line. Default is \";\\t \"<br>\n <b>splittokenby</b>: The characters used to split a token into key,val pair.\n Default is \"\", i.e. tokens are not split, and key is set to token, and val is\n null<br>\n <b>filterby</b>: Only emit the keys (comma separated) that are in filterby\n <br>",
         "shortDesc" : "<p>\n Splits the String tuples into tokens ",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.FilteredLineTokenizerKeyVal","category" : "logs",
         "displayName" : "Filtered line tokenizer key val",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "tokens",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.String>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.String;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "splitBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitBy",
               "canGet" : true
            },
            {
               "name" : "splitTokenBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitTokenBy",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : " An ArrayList of all tkns are emitted on output port \"tokens\".\n An ArrayList of all subtokens are emitted on port splittokens<p>\n This module is a pass through. Ideal for applications like log processing<br>\n <br>\n <b>StateFull : No, </b> tokens are processed in current window. <br>\n <b>Partitions : Yes, </b> output port unifier operator. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects String<br>\n <b>tokens</b>: emits ArrayList&lt;String&gt;<br>\n <b>splittokens</b>: emits ArrayList&lt;HashMap&lt;String,ArrayList&lt;String&gt;&gt;&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>splitby</b>: The characters used to split the line. Default is \";\\t \"<br>\n <b>splittokenby</b>: The characters used to split a token into key,val1,val2,.... If not specified the value is set to null. Default is \"\", i.e. tokens are not split<br>\n\n <br>",
         "shortDesc" : "Splits String objects into tokens, and emits as ArrayList",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.LineToTokenArrayList","category" : "logs",
         "displayName" : "Line to token array list",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "splittokens",
               "optional" : true,
               "description" : "Output sub tokens port.",
               "tupleType" : "java.util.ArrayList<java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.String>>>"
            },
            {
               "error" : false,
               "name" : "tokens",
               "optional" : true,
               "description" : "Output token port.",
               "tupleType" : "java.util.ArrayList<java.lang.String>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "splitBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitBy",
               "canGet" : true
            },
            {
               "name" : "splitTokenBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitTokenBy",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : " First token in line is treated as key and rest are put into values array list. <br>\n HashMap of token and array values are emitted on output port.\n This module is a pass through<br>\n <br>\n <b>StateFull : No, </b> tokens are processed in current window. <br>\n <b>Partitions : Yes, </b> output port unifier operator. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Input port, expects String<br>\n <b>tokens</b>: Output port, emits HashMap&lt;String, ArrayList&lt;String&gt;&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>splitby</b>: The characters used to split the line. Default is \";\\t \"<br>\n <b>splittokenby</b>: The characters used to split a token into key,val1,val2,.... Default is \"\", i.e. tokens are not split, and key=token, val=\"\"<br>\n <br>",
         "shortDesc" : "<p>\n Splits String objects into tokens, and emits as HashMap",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.LineToTokenHashMap","category" : "logs",
         "displayName" : "Line to token hash map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "tokens",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.String>>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "splitBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitBy",
               "canGet" : true
            },
            {
               "name" : "splitTokenBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitTokenBy",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : " This module is a pass through. Ideal for applications like word count, or log\n processing<br>\n <br>\n <b>StateFull : No, </b> tokens are processed in current window. <br>\n <b>Partitions : Yes, </b> No state dependency in output tokens. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects String<br>\n <b>tokens</b>: emits String<br>\n <br>\n <b>Properties</b>:<br>\n <b>splitby</b>: The characters used to split the line. Default is \";\\t \"<br>\n <br>\n <br>",
         "shortDesc" : "<p>\n Splits lines into tokens and emits token Strings on outpu port",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.LineTokenizer","category" : "logs",
         "displayName" : "Line tokenizer",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "tokens",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "splitBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitBy",
               "canGet" : true
            },
            {
               "name" : "splitTokenBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitTokenBy",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Useful to convert String (log lines) into a POJO (HashMap)<p>\n This module is a pass through<br>\n <br>\n <b>StateFull : No, </b> tokens are processed in current window. <br>\n <b>Partitions : Yes, </b>output unifier. <br>\n <br>\n <br>\n Ideal for applications like log processing<br>\n <b>Ports</b>:<br>\n <b>data</b>: expects String<br>\n <b>tokens</b>: emits HashMap&lt;String,String&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>splitby</b>: The characters used to split the line. Default is \";\\t \"<br>\n <b>splittokenby</b>: The characters used to split a token into key,val pair. Default is \"\", i.e. tokens are not split, and key is set to token, and val is null<br>\n <br>",
         "shortDesc" : "Splits lines into tokens, and tokens into sub-tokens and emits key,val pairs in a HashMap",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.LineTokenizerKeyVal","category" : "logs",
         "displayName" : "Line tokenizer key val",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "tokens",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.String>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "splitBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitBy",
               "canGet" : true
            },
            {
               "name" : "splitTokenBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitTokenBy",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : " </p>\n This class aggregates the value of given dimension across windows",
         "shortDesc" : "<p>\n MultiWindowDimensionAggregation class",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<java.lang.String, java.util.Map<java.lang.String, java.lang.Number>>"
            }
         ],
         "name" : "com.datatorrent.lib.logs.MultiWindowDimensionAggregation","category" : "logs",
         "displayName" : "Multi window dimension aggregation",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.String, com.datatorrent.lib.logs.DimensionObject<java.lang.String>>"
            }
         ],
         "properties" : [
            {
               "name" : "dimensionArray",
               "type" : "java.util.List",
               "canSet" : true,
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "empty",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "dimensionKeyVal",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "operationType",
               "type" : "com.datatorrent.lib.logs.MultiWindowDimensionAggregation$AggregateOperation",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "timeBucket",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "windowSize",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The capturing group name is used as the key name. The captured value is used as\n the value.</p>\n\n <p>For example, given the input:\n   <br><code>12345 \"foo bar\" baz;goober</code></p>\n\n <p>And the regular expression:\n   <br><code>(?&lt;id&gt;\\d+) \"(?&lt;username&gt;[^\"]+)\" (?&lt;action&gt;[^;]+);(?&lt;cookie&gt;.+)</code></p>\n\n <p>The operator would emit a Map containing:<br>\n  <table>\n  <tr><th>KEY</th><th>VAL</th></tr>\n  <tr><td>id</td><td>12345</td></tr>\n  <tr><td>username</td><td>foo bar</td></tr>\n  <tr><td>action</td><td>baz</td></tr>\n  <tr><td>cookie</td><td>goober</td></tr>\n  </table>\n\n <p>In the case where the regex does not match the input, nothing is emitted.</p>\n\n <p>Uses the named-regexp library originally from Google, but now maintained\n by Anthony Trinh (https://github.com/tony19/named-regexp).</p>\n\n This is a passthrough operator<br>\n <br>\n <b>StateFull : No </b><br>\n <b>Partitions : Yes</b>, No dependency among input values. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects String<br>\n <b>output</b>: emits Map<br>\n <br>\n <b>Properties</b>:<br>\n <b>regex</b>: defines the regex <br>",
         "shortDesc" : "<p>Use this operator to parse unstructured log data into named fields.</p>\n\n <p>Uses a regex with named capturing groups (http://www.regular-expressions.info/named.html) to extract portions of a string read\n from the input port into a Map<String,String>",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input log line port.",
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.logs.RegexMatchMapOperator","category" : "logs",
         "displayName" : "Regex match map operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "regex",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "the regex",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : " <p>\n This is an end window operator. This can not be partitioned. Partitioning\n this will yield incorrect result.<br>\n <b>Ports</b>:<br>\n <b>data</b>: expects V extends Number<br>\n <b>average</b>: emits V extends Number<br>\n <br>\n <br>\n <b>Properties</b>: None<br>\n <b>Specific compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None<br>\n <p>",
         "shortDesc" : "Emits the average of values at the end of window",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.Average","category" : "math",
         "displayName" : "Average",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "average",
               "optional" : true,
               "description" : "Output port",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "average",
               "type" : "java.lang.Number",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : " <br>User can block or only enable certain keys by setting filter-keys/inverse operator properties.\n <br> Block Key : inverse=true\n <br> Enable Key : inverse=false\n <p>\n This is an end window operator. This can not be partitioned. Partitioning\n this will yield incorrect result.<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>averagePort(s)</b>: emits KeyValPair&lt;K,V extends Number&gt;</b><br>\n <br>Output ports are optional.\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple (default : true).<br>\n <b>filterBy</b>: List of keys to filter on.<br>\n <br>\n <b>Specific compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None<br>\n <p>",
         "shortDesc" : "Emits the average of values for each key at the end of window",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Data input port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, ? extends java.lang.Number>"
            }
         ],
         "name" : "com.datatorrent.lib.math.AverageKeyVal","category" : "math",
         "displayName" : "Average key val",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "doubleAverage",
               "optional" : true,
               "description" : "Double average output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Double>"
            },
            {
               "error" : false,
               "name" : "intAverage",
               "optional" : true,
               "description" : "Integer average output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "longAverage",
               "optional" : true,
               "description" : "Long average output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Long>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : " <p>\n This is an end window operator. This can not be partitioned. Partitioning\n this will yield incorrect result.<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects HashMap&lt;K,V extends Number&gt;<br>\n <b>average</b>: emits HashMap&lt;K,V extends Number&gt;</b><br>\n <br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>\n <b>Specific compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None<br>\n <p>\n <br>",
         "shortDesc" : "Emits the average value for each key at the end of window",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Data input port.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.AverageMap","category" : "math",
         "displayName" : "Average map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "average",
               "optional" : true,
               "description" : "Average output port.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : " Arriving base value is stored in operator for comparison, old base value is overwritten.\n Data values arriving input port are compared with base value. <br>\n Change in value and percentage change in values are emitted on separate ports.<br>\n This operator can not be partitioned, since copies won't get consecutive operators. <br>\n This is StateFull operator, tuples that arrive on base port are kept in\n cache forever.<br>\n <br>\n <b>Input Ports</b>:<br>\n <b>data</b>: expects V extends Number, Data values<br>\n <b>base</b>: expects V extends Number, Base Value stored for comparison<br>\n\n <b>Output Ports</b>:<br>\n <b>change</b>: emits V extends Number,  Diff from base value<br>\n <b>percent</b>: emits Doubl, percent change in value compared to base value.<br>\n <br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>\n <b>Specific compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None<br>\n <br>\n\n <br>",
         "shortDesc" : "<p>\n Operator expects values arriving on data input port and base value input operator",
         "inputPorts" : [
            {
               "name" : "base",
               "optional" : false,
               "tupleType" : "class java.lang.Number"
            },
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.Change","category" : "math",
         "displayName" : "Change",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "change",
               "optional" : true,
               "description" : "Change in value compared to base value.",
               "tupleType" : "class java.lang.Number"
            },
            {
               "error" : false,
               "name" : "percent",
               "optional" : true,
               "description" : "Percent change in data value compared to base value.",
               "tupleType" : "class java.lang.Double"
            }
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n Operator is StateFull since current value is stored for comparison in next window. <br>\n This operator can not be partitioned, partitioning will result in inconsitent base value\n across replicated copies.\n <br>\n\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>alert</b>: emits KeyValPair&lt;K,KeyValPair&lt;V,Double&gt;&gt;(1)<br>\n <br>\n <b>Properties</b>:<br>\n <b>threshold</b>: The threshold of change between consecutive tuples of the\n same key that triggers an alert tuple<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>\n <b>Specific compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None<br>\n <br>",
         "shortDesc" : "<p>\n Operator compare consecutive input data values and exits value and percent change value\n pair on alert output port, if percent change exceeds certain thresh hold value",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.ChangeAlert","category" : "math",
         "displayName" : "Change alert",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "alert",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<V, java.lang.Double>"
            }
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "percentThreshold",
               "type" : "double",
               "canSet" : true,
               "description" : "threshold value",
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n\n StateFull : Yes, current key/value is stored in operator for comparison in\n next successive windows. <br>\n Partition(s): No, base comparison value will be inconsistent across\n instantiated copies. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>alert</b>: emits KeyValPair&lt;K,KeyValPair&lt;V,Double&gt;&gt;(1)<br>\n <br>\n <b>Properties</b>:<br>\n <b>threshold</b>: The threshold of change between consecutive tuples of the\n same key that triggers an alert tuple<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>",
         "shortDesc" : "<p>\n Operator compare consecutive values arriving at input port mapped by keys,\n this emits key/percent change pair on output alert port if percent change\n exceeds percentage thresh hold set in operator",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port, key/value pair.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.ChangeAlertKeyVal","category" : "math",
         "displayName" : "Change alert key val",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "alert",
               "optional" : true,
               "description" : "Key/Percent Change output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, com.datatorrent.lib.util.KeyValPair<V, java.lang.Double>>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "percentThreshold",
               "type" : "double",
               "canSet" : true,
               "description" : "threshold value",
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "<br> <br>\n\n StateFull : Yes, key/value pair in current window are stored for comparison in next window. <br>\n Partition : No, will yield wrong result, base value won't be consistent across instances. <br>\n\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>alert</b>: emits HashMap&lt;K,HashMap&lt;V,Double&gt;&gt;(1)<br>\n <br>\n <b>Properties</b>:<br>\n <b>threshold</b>: The threshold of change between consecutive tuples of the same key that triggers an alert tuple<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>",
         "shortDesc" : "<p>\n Operator stores key/value pair in hash map across the windows for comparison.<br>\n Operator emits hashmap of key/percent change in value for each key, if percent change\n exceeds preset thresh hold",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.ChangeAlertMap","category" : "math",
         "displayName" : "Change alert map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "alert",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.util.HashMap<V, java.lang.Double>>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "percentThreshold",
               "type" : "double",
               "canSet" : true,
               "description" : "threshold value",
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "It stores kay/value pairs arriving at base\n port in <code>basemap</code> across the windows.</br>\n <br>The key/value pairs that arrive at data port are compared with base value if the key exists in the <code>basemap</code>.</br>\n <br>Change value/percent are emitted on separate ports.</br>\n <p/>\n StateFull : Yes, base map values are stored across windows. <br>\n Partitions : Yes, values on the base port are replicated across all partitions. However the order of tuples on the\n output stream may change.\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>base</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>change</b>: emits KeyValPair&lt;K,V&gt;(1)<br>\n <b>percent</b>: emits KeyValPair&lt;K,Double&gt;(1)<br>\n <br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>",
         "shortDesc" : "<p/>\n <br>Operator takes input from two ports - data and base",
         "inputPorts" : [
            {
               "name" : "base",
               "optional" : false,
               "description" : "Base value port, stored in base map for comparison.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            },
            {
               "name" : "data",
               "optional" : false,
               "description" : "Data tuples input port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.ChangeKeyVal","category" : "math",
         "displayName" : "Change key val",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "change",
               "optional" : true,
               "description" : "Key/Change output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            },
            {
               "error" : false,
               "name" : "percent",
               "optional" : true,
               "description" : "key/percent change pair output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Double>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "Operator stores input arriving base port\n for comparison across the windows. kay/value map arriving are compared with\n base map, on per key base. For all existing keys map of key/change and\n key/percent change values are emitted on separate ports. <br>\n <p/>\n <br>\n StateFull : Yes, base values are stored across windows for comparison. <br>\n Partitions : Yes, values on the base port are replicated across all partitions. The order of tuples from output port may\n change.\n <br>\n <p/>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>base</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>change</b>: emits HashMap&lt;K,V&gt;(1)<br>\n <b>percent</b>: emits HashMap&lt;K,Double&gt;(1)<br>\n <br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>",
         "shortDesc" : "<p/>\n Operator takes input from two ports",
         "inputPorts" : [
            {
               "name" : "base",
               "optional" : false,
               "description" : "Base key/value map input port, for comparison.",
               "tupleType" : "java.util.Map<K, V>"
            },
            {
               "name" : "data",
               "optional" : false,
               "description" : "Data key/value map input port.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.ChangeMap","category" : "math",
         "displayName" : "Change map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "change",
               "optional" : true,
               "description" : "Output port emits map for key/change.",
               "tupleType" : "java.util.HashMap<K, V>"
            },
            {
               "error" : false,
               "name" : "percent",
               "optional" : true,
               "description" : "Output port emits map for key/percent change.",
               "tupleType" : "java.util.HashMap<K, java.lang.Double>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "If the tuple\n passed the test, it is emitted on the output port \"compare\". If the tuple fails it is emitted on port \"except\". The comparison is done by getting double\n value from the Number. Both output ports are optional, but at least one has to be connected<p>\n  * This module is a pass through<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V&gt;<br>\n <b>compare</b>: emits HashMap&lt;K,V&gt;<br>\n <b>except</b>: emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n Compile time checks<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <b>Specific run time checks</b>:<br>\n Does the incoming HashMap have the key<br>\n Is the value of the key a number<br>\n <p>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Benchmark table for CompareExceptMap&lt;K,V extends Number&gt; operator template\">\n <tr><th>In-Bound</th><th>Out-bound</th><th>Comments</th></tr>\n <tr><td><b>5 Million K,V pairs/s</b></td><td>Each tuple is emitted if emitError is set to true</td><td>In-bound rate determines performance as every tuple is emitted.\n Immutable tuples were used in the benchmarking. If you use mutable tuples and have lots of keys, the benchmarks may be lower</td></tr>\n </table><br>\n <p>\n <b>Function Table (K=String, V=Integer); emitError=true; key=a; value=3; cmp=eq)</b>:\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Function table for CompareExceptMap&lt;K,V extends Number&gt; operator template\">\n <tr><th rowspan=2>Tuple Type (api)</th><th>In-bound (process)</th><th colspan=2>Out-bound (emit)</th></tr>\n <tr><th><i>data</i>(HashMap&lt;K,V&gt;)</th><th><i>compare</i>(HashMap&lt;K,V&gt;)</th><th><i>except</i>(HashMap&lt;K,V&gt;)</th></tr>\n <tr><td>Begin Window (beginWindow())</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>\n <tr><td>Data (process())</td><td>{a=2,b=20,c=1000}</td><td></td><td>{a=2,b=20,c=1000}</td></tr>\n <tr><td>Data (process())</td><td>{a=3,b=40,c=2}</td><td>{a=3,b=40,c=2}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=10,b=5}</td><td></td><td>{a=10,b=5}</td></tr>\n <tr><td>Data (process())</td><td>{d=55,b=12}</td><td></td><td>{d=55,b=12}</td></tr>\n <tr><td>Data (process())</td><td>{d=22,a=4}</td><td></td><td>{d=22,a=4}</td></tr>\n <tr><td>Data (process())</td><td>{d=4,a=3,g=5,h=44}</td><td>{d=4,a=3,g=5,h=44}</td><td></td></tr>\n <tr><td>End Window (endWindow())</td><td>N/A</td><td>N/A</td><td>N/A</td></tr>\n </table>\n <br>\n <br>",
         "shortDesc" : "A compare opertion is done based on the property \"key\", \"value\", and \"compare\"",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.CompareExceptMap","category" : "math",
         "displayName" : "Compare except map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "compare",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, V>"
            },
            {
               "error" : false,
               "name" : "expect",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, V>"
            },
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "If the tuple\n passed the test, it is emitted on the output port \"compare\". If the tuple fails it is emitted on port \"except\". The comparison is done parsing a double\n value from the String. Both output ports are optional, but at least one has to be connected<p>\n  * This module is a pass through<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,String&gt;<br>\n <b>compare</b>: emits HashMap&lt;K,String&gt;<br>\n <b>except</b>: emits HashMap&lt;K,String&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <b>Specific run time checks</b>:<br>\n Does the incoming HashMap have the key<br>\n Is the value of the key a number<br>\n <br>",
         "shortDesc" : "A compare metric is done on String tuple based on the property \"key\", \"value\", and \"cmp\" both matching and non matching tuples on emitted on respective ports",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.math.CompareExceptStringMap","category" : "math",
         "displayName" : "Compare except string map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "compare",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            },
            {
               "error" : false,
               "name" : "except",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            },
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "emitError",
               "type" : "boolean",
               "canSet" : true,
               "description" : "emitError",
               "canGet" : true
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "If the tuple\n passed the test, it is emitted on the output port \"compare\". The comparison is done by getting double value from the Number.\n Both output ports are optional, but at least one has to be connected<p>\n This module is a pass through<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>compare</b>: emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n CompareMap string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n <b>Specific run time checks</b>:<br>\n Does the incoming HashMap have the key<br>\n Is the value of the key a number<br>\n <p>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Benchmark table for CompareMap&lt;K,V extends Number&gt; operator template\">\n <tr><th>In-Bound</th><th>Out-bound</th><th>Comments</th></tr>\n <tr><td><b>8 Million K,V pairs/s</b></td><td>Each matched tuple is emitted</td><td>In-bound rate and number of tuples that match determine performance.\n Immutable tuples were used in the benchmarking. If you use mutable tuples and have lots of keys, the benchmarks may be lower</td></tr>\n </table><br>\n <p>\n <b>Function Table (K=String,V=Integer); emitError=true; key=a; value=3; cmp=eq)</b>:\n <table border=\"1\" cellspacing=1 cellpadding=1 summary=\"Function table for CompareMap&lt;K,V extends Number&gt; operator template\">\n <tr><th rowspan=2>Tuple Type (api)</th><th>In-bound (process)</th><th>Out-bound (emit)</th></tr>\n <tr><th><i>data</i>(Map&lt;K,V&gt;)</th><th><i>compare</i>(HashMap&lt;K,V&gt;)</th></tr>\n <tr><td>Begin Window (beginWindow())</td><td>N/A</td><td>N/A</td></tr>\n <tr><td>Data (process())</td><td>{a=2,b=20,c=1000}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{a=3,b=40,c=2}</td><td>{a=3,b=40,c=2}</td></tr>\n <tr><td>Data (process())</td><td>{a=10,b=5}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{d=55,b=12}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{d=22,a=4}</td><td></td></tr>\n <tr><td>Data (process())</td><td>{d=4,a=3,g=5,h=44}</td><td>{d=4,a=3,g=5,h=44}</td></tr>\n <tr><td>End Window (endWindow())</td><td>N/A</td><td>N/A</td></tr>\n </table>\n <br>\n <br>",
         "shortDesc" : "A compare metric is done on tuple subclassed from Number based on the property \"key\", \"value\", and \"cmp\", and matching tuples are emitted",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.CompareMap","category" : "math",
         "displayName" : "Compare map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "compare",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, V>"
            },
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "If the tuple\n passed the test, it is emitted on the output port \"compare\". The comparison is done by parsing double value from the String.<p>\n This module is a pass through<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,String&gt;<br>\n <b>compare</b>: emits HashMap&lt;K,String&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\", \"gte\"<br>\n <br>\n <b>Specific run time checks</b>:<br>\n Does the incoming HashMap have the key<br>\n Is the value of the key a number<br>\n <br>",
         "shortDesc" : "A compare metric is done on String tuples based on the property \"key\", \"value\", and \"cmp\" and all matching tuples are emitted",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.math.CompareStringMap","category" : "math",
         "displayName" : "Compare string map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "compare",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            },
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "emitError",
               "type" : "boolean",
               "canSet" : true,
               "description" : "emitError",
               "canGet" : true
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n Key/Occurrence count value pair is emitted for each input on output port. <br>\n <br>\n StateFull : Yes, key occurrence is aggregated over windows. <br>\n Partitions : Yes, count occurrence unifier at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V&gt;<br>\n <b>count</b>: emits KeyValPair&lt;K,Integer&gt;</b><br>\n <br>",
         "shortDesc" : "<p>\n Operator aggregates occurrence of keys in key/value pair at input port",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port to receive data.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.CountKeyVal","category" : "math",
         "displayName" : "Count key val",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "description" : "Key/occurrence value pair output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>"
            }
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n Emits the count of occurrences of each key at the end of window. <br>\n <br>\n StateFull : Yes, each key occurrence are counted till end windows is seen. <br>\n Partitions : Yes, hash sum unifier on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>count</b>: emits HashMap&lt;K,Integer&gt;<br>\n <br>\n <b>Properties</b>: <br>\n  counts : Key occurrence aggregate map.\n <br>",
         "shortDesc" : "Operator aggregates key/occurrence count in map from key/value map input\n port",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port to receive data.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.CountMap","category" : "math",
         "displayName" : "Count map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            }
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The operator is idempotent as the division is done\n in order, i.e. the first number on denominator port would divide the first number on the numerator port.<p>\n This is a pass through operator<br>\n <br>\n StateFull : No, quotient is calculated in current window.\n Partitions : Yes, since each denominator and numerator are treated indiviually.\n <p>\n <b>Ports</b>:<br>\n <b>numerator</b>: expects Number<br>\n <b>denominator</b>: expects Number<br>\n <b>longQuotient</b>: emits Long<br>\n <b>integerQuotient</b>: emits Integer<br>\n <b>doubleQuotient</b>: emits Double<br>\n <b>floatQuotient</b>: emits Float<br>\n <b>longRemainder</b>: emits Long<br>\n <b>integerRemainder</b>: emits Integer<br>\n <b>doubleRemainder</b>: emits Double<br>\n <b>floatRemainder</b>: emits Float<br>\n <b>errordata</b>: emits String<br>\n <br>",
         "shortDesc" : "A division metric is done on consecutive tuples on ports numerator and denominator",
         "inputPorts" : [
            {
               "name" : "denominator",
               "optional" : false,
               "description" : "Denominator input port.",
               "tupleType" : "class java.lang.Number"
            },
            {
               "name" : "numerator",
               "optional" : false,
               "description" : "Numerator input port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.Division","category" : "math",
         "displayName" : "Division",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "doubleQuotient",
               "optional" : true,
               "tupleType" : "class java.lang.Double"
            },
            {
               "error" : false,
               "name" : "doubleRemainder",
               "optional" : true,
               "tupleType" : "class java.lang.Double"
            },
            {
               "error" : true,
               "name" : "errorData",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            },
            {
               "error" : false,
               "name" : "floatQuotient",
               "optional" : true,
               "tupleType" : "class java.lang.Float"
            },
            {
               "error" : false,
               "name" : "floatRemainder",
               "optional" : true,
               "tupleType" : "class java.lang.Float"
            },
            {
               "error" : false,
               "name" : "integerQuotient",
               "optional" : true,
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "integerRemainder",
               "optional" : true,
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "longQuotient",
               "optional" : true,
               "tupleType" : "class java.lang.Long"
            },
            {
               "error" : false,
               "name" : "longRemainder",
               "optional" : true,
               "tupleType" : "class java.lang.Long"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The\n comparison is done by getting double value from the Number. Both output ports\n are optional, but at least one has to be connected\n <p>\n This module is a pass through<br>\n <br>\n <br>\n StateFull : No, output is emitted in current window. <br>\n Partitions : Yes, No state dependency among input tuples. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>except</b>: emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\",\n \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Compile time checks</b>:<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\",\n \"gte\"<br>\n <br>\n <b>Run time checks</b>:<br>\n Does the incoming HashMap have the key, Is the value of the key a number<br>\n <br>",
         "shortDesc" : "<p>\n A compare metric is done on tuple sub-classed from Number based on the\n property \"key\", \"value\", and \"cmp\", and not matched tuples are emitted",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.ExceptMap","category" : "math",
         "displayName" : "Except map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "except",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, V>"
            },
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The\n comparison is done by parsing double value from the String. Both output ports\n are optional, but at least one has to be connected\n <p>\n This module is a pass through<br>\n <br>\n StateFull : No, output is computed during current window. <br>\n Partitions : Yes, no state dependency among input tuples. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,String&gt;<br>\n <b>except</b>: emits HashMap&lt;K,String&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>cmp</b>: The compare function. Supported values are \"lte\", \"lt\", \"eq\",\n \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n <b>Compile time checks</b>:<br>\n Key must be non empty (has to be set)<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\",\n \"gte\"<br>\n <br>\n <b>Specific run time checks</b>:<br>\n Does the incoming HashMap have the key<br>\n Is the value of the key a number<br>\n <br>",
         "shortDesc" : "A compare metric is done on tuple sub-classed from Number based on the\n property \"key\", \"value\", and \"cmp\", and not matched tuples are emitted",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.Map<K, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.math.ExceptStringMap","category" : "math",
         "displayName" : "Except string map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "except",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            },
            {
               "error" : false,
               "name" : "match",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.String>"
            }
         ],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "emitError",
               "type" : "boolean",
               "canSet" : true,
               "description" : "emitError",
               "canGet" : true
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : " <p>",
         "shortDesc" : "Compare the constant to the incoming tuple emit it on one or more of the\n output ports accordingly",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "Tuple input port.",
               "tupleType" : "java.lang.Comparable<? super T>"
            }
         ],
         "name" : "com.datatorrent.lib.math.LogicalCompareToConstant","category" : "math",
         "displayName" : "Logical compare to constant",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "equalTo",
               "optional" : true,
               "description" : "Equal output port.",
               "tupleType" : "java.lang.Comparable<? super T>"
            },
            {
               "error" : false,
               "name" : "greaterThan",
               "optional" : true,
               "description" : "Greater than output port.",
               "tupleType" : "java.lang.Comparable<? super T>"
            },
            {
               "error" : false,
               "name" : "greaterThanOrEqualTo",
               "optional" : true,
               "tupleType" : "java.lang.Comparable<? super T>"
            },
            {
               "error" : false,
               "name" : "lessThan",
               "optional" : true,
               "description" : "Less Than output port.",
               "tupleType" : "java.lang.Comparable<? super T>"
            },
            {
               "error" : false,
               "name" : "lessThanOrEqualTo",
               "optional" : true,
               "tupleType" : "java.lang.Comparable<? super T>"
            },
            {
               "error" : false,
               "name" : "notEqualTo",
               "optional" : true,
               "description" : "Not Equal output port.",
               "tupleType" : "java.lang.Comparable<? super T>"
            }
         ],
         "properties" : [
            {
               "name" : "constant",
               "type" : "java.lang.Comparable",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n Margin Formula : (1 - numerator/denominator). <br>\n If percent flag is set than margin is emitted as percentage. <br>\n <br>\n StateFull : Yes, numerator and denominator are summed for application\n windows. <br>\n Partitions : No, will yield worng margin result, no unifier on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>numerator</b>: expects V extends Number<br>\n <b>denominator</b>: expects V extends Number<br>\n <b>margin</b>: emits Double<br>\n <br>\n <b>Properties:<b>\n <br>\n <b>percent: </b>  output margin as percentage value.",
         "shortDesc" : "<p>\n Operator sums numerator and denominator value arriving at input ports",
         "inputPorts" : [
            {
               "name" : "denominator",
               "optional" : false,
               "description" : "Denominator input port.",
               "tupleType" : "class java.lang.Number"
            },
            {
               "name" : "numerator",
               "optional" : false,
               "description" : "Numerator input port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.Margin","category" : "math",
         "displayName" : "Margin",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "margin",
               "optional" : true,
               "description" : "Output margin port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "percent",
               "type" : "boolean",
               "canSet" : true,
               "description" : "percent",
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : " <p>\n <br>\n The values are added for each key within the window and for each stream.<br>\n <br>\n <b>Ports</b>:<br>\n <b>numerator</b>: expects KeyValPair&lt;K,V&gt;<br>\n <b>denominator</b>: expects KeyValPair&lt;K,V&gt;<br>\n <b>margin</b>: emits HashMap&lt;K,Double&gt;, one entry per key per window<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>",
         "shortDesc" : "Adds all values for each key in \"numerator\" and \"denominator\", and at the end\n of window emits the margin for each key (1 - numerator/denominator)",
         "inputPorts" : [
            {
               "name" : "denominator",
               "optional" : false,
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            },
            {
               "name" : "numerator",
               "optional" : false,
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.MarginKeyVal","category" : "math",
         "displayName" : "Margin key val",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "margin",
               "optional" : true,
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "percent",
               "type" : "boolean",
               "canSet" : true,
               "description" : "percent",
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "<p>\n <br>The values are added for each key within the window and for each stream.<br>\n <br>\n <b>Ports</b>:<br>\n <b>numerator</b>: expects Map&lt;K,V&gt;<br>\n <b>denominator</b>: expects Map&lt;K,V&gt;<br>\n <b>margin</b>: emits HashMap&lt;K,Double&gt;, one entry per key per window<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>",
         "shortDesc" : "Adds all values for each key in \"numerator\" and \"denominator\", and at the end of window emits the margin for each key\n (1 - numerator/denominator)",
         "inputPorts" : [
            {
               "name" : "denominator",
               "optional" : false,
               "tupleType" : "java.util.Map<K, V>"
            },
            {
               "name" : "numerator",
               "optional" : false,
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.MarginMap","category" : "math",
         "displayName" : "Margin map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "margin",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "percent",
               "type" : "boolean",
               "canSet" : true,
               "description" : "percent",
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "<br>\n <br>\n <b>StateFull :</b> Yes, max value is determined during application window, can be more than 1. <br>\n <b>Partitions : </b>Yes, operator itself is used as unifier at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects V extends Number<br>\n <b>max</b>: emits V extends Number<br>\n <br>",
         "shortDesc" : "<p>\n Emits at end of window maximum of all values sub-classed from Number in the incoming stream",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.Max","category" : "math",
         "displayName" : "Max",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "max",
               "optional" : true,
               "description" : "Max value output port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<p>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>max</b>: emits KeyValPair&lt;K,V extends Number&gt;, one entry per key<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>",
         "shortDesc" : "Emits at end of window maximum of all values sub-classed from Number for each key in KeyValPair",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.MaxKeyVal","category" : "math",
         "displayName" : "Max key val",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "max",
               "optional" : true,
               "description" : "Max value output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "<p>\n Emits tuple in end of window. Partition is round robin<br>\n <br>\n  <b>StateFull : </b>Yes, key/value max is determined over application window, can be > 1. <br>\n  <b>Partitions : </b>Yes, operator is max unifier operator on output port.\n <b>Ports</b>:<br>\n <b>data</b>: expects HashMap&lt;K,V extends Number&gt;<br>\n <b>max</b>: emits HashMap&lt;K,V extends Number&gt;, one entry per key<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>",
         "shortDesc" : "Emits at end of window maximum of all values sub-classed from Number for each key in HashMap",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.MaxMap","category" : "math",
         "displayName" : "Max map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "max",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "<br>\n <br>\n <b>StateFull :</b>Yes, min value is computed over application windows. <br>\n <b>Partitions :</b>Yes, operator is kin unifier operator. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects V extends Number<br>\n <b>min</b>: emits V extends Number<br>\n <br>\n <br>",
         "shortDesc" : "Emits at end of window minimum of all values sub-classed from Number in the incoming stream",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.Min","category" : "math",
         "displayName" : "Min",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "min",
               "optional" : true,
               "description" : "Min output port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<p>\n <br>\n\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>min</b>: emits KeyValPair&lt;K,V extends Number&gt;, one entry per key<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>",
         "shortDesc" : "Emits at end of window minimum of all values sub-classed from Number for each key in KeyValPair",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input key/value port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.MinKeyVal","category" : "math",
         "displayName" : "Min key val",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "min",
               "optional" : true,
               "description" : "Min value output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "<br>\n <br>\n <b>StateFull :</b> Yes, min value is computed over application window. <br>\n <b>Partitions :</b> Yes, min operator is min unifier for output port.\n <b>Ports</b>:<br>\n <b>data</b>: expects HashMap&lt;K,V extends Number&gt;<br>\n <b>min</b>: emits HashMap&lt;K,V extends Number&gt;, one entry per key<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>",
         "shortDesc" : "Emits at end of window minimum of all values sub-classed from Number for each key",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.MinMap","category" : "math",
         "displayName" : "Min map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "min",
               "optional" : true,
               "description" : "Min value output port",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : " Emits the result as Long on port \\\"longProduct\\\", as Integer on port \\\"integerProduct\\\",\n as Double on port \\\"doubleProduct\\\", and as Float on port \\\"floatProduct\\\". This is a pass through operator<p>\n <br>\n <b>StateFull : No </b>, output is computed in current window. <br>\n <b>Partitions : Yes </b>, No state dependency among input tuples. <br>\n <br>\n <b>Ports</b>:<br>\n <b>input</b>: expects Number<br>\n <b>longProduct</b>: emits Long<br>\n <b>integerProduct</b>: emits Integer<br>\n <b>doubleProduct</b>: emits Double<br>\n <b>floatProduct</b>: emits Float<br>\n <br>\n <b>Properties</b>:<br>\n <b>multiplier</b>: Number to multiply input tuple with<br>\n <br>",
         "shortDesc" : "Multiplies input tuple (Number) by the value of property \\\"multiplier\\\"",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "Input number port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.MultiplyByConstant","category" : "math",
         "displayName" : "Multiply by constant",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "doubleProduct",
               "optional" : true,
               "description" : "Double output port.",
               "tupleType" : "class java.lang.Double"
            },
            {
               "error" : false,
               "name" : "floatProduct",
               "optional" : true,
               "description" : "Float output port.",
               "tupleType" : "class java.lang.Float"
            },
            {
               "error" : false,
               "name" : "integerProduct",
               "optional" : true,
               "description" : "Integer output port.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "longProduct",
               "optional" : true,
               "description" : "Long output port.",
               "tupleType" : "class java.lang.Long"
            }
         ],
         "properties" : [
            {
               "name" : "multiplier",
               "type" : "java.lang.Number",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n Application can set multiply by value for quotient. <br>\n <br>\n <b>StateFull : Yes </b>, Values are sumed over application window. <br>\n <b>Partitions : No </b>, will yield wrong results, since values are\n accumulated over application window. <br>\n <br>\n <b>Ports</b>:<br>\n <b>numerator</b>: expects V extends Number<br>\n <b>denominator</b>: expects V extends Number<br>\n <b>quotient</b>: emits Double<br>\n <br>\n <b>Properties : </b> <br>\n <b>mult_by : </b>Multiply by value(default = 1). <br>\n <br>",
         "shortDesc" : "<p>\n Adds all the values on \"numerator\" and \"denominator\" and emits quotient at\n end of window",
         "inputPorts" : [
            {
               "name" : "denominator",
               "optional" : false,
               "description" : "Denominator values port.",
               "tupleType" : "class java.lang.Number"
            },
            {
               "name" : "numerator",
               "optional" : false,
               "description" : "Numerator values port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.Quotient","category" : "math",
         "displayName" : "Quotient",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "quotient",
               "optional" : true,
               "description" : "Quotient output port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "mult_by",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n Application can set multiplication value for quotient(default = 1). <br>\n Operator will calculate quotient of occurrence of key in numerator divided by\n occurrence of key in denominator if countKey flag is true. <br>\n Application can allow or block keys by setting filter key and inverse flag. <br>\n <br>\n <b>StateFull : Yes</b>, numerator/denominator values are summed over\n application window. <br>\n <b>Partitions : No, </b>, will yield wrong results, since values are summed\n over app window. <br>\n <br>\n <b>Ports</b>:<br>\n <b>numerator</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>denominator</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>quotient</b>: emits HashMap&lt;K,Double&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse :</b> if set to true the key in the filter will block tuple<br>\n <b>filterBy :</b> List of keys to filter on<br>\n <b>countkey :</b> Get quotient of occurrence of keys in numerator and\n denominator. <br>\n <b>mult_by :</b> Set multiply by constant value. <br>\n <br>",
         "shortDesc" : "<p>\n Add all the values for each key on \"numerator\" and \"denominator\" and emits\n quotient at end of window for all keys in the denominator",
         "inputPorts" : [
            {
               "name" : "denominator",
               "optional" : false,
               "description" : "Denominator input port.",
               "tupleType" : "java.util.Map<K, V>"
            },
            {
               "name" : "numerator",
               "optional" : false,
               "description" : "Numerator input port.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.QuotientMap","category" : "math",
         "displayName" : "Quotient map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "quotient",
               "optional" : true,
               "description" : "Quotient input port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Double>"
            }
         ],
         "properties" : [
            {
               "name" : "countkey",
               "type" : "boolean",
               "canSet" : true,
               "description" : "countkey",
               "canGet" : true
            },
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "mult_by",
               "type" : "int",
               "canSet" : true,
               "description" : "mult_by",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "<br>\n <b>Partitions : Yes </b>, High/Low values are unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects V extends Number<br>\n <b>range</b>: emits HighLow&lt;V&gt;<br>\n <br>\n <br>",
         "shortDesc" : "<p>\n Emits the range of values at the end of window<br>\n <br>\n <b>StateFull : Yes</b>, values are computed over application time window",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.Range","category" : "math",
         "displayName" : "Range",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "range",
               "optional" : true,
               "description" : "Output range port, with high low unifier operator.",
               "tupleType" : "com.datatorrent.lib.util.HighLow<V>"
            }
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n <br>\n <b>StateFull : Yes</b>, values are computed over application window. <br>\n <b>Partitions : Yes, </b> high/low values are each key is unified at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>range</b>: emits KeyValPair&lt;K,HighLow&lt;V&gt;&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>",
         "shortDesc" : "<p>\n Emits the range for each key at the end of window",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.RangeKeyVal","category" : "math",
         "displayName" : "Range key val",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "range",
               "optional" : true,
               "description" : "Output port to send out the high low range.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, com.datatorrent.lib.util.HighLow<V>>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "<br>\n Application can allow or block keys by setting filter keys and inverse flag. <br>\n <br>\n <b>StateFull : Yes</b>, values are computed over application window. <br>\n <b>Partitions : Yes</b>, values are unified at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>range</b>: emits HashMap&lt;K,HighLow&lt;V&gt;&gt; each key has two entries; .get(0) gives Max, .get(1) gives Min<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>",
         "shortDesc" : "<p>\n Emits the range for each key at the end of window",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input key/value map port.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.RangeMap","category" : "math",
         "displayName" : "Range map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "range",
               "optional" : true,
               "description" : "Output range port.",
               "tupleType" : "java.util.HashMap<K, com.datatorrent.lib.util.HighLow<V>>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "This is an end of window operator<br>\n <br>\n <b>StateFull : Yes</b>, average is computed over application window. <br>\n <b>Partitions : No</b>, will yield wrong results. <br>\n <br>\n <b>Ports</b>:<br>\n <b>input</b>: expects Number<br>\n <b>longAverage</b>: emits Long<br>\n <b>integerAverage</b>: emits Integer<br>\n <b>doubleAverage</b>: emits Double<br>\n <b>floatAverage</b>: emits Float<br>\n <br>",
         "shortDesc" : "Calculate the running average of the input numbers and emit it at the end of\n the window",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "Input number port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.RunningAverage","category" : "math",
         "displayName" : "Running average",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "doubleAverage",
               "optional" : true,
               "description" : "Double average output port.",
               "tupleType" : "class java.lang.Double"
            },
            {
               "error" : false,
               "name" : "floatAverage",
               "optional" : true,
               "description" : "Float average output port.",
               "tupleType" : "class java.lang.Float"
            },
            {
               "error" : false,
               "name" : "integerAverage",
               "optional" : true,
               "description" : "Integer average output port.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "longAverage",
               "optional" : true,
               "description" : "Long average output port.",
               "tupleType" : "class java.lang.Long"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "This is a stateful operator that never\n flushes its state; i.e. the addition would go on forever. The result of each\n addition is emitted on the four ports, namely \\\"doubleResult\\\",\n \\\"floatResult\\\", \\\"integerResult\\\", \\\"longResult\\\". Input tuple object has to\n be an implementation of the interface Collection&lt;T&gt;. Tuples are emitted\n on the output ports only if they are connected. This is done to avoid the\n cost of calling the functions when some ports are not connected.\n <p>\n This is a stateful pass through operator<br>\n <b>Partitions : </b>, no will yield wrong results, no unifier on output port.\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Collection&lt;T extends Number&lt;<br>\n <b>doubleResult</b>: emits Double<br>\n <b>floatResult</b>: emits Float<br>\n <b>integerResult</b>: emits Integer<br>\n <b>longResult</b>: emits Long<br>\n <br>",
         "shortDesc" : "Adds incoming tuple to the state",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "Input port, accepts collection of values of type 'T'.",
               "tupleType" : "java.util.Collection<T>"
            }
         ],
         "name" : "com.datatorrent.lib.math.Sigma","category" : "math",
         "displayName" : "Sigma",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "doubleResult",
               "optional" : true,
               "description" : "Double type output.",
               "tupleType" : "class java.lang.Double"
            },
            {
               "error" : false,
               "name" : "floatResult",
               "optional" : true,
               "description" : "Float type output.",
               "tupleType" : "class java.lang.Float"
            },
            {
               "error" : false,
               "name" : "integerResult",
               "optional" : true,
               "description" : "Integer type output.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "longResult",
               "optional" : true,
               "description" : "Long type output.",
               "tupleType" : "class java.lang.Long"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "This is a pass through operator<p>\n <br>\n <b>Ports</b>:<br>\n <b>input</b>: expects Number<br>\n <b>longResult</b>: emits Long<br>\n <b>integerResult</b>: emits Integer<br>\n <b>doubleResult</b>: emits Double<br>\n <b>floatResult</b>: emits Float<br>\n <br>",
         "shortDesc" : "Emits the result of square of the input tuple (Number).<br>\n Emits the result as Long on port longResult, as Integer on port integerResult,\n as Double on port doubleResult, and as Float on port floatResult",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.SquareCalculus","category" : "math",
         "displayName" : "Square calculus",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "doubleResult",
               "optional" : true,
               "description" : "Double type output.",
               "tupleType" : "class java.lang.Double"
            },
            {
               "error" : false,
               "name" : "floatResult",
               "optional" : true,
               "description" : "Float type output.",
               "tupleType" : "class java.lang.Float"
            },
            {
               "error" : false,
               "name" : "integerResult",
               "optional" : true,
               "description" : "Integer type output.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "longResult",
               "optional" : true,
               "description" : "Long type output.",
               "tupleType" : "class java.lang.Long"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n This is an end of window operator. Application can turn this into accumulated\n sum operator by setting cumulative flag to true. <br>\n <b>StateFull : Yes</b>, sum is computed over application window >= 1. <br>\n <b>Partitions : Yes</b>, sum is unified at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects V extends Number<br>\n <b>sum</b>: emits V extends Number<br>\n <b>sumDouble</b>: emits Double<br>\n <b>sumFloat</b>: emits Float<br>\n <b>sumInteger</b>: emits Integer<br>\n <b>sumLong</b>: emits Long<br>\n <b>sumShort</b>: emits Short<br>\n <br>\n <b>Properties: </b> <br>\n <b>cumulative </b> Sum has to be cumulative. <br>\n <br>",
         "shortDesc" : "<p>\n Emits the sum of values at the end of window",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port to receive data.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.math.Sum","category" : "math",
         "displayName" : "Sum",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "redisport",
               "optional" : true,
               "description" : "Redis server output port.",
               "tupleType" : "java.util.Map<java.lang.Integer, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "sum",
               "optional" : true,
               "description" : "Output sum port.",
               "tupleType" : "class java.lang.Number"
            },
            {
               "error" : false,
               "name" : "sumDouble",
               "optional" : true,
               "description" : "Output double sum port.",
               "tupleType" : "class java.lang.Double"
            },
            {
               "error" : false,
               "name" : "sumFloat",
               "optional" : true,
               "description" : "Output float sum port.",
               "tupleType" : "class java.lang.Float"
            },
            {
               "error" : false,
               "name" : "sumInteger",
               "optional" : true,
               "description" : "Output integer sum port.",
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "sumLong",
               "optional" : true,
               "description" : "Output Long sum port.",
               "tupleType" : "class java.lang.Long"
            },
            {
               "error" : false,
               "name" : "sumShort",
               "optional" : true,
               "description" : "Output short sum port.",
               "tupleType" : "class java.lang.Short"
            }
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "cumulative",
               "type" : "boolean",
               "canSet" : true,
               "description" : "cumulative flag",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : " Application accumulate sum across streaming window by setting cumulative flag\n to true. <br>\n This is an end of window operator<br>\n <br>\n <b>StateFull : Yes</b>, Sum is computed over application window and streaming\n window. <br>\n <b>Partitions : Yes</b>, Sum is unified at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>sum</b>: emits HashMap&lt;K,V&gt;<br>\n <b>count</b>: emits HashMap&lt;K,Integer&gt;</b><br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <b>cumulative</b>: boolean flag, if set the sum is not cleared at the end of\n window, <br>\n hence generating cumulative sum across streaming windows. Default is false.<br>\n <br>",
         "shortDesc" : "<p>\n Emits the sum, and count of values for each key at the end of window",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port to receive data.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.SumCountMap","category" : "math",
         "displayName" : "Sum count map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "sum",
               "optional" : true,
               "description" : "Key/sum map output port.",
               "tupleType" : "java.util.HashMap<K, V>"
            },
            {
               "error" : false,
               "name" : "sumDouble",
               "optional" : true,
               "description" : "key/double sum map output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Double>"
            },
            {
               "error" : false,
               "name" : "sumFloat",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.Float>"
            },
            {
               "error" : false,
               "name" : "sumInteger",
               "optional" : true,
               "description" : "key/integer sum output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "sumLong",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.Long>"
            },
            {
               "error" : false,
               "name" : "sumShort",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.Short>"
            }
         ],
         "properties" : [
            {
               "name" : "cumulative",
               "type" : "boolean",
               "canSet" : true,
               "description" : "cumulative flag",
               "canGet" : true
            },
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "<p> This is an end window operator. Default unifier works as this operator follows sticky partition.<br> <br> <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br> <b>sum</b>: emits KeyValPair&lt;K,V extends Number&gt;<br> <br> <b>Properties</b>:<br> <b>inverse</b>: If set to true the key in the\n filter will block tuple<br> <b>filterBy</b>: List of keys to filter on<br>\n <b>cumulative</b>: boolean flag, if set the sum is not cleared at the end of window, <br>\n hence generating cumulative sum\n across streaming windows. Default is false.<br>\n <br>",
         "shortDesc" : "Emits the sum of values for each key at the end of window",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port to receive data.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.SumKeyVal","category" : "math",
         "displayName" : "Sum key val",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "sum",
               "optional" : true,
               "description" : "Output sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            },
            {
               "error" : false,
               "name" : "sumDouble",
               "optional" : true,
               "description" : "Output double sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Double>"
            },
            {
               "error" : false,
               "name" : "sumFloat",
               "optional" : true,
               "description" : "Output float sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Float>"
            },
            {
               "error" : false,
               "name" : "sumInteger",
               "optional" : true,
               "description" : "Output integer sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "sumLong",
               "optional" : true,
               "description" : "Output long sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Long>"
            },
            {
               "error" : false,
               "name" : "sumShort",
               "optional" : true,
               "description" : "Output short sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Short>"
            }
         ],
         "properties" : [
            {
               "name" : "cumulative",
               "type" : "boolean",
               "canSet" : true,
               "description" : "cumulative flag.",
               "canGet" : true
            },
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : " This is an end of window operator<br>\n <br>\n <b>StateFull : Yes</b>, sum is computed over application window. <br>\n <b>Partitions : Yes</b>, sum is unified at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects Map&lt;K,V extends Number&gt;<br>\n <b>sum</b>: emits HashMap&lt;K,V&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <b>cumulative</b>: boolean flag, if set the sum is not cleared at the end of window, <br>\n hence generating cumulative sum across streaming windows. Default is false.<br>\n <br>",
         "shortDesc" : "<p>\n Emits the sum of values for each key at the end of window",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port to receive data.",
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.math.SumMap","category" : "math",
         "displayName" : "Sum map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "sum",
               "optional" : true,
               "description" : "Sum output port.",
               "tupleType" : "java.util.HashMap<K, V>"
            },
            {
               "error" : false,
               "name" : "sumDouble",
               "optional" : true,
               "description" : "Double sum output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Double>"
            },
            {
               "error" : false,
               "name" : "sumFloat",
               "optional" : true,
               "description" : "Float sum output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Float>"
            },
            {
               "error" : false,
               "name" : "sumInteger",
               "optional" : true,
               "description" : "Integer sum output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "sumLong",
               "optional" : true,
               "description" : "Long sum output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Long>"
            },
            {
               "error" : false,
               "name" : "sumShort",
               "optional" : true,
               "description" : "Short sum output port.",
               "tupleType" : "java.util.HashMap<K, java.lang.Short>"
            }
         ],
         "properties" : [
            {
               "name" : "cumulative",
               "type" : "boolean",
               "canSet" : true,
               "description" : "cumulative flag",
               "canGet" : true
            },
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "shortDesc" : "An implementation of the AbstractXmlKeyValueCartesianProduct operator that takes in the xml document\n as a String input and outputs the cartesian product as Strings.",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.math.XmlKeyValueStringCartesianProduct","category" : "math",
         "displayName" : "Xml key value string cartesian product",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            }
         ],
         "properties" : [
            {
               "name" : "config",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "delim",
               "type" : "java.lang.String",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n This is an end window operator which emits only at Nth window. <br>\n <br>\n <b>StateFull : Yes</b>, computes across multiple windows. <br>\n <b>Partitions : Yes</b>, high/low are unified on output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>range</b>: emits KeyValPair&lt;K,HighLow&lt;V&gt;&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple<br>\n <b>filterBy</b>: List of keys to filter on<br>\n <br>\n <b>Specific compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None<br>\n <b>windowSize i.e. N</b>: Number of streaming windows that define application window.<br>\n <br>",
         "shortDesc" : "A range operator of KeyValPair schema which calculate range across multiple streaming windows",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.multiwindow.MultiWindowRangeKeyVal","category" : "multiwindow",
         "displayName" : "Multi window range key val",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "range",
               "optional" : true,
               "description" : "Output port to send out the high low range.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, com.datatorrent.lib.util.HighLow<V>>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "windowSize",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : " <p>\n This is an end window operator which emits only at Nth window. <br>\n <br>\n <b>StateFull : Yes, </b> sum is computed across streaming windows.  <br>\n <b>Partitions : No, </b> sum is not unified at output port. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects KeyValPair&lt;K,V extends Number&gt;<br>\n <b>sum</b>: emits KeyValPair&lt;K,V&gt;<br>\n <b>count</b>: emits KeyValPair&lt;K,Integer&gt;</b><br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: If set to true the key in the filter will block tuple.<br>\n <b>filterBy</b>: List of keys to filter on.<br>\n <b>windowSize i.e. N</b>: Number of streaming windows that define application\n window.<br>\n <br>",
         "shortDesc" : "A sum operator of KeyValPair schema which accumulates sum across multiple\n streaming windows",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port to receive data.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.multiwindow.MultiWindowSumKeyVal","category" : "multiwindow",
         "displayName" : "Multi window sum key val",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "sum",
               "optional" : true,
               "description" : "Output sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            },
            {
               "error" : false,
               "name" : "sumDouble",
               "optional" : true,
               "description" : "Output double sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Double>"
            },
            {
               "error" : false,
               "name" : "sumFloat",
               "optional" : true,
               "description" : "Output float sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Float>"
            },
            {
               "error" : false,
               "name" : "sumInteger",
               "optional" : true,
               "description" : "Output integer sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "sumLong",
               "optional" : true,
               "description" : "Output long sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Long>"
            },
            {
               "error" : false,
               "name" : "sumShort",
               "optional" : true,
               "description" : "Output short sum port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Short>"
            }
         ],
         "properties" : [
            {
               "name" : "cumulative",
               "type" : "boolean",
               "canSet" : true,
               "description" : "cumulative flag.",
               "canGet" : true
            },
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "windowSize",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "<br>\n <br>\n <b>StateFull : Yes</b>, operator store values  for n-1 th windows. <br>\n <b>Partitions : No</b>, sum is not unified on output ports. <br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: Expects KeyValPair where K is Object and V is Number.<br>\n <b>doubleSMA</b>: Emits simple moving average of N window as Double.<br>\n <b>floatSMA</b>: Emits simple moving average of N window as Float.<br>\n <b>longSMA</b>: Emits simple moving average of N window as Long.<br>\n <b>integerSMA</b>: Emits simple moving average of N window as Integer.<br>\n <br>\n <b>Properties</b>:<br>\n <b>windowSize</b>: Number of windows to keep state on<br>\n <br>",
         "shortDesc" : "Calculate simple moving average (SMA) of last N window",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port for getting incoming data.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.multiwindow.SimpleMovingAverage","category" : "multiwindow",
         "displayName" : "Simple moving average",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "doubleSMA",
               "optional" : true,
               "description" : "Output port to emit simple moving average (SMA) of last N window as Double.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Double>"
            },
            {
               "error" : false,
               "name" : "floatSMA",
               "optional" : true,
               "description" : "Output port to emit simple moving average (SMA) of last N window as Float.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Float>"
            },
            {
               "error" : false,
               "name" : "integerSMA",
               "optional" : true,
               "description" : "Output port to emit simple moving average (SMA) of last N window as\n Integer.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "longSMA",
               "optional" : true,
               "description" : "Output port to emit simple moving average (SMA) of last N window as Long.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Long>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "windowSize",
               "type" : "int",
               "canSet" : true,
               "description" : "windowSize",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "All T within Window W are split into |K| buckets and <br>\n sort the bucket in the order that Tp_Ki < Tq_Ki if (comparator.compare(Tp_Ki, Tq_Ki) < 0 || ((Tp_Ki instance of Comparable) && Tp_Ki.compareTo(Tq_Ki) <0))</p>\n\n <b>Properties</b>:<br>\n <b>T</b> is the tuple object the operator can process <br>\n <b>K</b> is the key object used to categorize the tuples withint the sliding window<br>\n <b>function</b>: is used transform the tuple T to group key K. It's used to split all tuples into |K| group and sorted them in the group<br>\n by default: function is SingleKeyMappingFunction which map all t to null (all tuples are grouped into one group)\n <br><b>comparator</b>: is used to determine the order of the tuple<br>\n by default: comparator is null which means the tuple must be comparable\n <p></p>",
         "shortDesc" : "<p>A sliding window class that sorts all incoming tuples within the window and emit them in the right order</p><br>\n <p>Generally, Given tuples T, keys K, windows W",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.multiwindow.SortedMovingWindow","category" : "multiwindow",
         "displayName" : "Sorted moving window",
         "outputPorts" : [
            {
               "error" : true,
               "name" : "errorOutput",
               "optional" : true,
               "tupleType" : "class java.lang.Object"
            },
            {
               "error" : false,
               "name" : "sortedOutput",
               "optional" : true,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "properties" : [
            {
               "name" : "comparator",
               "type" : "java.util.Comparator",
               "canSet" : true,
               "canGet" : false,
               "properties" : []
            },
            {
               "name" : "function",
               "type" : "com.google.common.base.Function",
               "canSet" : true,
               "canGet" : false,
               "properties" : []
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "windowSize",
               "type" : "int",
               "canSet" : false,
               "description" : "n",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "\n <pre>\n Example\n Suppose we have relations A and B.\n\n A = LOAD 'data1' AS (a1:int,a2:int,a3:int);\n\n DUMP A;\n (1,2,3)\n (4,2,1)\n\n B = LOAD 'data2' AS (b1:int,b2:int);\n\n DUMP B;\n (2,4)\n (8,9)\n (1,3)\n In this example the cross product of relation A and B is computed.\n\n X = CROSS A, B;\n\n DUMP X;\n (1,2,3,2,4)\n (1,2,3,8,9)\n (1,2,3,1,3)\n (4,2,1,2,4)\n (4,2,1,8,9)\n (4,2,1,1,3)\n </pre>\n  <br>\n <b>StateFull : </b> Yes, tuples are collected over application window. <br>\n <b>Partitions : </b> No, will yield wrong result. <br>\n <br>\n This operator is pass thru operator. <br>\n <br>\n <b>Ports : </b> <br>\n <b> inport1 : </b> expects tuple of form Map&lt;String, Object&gt; <br>\n <b> inport2 : </b> expects tuple of form Map&lt;String, Object&gt; <br>\n <b> outport : </b> emits tuple of form Map&lt;String, Object&gt; <br>",
         "shortDesc" : "This class implements Apache Pig Cross operator semantic",
         "inputPorts" : [
            {
               "name" : "inport1",
               "optional" : false,
               "description" : "Input port 1.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            },
            {
               "name" : "inport2",
               "optional" : false,
               "description" : "Input port 2.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.pigquery.PigCrossOperator","category" : "pigquery",
         "displayName" : "Pig cross operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : "\n <pre>\n Example\n\n Suppose we have relation A.\n\n A = LOAD 'data' AS (a1:int,a2:int,a3:int);\n\n DUMP A;\n (8,3,4)\n (1,2,3)\n (4,3,3)\n (4,3,3)\n (1,2,3)\n\n In this example all duplicate tuples are removed.\n\n X = DISTINCT A;\n\n DUMP X;\n (1,2,3)\n (4,3,3)\n (8,3,4)\n\n </pre>\n\n <b>StateFull : </b> Yes, tuples are collected over application window. <br>\n <b>Partitions : </b> Yes, operator is also unifier for output port. <br>\n <br>\n This operator is pass thru operator. <br>\n <br>\n <b>Ports : </b> <br>\n <b> inport : </b> expects tuple of form Map&lt;String, Object&gt; <br>\n <b> outport : </b> emits tuple of form Map&lt;String, Object&gt; <br>",
         "shortDesc" : "Implements pig distinct operator semantic",
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port 1.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.pigquery.PigDistinctOperator","category" : "pigquery",
         "displayName" : "Pig distinct operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : "<br>\n Stream rows passing condition are emitted on output port stream. <br>\n <br>\n <b>StateFull : NO,</b> all row data is processed in current time window. <br>\n <b>Partitions : Yes, </b> No Input dependency among input rows. <br>\n <br>\n <b>Ports</b>:<br>\n <b> inport : </b> Input hash map(row) port, expects\n HashMap&lt;String,Object&gt;<<br>\n <b> outport : </b> Output hash map(row) port, emits\n HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <b> <br>\n <b> condition : </b> Select condition for selecting rows. <br>",
         "shortDesc" : "Class to implement Apache Pig filter statement semantic",
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.pigquery.PigFilterOperator","category" : "pigquery",
         "displayName" : "Pig filter operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : [
            {
               "name" : "condition",
               "type" : "com.datatorrent.lib.streamquery.condition.Condition",
               "canSet" : true,
               "description" : "Condition",
               "canGet" : true,
               "properties" : []
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "<p>PigForeachOperator class.</p>",
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port 1.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.pigquery.PigForeachOperator","category" : "pigquery",
         "displayName" : "Pig foreach operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n This operator does not support Group All semantic. <br>\n <pre>\n B = GROUP A BY age;\n\n DESCRIBE B;\n B: {group: int, A: {name: chararray,age: int,gpa: float}}\n\n ILLUSTRATE B;\n etc ...\n ----------------------------------------------------------------------\n | B     | group: int | A: bag({name: chararray,age: int,gpa: float}) |\n ----------------------------------------------------------------------\n |       | 18         | {(John, 18, 4.0), (Joe, 18, 3.8)}             |\n |       | 20         | {(Bill, 20, 3.9)}                             |\n ----------------------------------------------------------------------\n\n DUMP B;\n (18,{(John,18,4.0F),(Joe,18,3.8F)})\n (19,{(Mary,19,3.8F)})\n (20,{(Bill,20,3.9F)})\n </pre>\n <b>Ports : </b> <br>\n <b> inport : </b> expects tuple Map<String, Object> <br>\n <b>outport : </b> emits Map<Object, List<Map<String, Object>>> <br>\n\n <b>StateFull : </b> Yes, tuples are aggregated over application window. <br>\n <b>Partitions : </b> Yes, map unifier on output port. <br>\n\n <b>Properties : </b> <br>\n <b>groupByCondition : </b> Group condition. <br>\n <br>",
         "shortDesc" : "Class implements Apache Pig Group operator sematic",
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.pigquery.PigGroupOperator","category" : "pigquery",
         "displayName" : "Pig group operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.Map<java.lang.Object, java.util.List<java.util.Map<java.lang.String, java.lang.Object>>>"
            }
         ],
         "properties" : [
            {
               "name" : "groupByCondition",
               "type" : "com.datatorrent.lib.pigquery.condition.PigGroupCondition",
               "canSet" : true,
               "description" : "GroupByCondition",
               "canGet" : true,
               "properties" : []
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "\n <pre>\n Example\n Suppose we have relations A and B.\n\n A = LOAD 'data1' AS (a1:int,a2:int,a3:int);\n\n DUMP A;\n (1,2,3)\n (4,2,1)\n (8,3,4)\n (4,3,3)\n (7,2,5)\n (8,4,3)\n\n B = LOAD 'data2' AS (b1:int,b2:int);\n\n DUMP B;\n (2,4)\n (8,9)\n (1,3)\n (2,7)\n (2,9)\n (4,6)\n (4,9)\n In this example relations A and B are joined by their first fields.\n\n X = JOIN A BY a1, B BY b1;\n\n DUMP X;\n (1,2,3,1,3)\n (4,2,1,4,6)\n (4,3,3,4,6)\n (4,2,1,4,9)\n (4,3,3,4,9)\n (8,3,4,8,9)\n (8,4,3,8,9)\n </pre>\n <br>\n <b>Ports : </b> <br>\n <b>inport1 : </b> expects tuple Map<String, Object>. <br>\n <b>inport2 : </b> expects tuple Map<String, Object>. <br>\n <b>outport : </b> emits joinde tuple Map<String, Object>. <br>\n <br>\n <b> StateFull : </b> Yes, values are aggregated over application window.  <br>\n <b> Partitions : </b> No, will yield worng results. <br>\n Operator is pass thru, output tuples are emitted in current time window.  <br>\n <br>\n <b>Properties : </b> <br>\n <b> joinCondition : </b> Tuple join condition.",
         "shortDesc" : "This class implements Pig Join(Inner) semantic on live stream",
         "inputPorts" : [
            {
               "name" : "inport1",
               "optional" : false,
               "description" : "Input1 port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            },
            {
               "name" : "inport2",
               "optional" : false,
               "description" : "Input2 port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.pigquery.PigJoinOperator","category" : "pigquery",
         "displayName" : "Pig join operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : [
            {
               "name" : "joinCondition",
               "type" : "com.datatorrent.lib.streamquery.condition.Condition",
               "canSet" : true,
               "description" : "Condition",
               "canGet" : true,
               "properties" : []
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "\n <br>\n <b>Ports : </b> <br>\n <b>inport1 : </b> expects tuple Map<String, Object>. <br>\n <b>inport2 : </b> expects tuple Map<String, Object>. <br>\n <b>outport : </b> emits joinde tuple Map<String, Object>. <br>\n <br>\n <b> StateFull : </b> Yes, values are aggregated over application window.  <br>\n <b> Partitions : </b> No, will yield worng results. <br>\n Operator is end window operator, left/right/full values are emitted at end window.  <br>\n <br>\n <b>Properties : </b> <br>\n <b> joinCondition : </b> Tuple join condition.",
         "shortDesc" : "This class implements Pig Join(Outer) semantic on live stream",
         "inputPorts" : [
            {
               "name" : "inport1",
               "optional" : false,
               "description" : "Input1 port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            },
            {
               "name" : "inport2",
               "optional" : false,
               "description" : "Input2 port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.pigquery.PigJoinOuterOperator","category" : "pigquery",
         "displayName" : "Pig join outer operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : [
            {
               "name" : "joinCondition",
               "type" : "com.datatorrent.lib.streamquery.condition.Condition",
               "canSet" : true,
               "description" : "Condition",
               "canGet" : true,
               "properties" : []
            },
            {
               "name" : "joinType",
               "type" : "int",
               "canSet" : true,
               "description" : "int",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "A split into node creates\n multiple streams from a single stream. <br>\n This operator implements following semantic.  <br>\n <pre>\n instream is f1:int, f2:int, f3:int\n\n The expression for split into is \"X IF f1<7, Y IF f2==5, Z IF (f3<6)\"\n\n For instream tuples (1,2,3) would produce (1,2,3) on X, (1,2,3) on Z (4,5,6)\n would produce (4,5,6) on X, (4,5,6) on Y (7,8,9) would produce (7,8,9) on Z\n\n This would match to split into metric for Pig\n </pre>",
         "shortDesc" : "<p>\n Class to implement Pig split operator semantic",
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.pigquery.ThreeWayPigSplit","category" : "pigquery",
         "displayName" : "Three way pig split",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Key\n is name of variable used in script code. Proper map values must be provided\n by UP stream operators.\n\n <b> Sample Usage Code : </b>\n\n <pre>\n // Add random integer generator operator\n SingleKeyValMap rand = dag.addOperator(&quot;rand&quot;, SingleKeyValMap.class);\n\n Script script = dag.addOperator(&quot;script&quot;, Script.class);\n // script.setEval(&quot;val = val*val;&quot;);\n script.addSetupScript(&quot;function square() { return val*val;}&quot;);\n script.setInvoke(&quot;square&quot;);\n dag.addStream(&quot;evalstream&quot;, rand.outport, script.inBindings);\n\n // Connect to output console operator\n ConsoleOutputOperator console = dag.addOperator(&quot;console&quot;,\n \t\tnew ConsoleOutputOperator());\n dag.addStream(&quot;rand_console&quot;, script.result, console.input);\n\n </pre>\n\n <b> Sample Input Operator(emit)</b>\n\n <pre>\n  \t.\n \t\t.\n \t\tpublic void emitTuples() {\n \t\t\tHashMap<String, Object> map = new HashMap<String, Object>();\n \t\t\tmap.put(\"val\", random.nextInt());\n \t\t\toutport.emit(map);\n \t\t\t.\n \t\t\t.\n \t\t}\n \t\t.\n \t\t.\n </pre>\n\n This operator does not checkpoint interpreted functions in the variable bindings because they are not serializable\n Use setupScript() to define functions, and do NOT define or assign functions to variables at run time",
         "shortDesc" : "This operator executes JavaScript on tuples in for Map<String, Object>",
         "inputPorts" : [
            {
               "name" : "inBindings",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.script.JavaScriptOperator","category" : "script",
         "displayName" : "Java script operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outBindings",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            },
            {
               "error" : false,
               "name" : "result",
               "optional" : true,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "properties" : [
            {
               "name" : "bindings",
               "type" : "java.util.Map",
               "canSet" : false,
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "empty",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "engineByName",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "eval",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "invoke",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "passThru",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "script",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "shortDesc" : "Operator to execute ruby script on tuples",
         "inputPorts" : [
            {
               "name" : "inBindings",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.script.RubyOperator","category" : "script",
         "displayName" : "Ruby operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outBindings",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            },
            {
               "error" : false,
               "name" : "result",
               "optional" : true,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "properties" : [
            {
               "name" : "bindings",
               "type" : "java.util.Map",
               "canSet" : false,
               "canGet" : true,
               "properties" : [
                  {
                     "name" : "empty",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "eval",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "invoke",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "passThru",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "script",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "shortDesc" : "<p>DimensionsComputation class.</p>",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.statistics.DimensionsComputation","category" : "statistics",
         "displayName" : "Dimensions computation",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "tupleType" : "interface com.datatorrent.lib.statistics.DimensionsComputation$AggregateEvent"
            }
         ],
         "properties" : [
            {
               "name" : "aggregators",
               "type" : "[Lcom.datatorrent.lib.statistics.DimensionsComputation$Aggregator;",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "unifier",
               "type" : "com.datatorrent.api.Operator$Unifier",
               "canSet" : true,
               "canGet" : false,
               "properties" : []
            }
         ]
      },
      {
         "shortDesc" : "A {@link Unifier} implementation for {@link DimensionsComputation}.<br/>",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.statistics.DimensionsComputationUnifierImpl","category" : "statistics",
         "displayName" : "Dimensions computation unifier impl",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "tupleType" : "interface com.datatorrent.lib.statistics.DimensionsComputation$AggregateEvent"
            }
         ],
         "properties" : [
            {
               "name" : "aggregators",
               "type" : "[Lcom.datatorrent.lib.statistics.DimensionsComputation$Aggregator;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n <br>\n <b>Input Port(s) : </b><br>\n <b>data : </b> Data values input port. <br>\n <br>\n <b>Output Port(s) : </b> <br>\n <b>median : </b>Median output port. <br>\n <br>\n <b>StateFull : Yes</b>, value are aggregated over application window. <br>\n <b>Partitions : No</b>, no will yield wrong results. <br>\n <br>+",
         "shortDesc" : "This operator computes median of incoming data",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.statistics.MedianOperator","category" : "statistics",
         "displayName" : "Median operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "median",
               "optional" : true,
               "description" : "Output port",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n <br>\n <b>Input Port(s) : </b><br>\n <b>data : </b> Data values input port. <br>\n <br>\n <b>Output Port(s) : </b> <br>\n <b>mode : </b>Mode value output port. <br>\n <br>\n <b>StateFull : Yes</b>, value are aggregated over application window. <br>\n <b>Partitions : No</b>, no will yeild wrong results. <br>\n <br>",
         "shortDesc" : "This operator computes weighted mean of incoming data",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port.",
               "tupleType" : "java.lang.Comparable<?>"
            }
         ],
         "name" : "com.datatorrent.lib.statistics.ModeOperator","category" : "statistics",
         "displayName" : "Mode operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mean",
               "optional" : true,
               "description" : "Output port",
               "tupleType" : "java.lang.Comparable<?>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n <br>\n <b>Input Port(s) : </b><br>\n <b>data : </b> Data values input port. <br>\n <br>\n <b>Output Port(s) : </b> <br>\n <b>variance : </b>Variance value output port. <br>\n <b>standardDeviatin : </b>Variance value output port. <br>\n <br>\n <b>StateFull : Yes</b>, value are aggregated over application window. <br>\n <b>Partitions : No</b>, no will yield wrong results. <br>\n <br>",
         "shortDesc" : "This operator computes variance and standard deviation over incoming data",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.statistics.StandardDeviation","category" : "statistics",
         "displayName" : "Standard deviation",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "standardDeviation",
               "optional" : true,
               "description" : "Standard deviation output port",
               "tupleType" : "class java.lang.Number"
            },
            {
               "error" : false,
               "name" : "variance",
               "optional" : true,
               "description" : "Variance output port",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n <br>\n <b>Input Port(s) : </b><br>\n <b>data : </b> Data values input port. <br>\n <b>weight : </b> Current input data weight. <br>\n <br>\n <b>Output Port(s) : </b> <br>\n <b>mean : </b>Weighted mean output port. <br>\n <br>\n <b>StateFull : Yes</b>, value are aggregated over application window. <br>\n <b>Partitions : No</b>, no will yeild wrong results. <br>\n <br>",
         "shortDesc" : "This operator computes weighted mean of incoming data",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input data port.",
               "tupleType" : "class java.lang.Number"
            },
            {
               "name" : "weight",
               "optional" : false,
               "description" : "Input weight port.",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.statistics.WeightedMeanOperator","category" : "statistics",
         "displayName" : "Weighted mean operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mean",
               "optional" : true,
               "description" : "Output port",
               "tupleType" : "class java.lang.Number"
            }
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "average",
               "type" : "java.lang.Number",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The size of the ArrayList before it is emitted is determined by property \\\"size\\\". If size == 0\n then the ArrayList (if not empty) is emitted in the endWindow call. Is size is specified then the ArrayList is emitted as soon as the size is\n reached as part of process(tuple), and no emit happens in endWindow. For size != 0, the operator is statefull.<p>\n <br>\n <b>Port</b>:<br>\n <b>input</b>: expects T<br>\n <b>output</b>: emits ArrayList&lt;T&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>size</b>: The size of ArrayList. If specified the ArrayList is emitted the moment it reaches this size.\n               If 0, the ArrayList is emitted in endWindow call. Default value is 0, </br>\n <br>",
         "shortDesc" : "Creates a ArrayList tuple from incoming tuples",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.stream.ArrayListAggregator","category" : "stream",
         "displayName" : "Array list aggregator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "description" : "Collection output port.",
               "tupleType" : "java.util.Collection<T>"
            }
         ],
         "properties" : [
            {
               "name" : "size",
               "type" : "int",
               "canSet" : true,
               "description" : "size of collection",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n It is a pass through operator<br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects ArrayList&lt;K&gt;br> <b>item</b>: emits K<br>",
         "shortDesc" : "<p>\n Takes in an ArrayList and emits each item in the array; mainly used for\n breaking up a ArrayList tuple into Objects",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input array list port.",
               "tupleType" : "java.util.ArrayList<K>"
            }
         ],
         "name" : "com.datatorrent.lib.stream.ArrayListToItem","category" : "stream",
         "displayName" : "Array list to item",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "item",
               "optional" : true,
               "description" : "Output array item port.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n Operator emits key/array list map at end window, this end window operator. <br>\n <br>\n <b>StateFull : Yes</b>, values are collected over application window. <br>\n <b>Partitions : No</b>, will collect wrong results. <br>\n <br>\n <b>Ports : </b><br>\n <b>Input(s) : </b> 5 max input ports, 3 are optional. <br>\n <br>",
         "shortDesc" : "<p>\n Operator aggregates key/value input from 5 ports of different types into\n key/array list map, for each key",
         "inputPorts" : [
            {
               "name" : "in1",
               "optional" : false,
               "description" : "V1 type value input port.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "name" : "in2",
               "optional" : false,
               "description" : "V2 type value input port.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "name" : "in3",
               "optional" : true,
               "description" : "V3 type value input port.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "name" : "in4",
               "optional" : true,
               "description" : "V4 type value input port.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "name" : "in5",
               "optional" : true,
               "description" : "V5 type value input port.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.stream.ConsolidatorKeyVal","category" : "stream",
         "displayName" : "Consolidator key val",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "out",
               "optional" : true,
               "description" : "Key/array values map output port.",
               "tupleType" : "java.util.HashMap<K, java.util.ArrayList<java.lang.Object>>"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : " <p>\n This is a pass through operator<br>\n <br>\n <b>StateFull : Yes</b>, tuples are counted over application window. <br>\n <b>Partitions : Yes</b>, count is unified at output port. <br>\n <b>Ports</b>:<br>\n <b>input</b>: expects Object<br>\n <b>output</b>: emits Integer<br>\n <br>",
         "shortDesc" : "Counter counts the number of tuples delivered to it in each window and emits\n the count",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.stream.Counter","category" : "stream",
         "displayName" : "Counter",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "output",
               "optional" : true,
               "tupleType" : "class java.lang.Integer"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : "Useful if you want to have a\n stream for monitoring purpose etc. In future STRAM may simply support a\n virtual stream and make this operator redundant<br>\n <br>\n <b>Port</b>:<br>\n <b>data</b>: expects K<br>\n <br>",
         "shortDesc" : "Terminates a stream; does nothing to the tuple",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input any data type port.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.stream.DevNull","category" : "stream",
         "displayName" : "Dev null",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Increments a count\n and writes the net number (rate) to console. Useful to benchmark other\n modules.<br>\n This operator is neither pass through nor windowed as far as data tuples are\n concerned. The logging is done during end of window call.<br>\n <br>\n <b>Port</b>:<br>\n <b>data</b>: expects K<br>\n <br>\n <b>Properties</b>: rollingwindowcount: Number of windows to average over.\n Results are written to the log<br>\n <br>",
         "shortDesc" : "<p>\n Counts and then drops the tuple; mainly used for logging",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.stream.DevNullCounter","category" : "stream",
         "displayName" : "Dev null counter",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "debug",
               "type" : "boolean",
               "canSet" : true,
               "description" : "debug state",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "rollingwindowcount",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "shortDesc" : "Takes a HashMap and emits its keys, keyvals, vals; used for breaking up a\n HashMap tuple into objects (keys, vals, or key/val pairs)\n <p>\n This is a pass through operator<br>\n <br>\n <b>StateFull : No</b> <br>\n <b>Partitions : Yes </b><br>\n <br>\n <b>Ports</b>:<br>\n <b>data</b>: expects HashMap&lt;K,V&gt;<br>\n <b>key</b>: emits K<br>\n <b>keyval</b>: emits Entry&lt;K,V&gt;<br>\n <b>val</b>: emits V<br>\n <br>",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input key/vale map port.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.stream.HashMapToKeyValPair","category" : "stream",
         "displayName" : "Hash map to key val pair",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "key",
               "optional" : true,
               "description" : "Key output port.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "error" : false,
               "name" : "keyval",
               "optional" : true,
               "description" : "key/value pair output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            },
            {
               "error" : false,
               "name" : "val",
               "optional" : true,
               "description" : "Value output port.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "Takes a json byte stream and emits a HashMap of key values\n <p>\n This is a pass through operator<br>\n <br>\n <b>Ports</b>:<br>\n <b>input</b>: expects json byte array &lt;K,V&gt;<br>\n <b>outputMap</b>: emits HashMap&lt;String,Object&gt;<br>\n <b>outputJsonObject</b>: emits JSONObject<br>\n <b>outputFlatMap</b>: emits HashMap&lt;String,Object&gt;<br>\n &nbsp&nbsp The key will be dot concatenated nested key names <br>\n &nbsp&nbsp eg: key: \"agentinfo.os.name\", value: \"Ubuntu\" <br>\n <br>",
         "inputPorts" : [
            {
               "name" : "input",
               "optional" : false,
               "description" : "Input byte array port.",
               "tupleType" : "byte[]"
            }
         ],
         "name" : "com.datatorrent.lib.stream.JsonByteArrayOperator","category" : "stream",
         "displayName" : "Json byte array operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "flatmap",
               "optional" : true,
               "description" : "Output hash map port.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Object>"
            },
            {
               "error" : false,
               "name" : "jsonobject",
               "optional" : true,
               "description" : "Output JSONObject port.",
               "tupleType" : "class org.codehaus.jettison.json.JSONObject"
            },
            {
               "error" : false,
               "name" : "map",
               "optional" : true,
               "description" : "Output hash map port.",
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : [
            {
               "name" : "concatenationCharacter",
               "type" : "char",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "Takes a KeyValPair and emits a HashMap(1), Used for for converting KeyValPair\n to a HashMap(1) tuple\n <p>\n This is a pass through operator<br>\n <br>\n <b>Ports</b>:<br>\n <b>keyval</b>: expects KeyValPair&lt;K,V&gt;<br>\n <b>map</b>: emits HashMap&lt;K,V&gt;<br>\n <br>",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "key/value input port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.stream.KeyValPairToHashMap","category" : "stream",
         "displayName" : "Key val pair to hash map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "map",
               "optional" : true,
               "description" : "key/value map output port.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "If keys[] are set, then each\n incoming tuple is the value of the key (in-order) till all keys get a value.\n Once all keys are assigned values, the tuple (HashMap) is emitted, the\n process of assigning values starts again<br>\n This is a stateful operator as it waits across window boundary to complete\n the HashTable<br>\n <br>\n <b> StateFull : Yes, </b>Operator maintains index of key across windows. <br>\n <b> Partitions : Yes </b> <br>\n <br>\n <b>Port</b>:<br>\n <b>data</b>: expects V<br>\n <b>map</b>: emits HashMap&lt;K,v&gt;<br>\n <br>\n <b>Properties</b>:<br>\n <b>keys[]</b>: Set of keys to insert in the output tuple</b>",
         "shortDesc" : "<p>\n Creates a HashMap tuple from incoming tuples",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Value input port.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.stream.RoundRobinHashMap","category" : "stream",
         "displayName" : "Round robin hash map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "map",
               "optional" : true,
               "description" : "key/value map output port.",
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "keys",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "Duplicates an input stream as is into two output streams; needed to allow separation of listeners into two streams with different properties (for example\n inline vs in-rack)<p>\n This is a pass through operator<br>\n <br>\n <b>Port Interface</b><br>\n <b>data</b>: expects &lt;K&gt;<br>\n <b>out1</b>: emits &lt;K&gt;<br>\n <b>out2</b>: emits &lt;K&gt;<br>\n <br>",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.stream.StreamDuplicater","category" : "stream",
         "displayName" : "Stream duplicater",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "out1",
               "optional" : true,
               "description" : "Output port 1.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "error" : false,
               "name" : "out2",
               "optional" : true,
               "description" : "Output port 2.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "Merges two streams with identical schema and emits the tuples to the output port in order<p>\n This is a pass through operator<br>\n <b>Ports</b>:<br>\n <b>data1</b>: expects K<br>\n <b>data2</b>: expects K<br>\n <b>out</b>: emits K<br>\n <br>",
         "inputPorts" : [
            {
               "name" : "data1",
               "optional" : false,
               "description" : "Data port 1.",
               "tupleType" : "class java.lang.Object"
            },
            {
               "name" : "data2",
               "optional" : false,
               "description" : "Data port 2.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.stream.StreamMerger","category" : "stream",
         "displayName" : "Stream merger",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "out",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "class java.lang.Object"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n Stream rows passing condition are emitted on output port stream. <br>\n <br>\n <b>StateFull : NO,</b> all row data is processed in current time window. <br>\n <b>Partitions : Yes, </b> No Input dependency among input rows. <br>\n <br>\n <b>Ports</b>:<br>\n <b> inport : </b> Input hash map(row) port, expects\n HashMap&lt;String,Object&gt;<<br>\n <b> outport : </b> Output hash map(row) port, emits\n HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <b> <br>\n <b> condition : </b> Select condition for selecting rows. <br>\n <b> columns : </b> Column names/aggregate functions for select. <br>\n <br>",
         "shortDesc" : "This operator provides sql select query semantic on live data stream",
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.DeleteOperator","category" : "streamquery",
         "displayName" : "Delete operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : [
            {
               "name" : "condition",
               "type" : "com.datatorrent.lib.streamquery.condition.Condition",
               "canSet" : true,
               "canGet" : false,
               "properties" : []
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "Embedded derby sql input operator.",
         "inputPorts" : [
            {
               "name" : "bindings",
               "optional" : true,
               "tupleType" : "java.util.ArrayList<java.lang.Object>"
            },
            {
               "name" : "in1",
               "optional" : false,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Object>"
            },
            {
               "name" : "in2",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Object>"
            },
            {
               "name" : "in3",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Object>"
            },
            {
               "name" : "in4",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Object>"
            },
            {
               "name" : "in5",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.DerbySqlStreamOperator","category" : "streamquery",
         "displayName" : "Derby sql stream operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "result",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "statement",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n Stream rows satisfying given select condition are processed by group by\n column names and aggregate column function. <br>\n If having condition is specified for aggregate index(s), it must also be\n satisfied by row. HashMap of column name(s) and aggregate alias is emitted on\n output port. <br>\n <br>\n <b>StateFull : Yes,</b> Operator aggregates input over application window. <br>\n <b>Partitions : No, </b> will yield wrong result(s). <br>\n <br>\n <b>Ports</b>:<br>\n <b> inport : </b> Input hash map(row) port, expects\n HashMap&lt;String,Object&gt;<<br>\n <b> outport : </b> Output hash map(row) port, emits\n HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <b> <br>\n <b> condition : </b> Select condition for deleting rows. <br>\n <b> columnGroupIndexes : </b> Group by names list. <br>\n <b> indexes : </b> Select column indexes. <br>\n <b> havingConditions : </b> Having filter conditions for aggregate(s). <br>\n <br>",
         "shortDesc" : "This operator provides sql group by query semantic on live data stream",
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.GroupByHavingOperator","category" : "streamquery",
         "displayName" : "Group by having operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : [
            {
               "name" : "condition",
               "type" : "com.datatorrent.lib.streamquery.condition.Condition",
               "canSet" : true,
               "canGet" : false,
               "properties" : []
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n Operator joins row on given condition and selected names, emits\n joined result at output port.\n  <br>\n  <b>StateFull : Yes,</b> Operator aggregates input over application window. <br>\n  <b>Partitions : No, </b> will yield wrong result(s). <br>\n  <br>\n  <b>Ports : </b> <br>\n  <b> inport1 : </b> Input port for table 1, expects HashMap&lt;String, Object&gt; <br>\n  <b> inport1 : </b> Input port for table 2, expects HashMap&lt;String, Object&gt; <br>\n  <b> outport : </b> Output joined row port, emits HashMap&lt;String, ArrayList&lt;Object&gt;&gt; <br>\n  <br>\n  <b> Properties : </b>\n  <b> joinCondition : </b> Join condition for table rows. <br>\n  <b> table1Columns : </b> Columns to be selected from table1. <br>\n  <b> table2Columns : </b> Columns to be selected from table2. <br>\n  <br>",
         "shortDesc" : "This operator reads table row data from 2 table data input ports",
         "inputPorts" : [
            {
               "name" : "inport1",
               "optional" : false,
               "description" : "Input port 1.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            },
            {
               "name" : "inport2",
               "optional" : false,
               "description" : "Input port 2.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.InnerJoinOperator","category" : "streamquery",
         "displayName" : "Inner join operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : [
            {
               "name" : "joinCondition",
               "type" : "com.datatorrent.lib.streamquery.condition.Condition",
               "canSet" : true,
               "description" : "the joinCondition",
               "canGet" : true,
               "properties" : []
            }
         ]
      },
      {
         "longDesc" : "<br>\n Input data rows are ordered by order rules, ordered result is emitted on output port. <br>\n <br>\n  *  <br>\n  <b>StateFull : Yes,</b> Operator aggregates input over application window. <br>\n  <b>Partitions : Yes, </b> This operator is also unifier on output port. <br>\n  <br>\n <b>Ports</b>:<br>\n <b> inport : </b> Input hash map(row) port, expects HashMap&lt;String,Object&gt;<<br>\n <b> outport : </b> Output hash map(row) port, emits  HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : </b> <br>\n <b> oredrByRules : </b>List of order by rules for tuples.",
         "shortDesc" : "<p>\n This operator provides sql oredr by operator semantic over luve stream data",
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.OrderByOperator","category" : "streamquery",
         "displayName" : "Order by operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : [
            {
               "name" : "descending",
               "type" : "boolean",
               "canSet" : true,
               "description" : "isDescending",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n Please refer to {@link com.datatorrent.lib.streamquery.InnerJoinOperator} for\n details.\n\n <b> Properties : </b> <br>\n <b> isLeftJoin : </b> Left join flag. <br>\n <b> isFullJoin : </b> Full join flag. <br>",
         "shortDesc" : "This operator provides sql left/right/full outer join metric semantic on\n live stream",
         "inputPorts" : [
            {
               "name" : "inport1",
               "optional" : false,
               "description" : "Input port 1.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            },
            {
               "name" : "inport2",
               "optional" : false,
               "description" : "Input port 2.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.OuterJoinOperator","category" : "streamquery",
         "displayName" : "Outer join operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : [
            {
               "name" : "fullJoin",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "joinCondition",
               "type" : "com.datatorrent.lib.streamquery.condition.Condition",
               "canSet" : true,
               "description" : "the joinCondition",
               "canGet" : true,
               "properties" : []
            }
         ]
      },
      {
         "longDesc" : "<br>\n <b>StateFull : Yes,</b> Operator aggregates input over application window. <br>\n <b>Partitions : No, </b> will yield wrong result(s). <br>\n <br>\n <b>Ports : </b> <br>\n <b>inport : </b> expect tuple for type T. <br>\n <b>outport : </b> emits tuple for type T. <br>\n <br>\n <b> Properties : </b> <br>\n <b> functions : </b> Sql function for rows. <br>",
         "shortDesc" : "<p>\n This operator applies sql top/limit semantic on incoming tuple(s)",
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.SelectFunctionOperator","category" : "streamquery",
         "displayName" : "Select function operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : "<br>\n Stream rows passing condition are emitted on output port stream. <br>\n <br>\n <b>StateFull : NO,</b> all row data is processed in current time window. <br>\n <b>Partitions : Yes, </b> No Input dependency among input rows. <br>\n <br>\n <b>Ports</b>:<br>\n <b> inport : </b> Input hash map(row) port, expects\n HashMap&lt;String,Object&gt;<<br>\n <b> outport : </b> Output hash map(row) port, emits\n HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <b> <br>\n <b> condition : </b> Select condition for selecting rows. <br>\n <b> columns : </b> Column names/aggregate functions for select. <br>\n <br>",
         "shortDesc" : "This operator provides sql select query semantic on live data stream",
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.SelectOperator","category" : "streamquery",
         "displayName" : "Select operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : [
            {
               "name" : "condition",
               "type" : "com.datatorrent.lib.streamquery.condition.Condition",
               "canSet" : true,
               "canGet" : false,
               "properties" : []
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n Stream rows passing condition are emitted on output port stream. <br>\n <br>\n <b>StateFull : NO,</b> all row data is processed in current time window. <br>\n <b>Partitions : Yes, </b> No Input dependency among input rows. <br>\n <br>\n <b>Ports</b>:<br>\n <b> inport : </b> Input hash map(row) port, expects\n HashMap&lt;String,Object&gt;<<br>\n <b> outport : </b> Output hash map(row) port, emits\n HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <b> <br>\n <b> topValue : </b> top values count. <br>\n <b> isPercentage : </b> top values count is percentage flag.\n <br>",
         "shortDesc" : "This operator provides sql top select query semantic on live data stream",
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.SelectTopOperator","category" : "streamquery",
         "displayName" : "Select top operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : [
            {
               "name" : "percentage",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "topValue",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "<br>\n  Stream rows passing condition are emitted on output port stream. <br>\n  <br>\n  <b>StateFull : NO,</b> all row data is processed in current time window. <br>\n  <b>Partitions : Yes, </b> No Input dependency among input rows. <br>\n  <br>\n <b>Ports</b>:<br>\n <b> inport : </b> Input hash map(row) port, expects HashMap&lt;String,Object&gt;<<br>\n <b> outport : </b> Output hash map(row) port, emits  HashMap&lt;String,Object&gt;<br>\n <br>\n <b> Properties : <b> <br>\n <b> condition : </b> Select condition for selecting rows. <br>\n <b> columns : </b> Column names/aggregate functions for select. <br>\n <br>",
         "shortDesc" : "This operator provides sql select query semantic on live data stream",
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "description" : "Input port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.streamquery.UpdateOperator","category" : "streamquery",
         "displayName" : "Update operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Output port.",
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "properties" : [
            {
               "name" : "condition",
               "type" : "com.datatorrent.lib.streamquery.condition.Condition",
               "canSet" : true,
               "canGet" : false,
               "properties" : []
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "<p>CompareFilterTuples class.</p>",
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "tupleType" : "java.util.Map<k, java.lang.Integer>"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.CompareFilterTuples","category" : "testbench",
         "displayName" : "Compare filter tuples",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "tupleType" : "java.util.Map<k, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "redisport",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.Integer, java.lang.String>"
            }
         ],
         "properties" : [
            {
               "name" : "compareType",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "shortDesc" : "<p>CountOccurance class.</p>",
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.CountOccurance","category" : "testbench",
         "displayName" : "Count occurance",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "dimensionOut",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            },
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "tupleType" : "java.util.Map<k, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "total",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Integer>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The aim is to create a load with pair of keys<p>\n <br>\n Examples of pairs include<br>\n publisher,advertizer<br>\n automobile,model<br>\n <br>\n The keys to be inserted are given by the property <b>keys</b>. Users can choose to insert their\n own values via property <b>values</b>. Insertion can be done as replacement, addition, multiply,\n or append (append is not yet supported)<br>. For each incoming key users can provide an insertion\n probability for the insert keys. This allows for randomization of the insert key choice<br><br>\n <br>\n <b>Tuple Schema</b>: Each tuple is HashMap<String, Double> on both the ports. Currently other schemas are not supported<br>\n <b>Port Interface</b><br>\n <b>data</b>: emits HashMap<String,Double><br>\n <b>event</b>: expects HashMap<String,Double><br>\n <br>\n <b>Properties</b>:\n None<br>\n <br>\n Compile time checks are:<br>\n <b>keys</b> cannot be empty<br>\n <b>values</b> if specified has to be comma separated doubles and their number must match the number of keys<br>\n <b>weights</b> if specified the format has to be \"key1:val1,val2,...,valn;key2:val1,val2,...,valn;...\", where n has to be\n number of keys in parameter <b>keys</b>. If not specified all weights are equal<br>\n <br>\n <br>\n <b>Benchmarks</b>: This node has been benchmarked at over 5 million tuples/second in local/inline mode<br>",
         "shortDesc" : "Takes a in stream event and adds to incoming keys to create a new tuple that is emitted on output port data",
         "inputPorts" : [
            {
               "name" : "event",
               "optional" : false,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Double>"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.EventClassifier","category" : "testbench",
         "displayName" : "Event classifier",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "data",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Double>"
            }
         ],
         "properties" : [
            {
               "name" : "keyMap",
               "type" : "java.util.HashMap",
               "canSet" : true,
               "canGet" : false,
               "properties" : [
                  {
                     "name" : "empty",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The aim is to create a load with pair of keys<p>\n <br>\n Examples of pairs include<br>\n publisher,advertizer<br>\n automobile,model<br>\n <br>\n The keys to be inserted are given by the property <b>keys</b>. Users can choose to insert their\n own values via property <b>values</b>. Insertion can be done as replacement, addition, multiply,\n or append (append is not yet supported)<br>. For each incoming key users can provide an insertion\n probability for the insert keys. This allows for randomization of the insert key choice<br><br>\n <br>\n <b>Tuple Schema</b>: Each tuple is HashMap<String, Double> on both the ports. Currently other schemas are not supported<br>\n <b>Port Interface</b><br>\n <b>data</b>: emits HashMap<String,Double><br>\n <b>event</b>: expects HashMap<String,Double><br>\n <br>\n <b>Properties</b>:\n None<br>\n <br>\n Compile time checks are:<br>\n <b>keys</b> cannot be empty<br>\n <b>values</b> if specified has to be comma separated doubles and their number must match the number of keys<br>\n <b>weights</b> if specified the format has to be \"key1:val1,val2,...,valn;key2:val1,val2,...,valn;...\", where n has to be\n number of keys in parameter <b>keys</b>. If not specified all weights are equal<br>\n <br>\n <br>\n <b>Benchmarks</b>: This node has been benchmarked at over 5 million tuples/second in local/inline mode<br>",
         "shortDesc" : "Takes a in stream event and adds to incoming keys to create a new tuple that is emitted on output port data",
         "inputPorts" : [
            {
               "name" : "event",
               "optional" : false,
               "tupleType" : "class java.lang.Number"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.EventClassifierNumberToHashDouble","category" : "testbench",
         "displayName" : "Event classifier number to hash double",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "data",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Double>"
            }
         ],
         "properties" : [
            {
               "name" : "key",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "seedend",
               "type" : "int",
               "canSet" : true,
               "description" : "seed end",
               "canGet" : true
            },
            {
               "name" : "seedstart",
               "type" : "int",
               "canSet" : true,
               "description" : "seed start",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Creates tuples and keeps emitting them on the output port \"data\"<p>\n <br>\n The load is generated as per config parameters. This class is mainly meant for testing\n nodes.<br>\n It does not need to be windowed. It would just create tuple stream upto the limit set\n by the config parameters.<br>\n <b>Ports</b>:\n <b>string_data</b>: emits String<br>\n <b>hash_data</b>: emits HashMap<String,Double><br>\n <b>count<b>: emits HashMap<String, Number>, contains per window count of throughput<br>\n <br>\n <b>Tuple Schema</b>: Has two choices HashMap<String, Double>, or String<br><br>\n <b>Port Interface</b>:It has only one output port \"data\" and has no input ports<br><br>\n <b>Properties</b>:\n <b>keys</b> is a comma separated list of keys. This key are the <key> field in the tuple<br>\n <b>values</b> are comma separated list of values. This value is the <value> field in the tuple. If not specified the values for all keys are 0.0<br>\n <b>weights</b> are comma separated list of probability weights for each key. If not specified the weights are even for all keys<br>\n <b>tuples_blast</b> is the total number of tuples sent out before the thread returns control. The default value is 10000<br>\n <b>max_windows_count</b>The number of windows after which the node would shut down. If not set, the node runs forever<br>\n <br>\n Compile time checks are:<br>\n <b>keys</b> cannot be empty<br>\n <b>values</b> if specified has to be comma separated doubles and their number must match the number of keys<br>\n <b>weights</b> if specified has to be comma separated integers and number of their number must match the number of keys<br>\n <b>tuples_blast</b>If specified must be an integer<br>\n <br>\n\n Compile time error checking includes<br>\n <b>Benchmarks></b>: Send as many tuples in in-line mode, the receiver just counts the tuples and drops the object<br>\n String schema does about 26 Million tuples/sec in throughput<br>\n HashMap schema does about 10 Million tuples/sec in throughput<br>",
         "shortDesc" : "Generates synthetic load",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.testbench.EventGenerator","category" : "testbench",
         "displayName" : "Event generator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Number>"
            },
            {
               "error" : false,
               "name" : "hash_data",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Double>"
            },
            {
               "error" : false,
               "name" : "string_data",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            }
         ],
         "properties" : [
            {
               "name" : "keys",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "maxCountOfWindows",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "rollingWindowCount",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "tuplesBlast",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "values",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "weights",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "Data is immediately emitted on output port data.\n Emits number of tuples on port count<p>\n The aim is to create a random movement\n <br>\n Examples of application includes<br>\n random motion<br>\n <br>\n <br>\n Description: tbd\n <br>\n <b>Tuple Schema</b>: Each tuple is HashMap<String, ArrayList> on both the ports. Currently other schemas are not supported<br>\n <b>Port Interface</b><br>\n <b>seed</b>: The seed data for setting up the incrementor data to work on<br>\n <b>increment</b>: Small random increments to the seed data. This now creates a randomized change in the seed<br>\n <b>data</b>: Output of seed + increment<br>\n <b>count</b>: Emits number of processed tuples per window<br>\n <br>\n <b>Properties</b>:\n <br>keys: In case the value has multiple dimensions. They can be accessed via keys<br>\n <br>delta: The max value from an increment. The value on increment port is treated as a \"percent\" of this delta<br>\n Compile time checks are:<br>\n <br>\n <b>Benchmarks</b>: The benchmark was done in local/inline mode<br>\n Processing tuples on seed port are at 3.5 Million tuples/sec<br>\n Processing tuples on increment port are at 10 Million tuples/sec<br>\n <br>",
         "shortDesc" : "Takes in a seed stream on port seed and then on increments this data based on increments on port increment",
         "inputPorts" : [
            {
               "name" : "increment",
               "optional" : false,
               "tupleType" : "java.util.HashMap<java.lang.String, java.util.HashMap<java.lang.String, java.lang.Integer>>"
            },
            {
               "name" : "seed",
               "optional" : false,
               "tupleType" : "java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.Integer>>"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.EventIncrementer","category" : "testbench",
         "displayName" : "Event incrementer",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Integer>"
            },
            {
               "error" : false,
               "name" : "data",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.String>"
            }
         ],
         "properties" : [
            {
               "name" : "delta",
               "type" : "double",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The aim is to create another stream representing a subsection of incoming load<p>\n <br>\n Examples of pairs include<br>\n publisher,advertizer<br>\n automobile,model<br>\n <br>\n <b>Ports</b>:\n <b>data</b>: expects HashMap<String,T>\n <b>filter</b>:\n The keys to be inserted are given by the property <b>keys</b>. Users can choose to insert their\n own values via property <b>values</b>.<br>\n For each incoming key users can provide an insertion\n probability for the insert keys. This allows for randomization of the insert key choice<br><br>\n <br>\n Benchmarks: This node has been benchmarked at over 22 million tuples/second in local/inline mode<br>\n\n <b>Tuple Schema</b>: Each tuple is HashMap<String, Double> on both the ports. Currently other schemas are not supported<br>\n <br>\n <b>Properties</b>:\n <br>\n Compile time checks are:<br>\n <br>",
         "shortDesc" : "Filters the tuples as per the filter (pass through percent) and emits them",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.HashMap<java.lang.String, T>"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.FilterClassifier","category" : "testbench",
         "displayName" : "Filter classifier",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "filter",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, T>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The aim is to create another stream representing a subsection of incoming load<p>\n <br>\n Examples of pairs include<br>\n publisher,advertizer<br>\n automobile,model<br>\n <br>\n The keys to be inserted are given by the property <b>keys</b>. Users can choose to insert their\n own values via property <b>values</b>.<br>\n For each incoming key users can provide an insertion\n probability for the insert keys. This allows for randomization of the insert key choice<br><br>\n <br>\n <b>Tuple Schema</b>: Each tuple is HashMap<String, Double> on both the ports. Currently other schemas are not supported<br>\n <b>Port Interface</b><br>\n <b>out_data</b>: Output port for emitting the new tuple<br>\n <b>in_data</b>: Input port for receiving the incoming tuple<br>\n <br>\n <b>Properties</b>:\n <b>keys</b> is a comma separated list of keys. This key are the insert keys in the tuple<br>\n <b>values</b> are comma separated list of values. This value is for insertion into the <value> field in the tuple. also called \"insert value\". If not specified the incoming values are not changed<br>\n <b>weights</b> are comma separated list of probability weights for each incoming key. For each incoming key the weights have to be provided. If this parameter is empty all the weights are even for all keys<br>\n <b>percent<b>A number between 0 and 100. This is the percent of the time a new tuple is created. If say the number is 1, then a randomly selected 1 tuple out of 100 would create an output typle<br>\n <br>\n Compile time checks are:<br>\n <b>keys</b> cannot be empty<br>\n <b>values</b> if not provided the incoming value is passed through<br>\n <b>weights</b> if specified the format has to be \"key1:val1,val2,...,valn;key2:val1,val2,...,valn;...\", where n has to be\n number of keys in parameter <b>keys</b>. If not specified all weights are equal<br>\n <b>filter</b> The first number has to be less than the second and both have to be positive<br>\n <br>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n This node has been benchmarked at over 20 million tuples/second in local/inline mode<br>\n <br>",
         "shortDesc" : "Takes in a stream data and filters the tuples, and only emits tuples as per pass filter numbers provided\n on output port filter",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.HashMap<java.lang.String, T>"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.FilteredEventClassifier","category" : "testbench",
         "displayName" : "Filtered event classifier",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "filter",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, T>"
            }
         ],
         "properties" : [
            {
               "name" : "keyMap",
               "type" : "java.util.HashMap",
               "canSet" : true,
               "canGet" : false,
               "properties" : [
                  {
                     "name" : "empty",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "keyWeights",
               "type" : "java.util.HashMap",
               "canSet" : true,
               "canGet" : false,
               "properties" : [
                  {
                     "name" : "empty",
                     "type" : "boolean",
                     "canSet" : false,
                     "canGet" : true
                  }
               ]
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "passFilter",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "totalFilter",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "shortDesc" : "<p>HttpStatusFilter class.</p>",
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.String>"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.HttpStatusFilter","category" : "testbench",
         "displayName" : "Http status filter",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Integer>"
            }
         ],
         "properties" : [
            {
               "name" : "filterStatus",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "<p>KeyValSum class.</p>",
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Integer>"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.KeyValSum","category" : "testbench",
         "displayName" : "Key val sum",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Integer>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Creates tuples using random numbers and keeps emitting them on the output port string_data and integer_data<p>\n <br>\n The load is generated as per config parameters. This class is mainly meant for testing nodes by creating a random number within\n a range at a very high throughput. This node does not need to be windowed. It would just create tuple stream upto the limit set\n by the config parameters.<br>\n <br>\n <b>Tuple Schema</b>: Has two choices Integer, or String<br><br>\n <b>Port Interface</b>\n <b>string_data</b>: Emits String tuples<br>\n <b>integer_data</b>: Emits Integer tuples<br>\n <b>Properties</b>:\n <b>key</b> is an optional parameter, the generator sends an HashMap if key is specified<br>\n <b>min_value</b> is the minimum value of the range of numbers. Default is 0<br>\n <b>max_value</b> is the maximum value of the range of numbers. Default is 100<br>\n <b>tuples_burst</b> is the total amount of tuples sent by the node before handing over control. The default\n value is 10000. A high value does not help as if window has space the control is immediately returned for mode processing<br>\n <b>string_schema</b> controls the tuple schema. For string set it to \"true\". By default it is \"false\" (i.e. Integer schema)<br>\n <br>\n Compile time checks are:<br>\n <b>min_value</b> has to be an integer<br>\n <b>max_value</b> has to be an integer and has to be >= min_value<br>\n <b>tuples_burst</b>If specified must be an integer<br>\n <br>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n This node has been benchmarked at over 10 million tuples/second in local/inline mode<br>\n<br>\n Compile time error checking includes<br>\n <br>",
         "shortDesc" : "Generates synthetic load",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.testbench.RandomEventGenerator","category" : "testbench",
         "displayName" : "Random event generator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "integer_data",
               "optional" : true,
               "tupleType" : "class java.lang.Integer"
            },
            {
               "error" : false,
               "name" : "string_data",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            }
         ],
         "properties" : [
            {
               "name" : "maxcountofwindows",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "maxvalue",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "minvalue",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "tuplesBlast",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "tuplesBlastIntervalMillis",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "<p>RedisSumOper class.</p>",
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "tupleType" : "class java.lang.Integer"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.RedisSumOper","category" : "testbench",
         "displayName" : "Redis sum oper",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.Integer, java.lang.Integer>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The new tuple is emitted\n on the output ports string_data and hash_data<p>\n <br>\n Examples of getting seed distributions include<br>\n Chages in mobile co-ordinates of a phone<br>\n Random changes on motion of an object<br>\n <br>\n The seed is created from the values of properties <b>seed_start</b>, and <b>seed_end</b>\n <br>\n <b>Default schema</b>:<br>\n Schema for port <b>data</b>: The default schema is HashMap<String, ArrayList<valueData>>, where valueData is class{String, Integer}<br>\n <b>String schema</b>: The string is \"key;valkey1:value1;valkey2:value2;...\"<br>\n <b>HashMap schema</b>: Key is String, and Value is a ArrrayList<String, Number><br>\n The value in both the schemas is an integer (for choice of strings, these are enum values)\n <br>\n <b>Port Interface</b><br>\n <b>data1</b>: Expects tuples of type <T><br>\n <b>data2</b>: Expects tuples of type <T><br>\n <b>string_data</b>: Emits new classified seed of schema String<br>\n <b>hash_data</b>: Emits new classified seed of schema HashMap<String, HashMap<String, T>><br>\n <br>\n <b>Properties</b>:\n <b>seed_start</b>: An integer for the seed to start from<br>\n <b>seed_end</b>: An integer for the seed to end with<br>\n <br>string_schema</b>: If set to true, operates in string schema mode<br>\n <br>key</b>: Classifier keys to be inserted in order for each incoming tuple. Format is \"key1,key1start, key1end; key2, key2start, key2end;...\"\n <br>\n Compile time checks are:<br>\n <b>seed_start</b>Has to be an integer<br>\n <b>sedd_end</b>Has to be an integer<br>\n <b>key</b>If provided has to be in format \"key1,key1start,key1end;key2, key2start, key2end; ...\"\n <br>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n String: Benchmarked at over 13 million tuples/second in local/in-line mode<br>\n Integer: Benchmarked at over 7 million tuples/second in local/in-line mode<br>\n <br>",
         "shortDesc" : "Generates seeds and merges data as it comes in from input ports (data1, and data2)",
         "inputPorts" : [
            {
               "name" : "data1",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            },
            {
               "name" : "data2",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.SeedEventClassifier","category" : "testbench",
         "displayName" : "Seed event classifier",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "hash_data",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.util.HashMap<java.lang.String, T>>"
            },
            {
               "error" : false,
               "name" : "string_data",
               "optional" : true,
               "tupleType" : "class java.lang.String"
            }
         ],
         "properties" : [
            {
               "name" : "key1",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "key2",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "seedend",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "seedstart",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "The new tuple is emitted\n on the output port keyvalpair_list, val_list, string_data, val_data<p>\n <br>\n Examples of getting seed distributions include<br>\n Clients data of a company for every clientId (key is clienId)<br>\n Persons age, gender, for every phone number (key is phone number)<br>\n Year, color, mileage for every car make (key is car make model)<br>\n <br>\n The classification to be done is based on the value of the property <b>key</b>. This property provides all the classification\n information and their ranges<br>The range of values for the key is given in the format described below<br>\n <br>\n <b>Benchmarks</b>: Generate as many tuples as possible in inline mode<br>\n HashMap<String, String>: 8 million/sec with no classification; 1.8 million tuples/sec with classification<br>\n HashMap<Sring, ArrayList<Integer>>: 8 million/sec with no classification; 3.5 million tuples/sec with classification<br>\n <br>\n <b>Default schema</b>:<br>\n Schema for port <b>data</b>: The default schema is HashMap<String, ArrayList<valueData>>, where valueData is class{String, Integer}<br>\n <b>String schema</b>: The string is \"key;valkey1:value1;valkey2:value2;...\"<br>\n <b>HashMap schema</b>: Key is String, and Value is a ArrrayList<String, Number><br>\n The value in both the schemas is an integer (for choice of strings, these are enum values)\n <br>\n <b>Port Interface</b><br>\n <b>data</b>: Output port for emitting the new classified seed<br>\n <br>\n <b>Properties</b>:\n <b>seed_start</b>: An integer for the seed to start from<br>\n <b>seed_end</b>: An integer for the seed to end with<br>\n <br>string_schema</b>: If set to true, operates in string schema mode<br>\n <br>key</b>: Classifier keys to be inserted randomly. Format is \"key1,key1start, key1end; key2, key2start, key2end;...\"\n <br>\n Compile time checks are:<br>\n <b>seed_start</b>Has to be an integer<br>\n <b>seed_end</b>Has to be an integer<br>\n <b>key</b>If provided has to be in format \"key1,key1start,key1end;key2, key2start, key2end; ...\"\n <br>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n With key: Benchmarked at over 1 million tuples/second in local/in-line mode<br>\n Without key: Benchmarked at over 4 million tuples/second in local/in-line mode<br>",
         "shortDesc" : "Generates one time seed load based on range provided for the keys, and adds new classification to incoming keys",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.testbench.SeedEventGenerator","category" : "testbench",
         "displayName" : "Seed event generator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "keyvalpair_list",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.util.ArrayList<com.datatorrent.lib.util.KeyValPair>>"
            },
            {
               "error" : false,
               "name" : "string_data",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.String>"
            },
            {
               "error" : false,
               "name" : "val_data",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.String>"
            },
            {
               "error" : false,
               "name" : "val_list",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.util.ArrayList<java.lang.Integer>>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "seedend",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "seedstart",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "Stram now has this data for all streams via its web-service<br>\n Expects incoming stream to be a HashMap<String, Integer> and add all integer values to compute throughput. These\n values are throughput per window from upstream operators. On end of window this total and average is emitted<p>\n <br>\n <br>\n Benchmarks: This node has been benchmarked at over 5 million tuples/second in local/inline mode<br>\n\n <b>Tuple Schema</b>\n Each input tuple is HashMap<String, Integer><br>\n Output tuple is a HashMap<String, Integer>, where strings are throughputs, averages etc<br>\n <b>Port Interface</b><br>\n <b>count</b>: Output port for emitting the results<br>\n <b>data</b>: Input port for receiving the incoming tuple<br>\n <br>\n <b>Properties</b>:\n rolling_window_count: Number of windows to average over\n <br>\n Compile time checks are:<br>\n none\n <br>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n Benchmarked at over 17 million tuples/second in local/in-line mode<br>\n <br>",
         "shortDesc" : "Developed for a demo",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.ThroughputCounter","category" : "testbench",
         "displayName" : "Throughput counter",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "count",
               "optional" : true,
               "tupleType" : "java.util.HashMap<java.lang.String, java.lang.Number>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "rollingWindowCount",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "<p>TopOccurance class.</p>",
         "inputPorts" : [
            {
               "name" : "inport",
               "optional" : false,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Integer>"
            }
         ],
         "name" : "com.datatorrent.lib.testbench.TopOccurance","category" : "testbench",
         "displayName" : "Top occurance",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "gtThreshHold",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.Integer, java.lang.String>"
            },
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "tupleType" : "java.util.Map<java.lang.Integer, java.lang.String>"
            }
         ],
         "properties" : [
            {
               "name" : "n",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "threshHold",
               "type" : "int",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "<p>AlertEscalationOperator class.</p>",
         "inputPorts" : [
            {
               "name" : "in",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.util.AlertEscalationOperator","category" : "util",
         "displayName" : "Alert escalation operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "alert",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "properties" : [
            {
               "name" : "activated",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "alertInterval",
               "type" : "long",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "timeout",
               "type" : "long",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "Alert Escalation Operator intended for use with Alerts.",
         "inputPorts" : [
            {
               "name" : "in",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.util.AlertThreeLevelTimedEscalationOperator","category" : "util",
         "displayName" : "Alert three level timed escalation operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "alert",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            },
            {
               "error" : false,
               "name" : "alert2",
               "optional" : true,
               "tupleType" : "class java.lang.Object"
            },
            {
               "error" : false,
               "name" : "alert3",
               "optional" : true,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "properties" : [
            {
               "name" : "activated",
               "type" : "boolean",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "alertInterval",
               "type" : "long",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "levelOneAlertTime",
               "type" : "long",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "levelThreeAlertTime",
               "type" : "long",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "levelTwoAlertTime",
               "type" : "long",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "timeout",
               "type" : "long",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "each one key belongs only to one partition. The final output of the\n combiner is a simple merge into a single object that implements Map",
         "shortDesc" : "Combiner for an output port that emits object with Map<K,V> interface and has the processing done\n with sticky key partition, i.e",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.ArrayHashMapFrequent","category" : "util",
         "displayName" : "Array hash map frequent",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mergedport",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            }
         ],
         "properties" : [
            {
               "name" : "least",
               "type" : "boolean",
               "canSet" : true,
               "description" : "least flag",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Default is true<br>\n <b>filterBy</b>: List of keys to filter on. Default is an empty filter<br>\n <br>\n <b>Specific compile time checks</b>: None<br>\n <b>Specific run time checks</b>: None<br>\n <br>\n <b>Benchmarks</b>: Not done as there are no ports on this operator<br>\n <br>\n <br>",
         "shortDesc" : "Base class for operators that enables filtering of of keys to be processed<p>\n By default no filtering would be done as inverse is set to true and filterBy would be empty unless set<br>\n <br>\n <b>Ports</b>: None<br>\n <br>\n <b>Properties</b>:<br>\n <b>inverse</b>: if set to true the key in the filter will block tuple",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.BaseFilteredKeyValueOperator","category" : "util",
         "displayName" : "Base filtered key value operator",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "Base class for operators that allows cloneKey for enabling users to use mutable objects<p>",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.BaseKeyOperator","category" : "util",
         "displayName" : "Base key operator",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "Base class for operators that allows cloneValue and cloneKey for enabling users to use mutable objects<p>",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.BaseKeyValueOperator","category" : "util",
         "displayName" : "Base key value operator",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Base class for line split operators.<br>\n processToken, and processSubToken are called for each token. Users should override calls backs to intercept at any level.<p>\n This operator is a base class for pass through operators<br>\n <br>\n Ideal for applications like word count\n Ports:<br>\n <b>data</b>: expects String<br>",
         "shortDesc" : "Base class for splitting lines into tokens and tokens into sub-tokens",
         "inputPorts" : [
            {
               "name" : "data",
               "optional" : false,
               "tupleType" : "class java.lang.String"
            }
         ],
         "name" : "com.datatorrent.lib.util.BaseLineTokenizer","category" : "util",
         "displayName" : "Base line tokenizer",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "splitBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitBy",
               "canGet" : true
            },
            {
               "name" : "splitTokenBy",
               "type" : "java.lang.String",
               "canSet" : true,
               "description" : "splitTokenBy",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Supported values are \"lte\", \"lt\", \"eq\",\n \"neq\", \"gt\", \"gte\". Default is \"eq\"<br>\n <br>\n Compile time checks<br>\n Key must be non empty<br>\n Value must be able to convert to a \"double\"<br>\n Compare string, if specified, must be one of \"lte\", \"lt\", \"eq\", \"neq\", \"gt\",\n \"gte\"<br>\n <br>\n Run time checks<br>\n none<br>",
         "shortDesc" : "Base class that sets up the operator functionality needed for match based\n operators\n <p>\n <br>\n Ports:<br>\n none <br>\n Properties:<br>\n <b>key</b>: The key on which compare is done<br>\n <b>value</b>: The value to compare with<br>\n <b>comp<b>: The compare function",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.BaseMatchOperator","category" : "util",
         "displayName" : "Base match operator",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "cmp",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "key",
               "type" : "java.lang.Object",
               "canSet" : true,
               "description" : "key",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseMatchOperator$supported_type",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "value",
               "type" : "double",
               "canSet" : true,
               "description" : "value",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Provides basic methods for value conversion<p>\n <br>\n <b>Benchmarks</b>: Not done as emit is done by sub-classes<br>\n <br>\n <br>\n <br>",
         "shortDesc" : "Base class for operators that take in &lt;K,V extends Number&gt;",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.BaseNumberKeyValueOperator","category" : "util",
         "displayName" : "Base number key value operator",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "Provides basic methods for value conversion<p>\n <br>\n <b>Benchmarks</b>: Not done as there is emit tuple is done by sub-classes<br>\n <br>\n <br>\n <br>",
         "shortDesc" : "Base class for operators that take in V extends Number",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.BaseNumberValueOperator","category" : "util",
         "displayName" : "Base number value operator",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "Count unique occurrences of keys within an application window",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.BaseUniqueKeyCounter","category" : "util",
         "displayName" : "Base unique key counter",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "Only one tuple per unique key is emitted on end of window, so this operator is not bound by outbound throughput<br>",
         "shortDesc" : "Count unique occurances of keys within a window<p>\n <br>\n <b>Benchmarks</b>: Blast as many tuples as possible in inline mode<br>\n Operator processes > 110 million tuples/sec",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.BaseUniqueKeyValueCounter","category" : "util",
         "displayName" : "Base unique key value counter",
         "outputPorts" : [],
         "properties" : [
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "<p>DimensionTimeBucketSumOperator class.</p>",
         "inputPorts" : [
            {
               "name" : "in",
               "optional" : false,
               "tupleType" : "java.util.Map<java.lang.String, java.lang.Object>"
            }
         ],
         "name" : "com.datatorrent.lib.util.DimensionTimeBucketSumOperator","category" : "util",
         "displayName" : "Dimension time bucket sum operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "out",
               "optional" : false,
               "description" : "First String key is the bucket Second String key is the key Third String\n key is the field",
               "tupleType" : "java.util.Map<java.lang.String, java.util.Map<java.lang.String, java.lang.Number>>"
            }
         ],
         "properties" : [
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "timeBucketFlags",
               "type" : "int",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "timeKeyName",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "timeZone",
               "type" : "java.util.TimeZone",
               "canSet" : true,
               "canGet" : false,
               "properties" : [
                  {
                     "name" : "DSTSavings",
                     "type" : "int",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "ID",
                     "type" : "java.lang.String",
                     "canSet" : true,
                     "canGet" : true
                  },
                  {
                     "name" : "displayName",
                     "type" : "java.lang.String",
                     "canSet" : false,
                     "canGet" : true
                  },
                  {
                     "name" : "rawOffset",
                     "type" : "int",
                     "canSet" : true,
                     "canGet" : true
                  }
               ]
            }
         ]
      },
      {
         "shortDesc" : "The filter operator that uses JavaScript, intended for use with alerts",
         "inputPorts" : [
            {
               "name" : "in",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "name" : "com.datatorrent.lib.util.JavaScriptFilterOperator","category" : "util",
         "displayName" : "Java script filter operator",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "out",
               "optional" : false,
               "tupleType" : "class java.lang.Object"
            }
         ],
         "properties" : [
            {
               "name" : "functionName",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "setupScript",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "each one key belongs only to one partition. The final output of the\n combiner is a simple merge into a single object that implements Map",
         "shortDesc" : "Combiner for an output port that emits object with Map<K,V> interface and has the processing done\n with sticky key partition, i.e",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.UnifierArrayHashMapFrequent","category" : "util",
         "displayName" : "Unifier array hash map frequent",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mergedport",
               "optional" : true,
               "tupleType" : "java.util.ArrayList<java.util.HashMap<K, java.lang.Integer>>"
            }
         ],
         "properties" : [
            {
               "name" : "least",
               "type" : "boolean",
               "canSet" : true,
               "description" : "least flag",
               "canGet" : true
            }
         ]
      },
      {
         "shortDesc" : "Unifier for array list output port.",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.UnifierArrayList","category" : "util",
         "displayName" : "Unifier array list",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mergedport",
               "optional" : true,
               "description" : "Output port",
               "tupleType" : "java.util.ArrayList<K>"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : "each one key belongs only to one partition. The final output of the\n combiner is a simple merge into a single object that implements Map",
         "shortDesc" : "Combiner for an output port that emits object with Map<K,V> interface and has the processing done\n with sticky key partition, i.e",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.UnifierBooleanAnd","category" : "util",
         "displayName" : "Unifier boolean and",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mergedport",
               "optional" : true,
               "tupleType" : "class java.lang.Boolean"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : "each one key belongs only to one partition. The final output of the\n combiner is a simple merge into a single object that implements Map",
         "shortDesc" : "Combiner for an output port that emits object with Map<K,V> interface and has the processing done\n with sticky key partition, i.e",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.UnifierBooleanOr","category" : "util",
         "displayName" : "Unifier boolean or",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mergedport",
               "optional" : true,
               "tupleType" : "class java.lang.Boolean"
            }
         ],
         "properties" : []
      },
      {
         "shortDesc" : "This unifier aggregates occurrence of key on output port and emits key/total occurrence value pair.",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.UnifierCountOccurKey","category" : "util",
         "displayName" : "Unifier count occur key",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "outport",
               "optional" : true,
               "description" : "Key/occurrence value pair output port.",
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, java.lang.Integer>"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : "each one key belongs only to one partition. The final output of the\n combiner is a simple merge into a single object that implements Map",
         "shortDesc" : "Combiner for an output port that emits object with Map<K,V> interface and has the processing done\n with sticky key partition, i.e",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.UnifierHashMap","category" : "util",
         "displayName" : "Unifier hash map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mergedport",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : "each one key belongs only to one partition. The final output of the\n combiner is a simple merge into a single object that implements Map",
         "shortDesc" : "Combiner for an output port that emits object with Map<K,V> interface and has the processing done\n with sticky key partition, i.e",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.UnifierHashMapFrequent","category" : "util",
         "displayName" : "Unifier hash map frequent",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mergedport",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            }
         ],
         "properties" : [
            {
               "name" : "least",
               "type" : "boolean",
               "canSet" : true,
               "description" : "least flag",
               "canGet" : true
            }
         ]
      },
      {
         "longDesc" : "The combiner needs to add values of a key from every partition",
         "shortDesc" : "Combiner for an output port that emits object with Map<K,Integer> interface and has the processing done\n with round robin partitions",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.UnifierHashMapInteger","category" : "util",
         "displayName" : "Unifier hash map integer",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mergedport",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, java.lang.Integer>"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : "The first element in the ArrayList is high, the next is low",
         "shortDesc" : "Combiner for an output port that emits object with Map<K,ArrayList<V>(2)> interface and has the processing done\n with round robin partition",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.UnifierHashMapRange","category" : "util",
         "displayName" : "Unifier hash map range",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mergedport",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, com.datatorrent.lib.util.HighLow<V>>"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : "key,vals pairs need to be combined back together",
         "shortDesc" : "Combiner for an output port that emits object with Map<K,V> interface and has the processing done\n with round robin partition for a Sum metric, i.e",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.UnifierHashMapSumKeys","category" : "util",
         "displayName" : "Unifier hash map sum keys",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mergedport",
               "optional" : true,
               "tupleType" : "java.util.HashMap<K, V>"
            }
         ],
         "properties" : [
            {
               "name" : "filterBy",
               "type" : "[Ljava.lang.Object;",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "inverse",
               "type" : "boolean",
               "canSet" : true,
               "description" : "the value of inverse",
               "canGet" : true
            },
            {
               "name" : "keyValPairStreamCodec",
               "type" : "java.lang.Class",
               "canSet" : false,
               "canGet" : true
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "java.lang.Class",
               "canSet" : true,
               "canGet" : false
            }
         ]
      },
      {
         "longDesc" : "The first element in the ArrayList is high, the next is low",
         "shortDesc" : "Combiner for an output port that emits object with Map<K,ArrayList<V>(2)> interface and has the processing done\n with round robin partition",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.UnifierKeyValRange","category" : "util",
         "displayName" : "Unifier key val range",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mergedport",
               "optional" : true,
               "tupleType" : "com.datatorrent.lib.util.KeyValPair<K, com.datatorrent.lib.util.HighLow<V>>"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : "each one key belongs only to one partition. The final output of the\n combiner is a simple merge into a single object that implements Map",
         "shortDesc" : "Combiner for an output port that emits object with Map<K,V> interface and has the processing done\n with sticky key partition, i.e",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.UnifierMap","category" : "util",
         "displayName" : "Unifier map",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mergedport",
               "optional" : true,
               "tupleType" : "java.util.Map<K, V>"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : "The first element in the ArrayList is high, the next is low",
         "shortDesc" : "cd\n Combiner for an output port that emits object with ArrayList<V>(2) interface and has the processing done\n with round robin partition",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.UnifierRange","category" : "util",
         "displayName" : "Unifier range",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mergedport",
               "optional" : true,
               "tupleType" : "com.datatorrent.lib.util.HighLow<V>"
            }
         ],
         "properties" : []
      },
      {
         "longDesc" : "The final tuple is sum of all partition values",
         "shortDesc" : "Combiner for an output port that emits object with <V> interface and has the processing done\n with round robin partitioning",
         "inputPorts" : [],
         "name" : "com.datatorrent.lib.util.UnifierSumNumber","category" : "util",
         "displayName" : "Unifier sum number",
         "outputPorts" : [
            {
               "error" : false,
               "name" : "mergedport",
               "optional" : true,
               "tupleType" : "class java.lang.Number"
            }
         ],
         "properties" : [
            {
               "name" : "VType",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : true,
               "canGet" : false
            },
            {
               "name" : "name",
               "type" : "java.lang.String",
               "canSet" : true,
               "canGet" : true
            },
            {
               "name" : "type",
               "type" : "com.datatorrent.lib.util.BaseNumberValueOperator$V_TYPE",
               "canSet" : false,
               "canGet" : true
            }
         ]
      }
   ]
}
